[
  {
    "timestamp": "2017-07-05T17:20:19.747974",
    "conversation_id": 180,
    "user": "Willow",
    "message": "if i remember correctly, this was what he wanteded to implement a non-alpha release"
  },
  {
    "timestamp": "2017-07-05T17:20:35.754536",
    "conversation_id": 180,
    "user": "Garth",
    "message": "yeah"
  },
  {
    "timestamp": "2017-07-05T17:20:38.756073",
    "conversation_id": 180,
    "user": "Garth",
    "message": "ok"
  },
  {
    "timestamp": "2017-07-05T17:22:24.800948",
    "conversation_id": 180,
    "user": "Garth",
    "message": "that’s bad, right?"
  },
  {
    "timestamp": "2017-07-05T17:30:20.001651",
    "conversation_id": 180,
    "user": "Trudie",
    "message": "trying to use clojure 1.9 from emacs with cider, but when I run cider I get"
  },
  {
    "timestamp": "2017-07-05T17:31:56.041091",
    "conversation_id": 180,
    "user": "Willow",
    "message": "can you run a lein repl in this project without emacs?"
  },
  {
    "timestamp": "2017-07-05T17:33:45.085695",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "upgrade to a newer core.async and it goes away"
  },
  {
    "timestamp": "2017-07-05T17:34:11.096109",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "<@Trudie> ^ forgot to tag"
  },
  {
    "timestamp": "2017-07-05T17:47:53.416052",
    "conversation_id": 180,
    "user": "Owen",
    "message": "also works with lists"
  },
  {
    "timestamp": "2017-07-05T17:48:23.427271",
    "conversation_id": 180,
    "user": "Trudie",
    "message": "<@Margaret> Hm... now to find out which dependency has the wrong core.async version..."
  },
  {
    "timestamp": "2017-07-05T17:49:29.452562",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "you can specify your own core.async version and the deps will have to use it"
  },
  {
    "timestamp": "2017-07-05T17:49:39.456277",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "or use `lein deps :tree` to see where it comes in"
  },
  {
    "timestamp": "2017-07-05T17:50:03.465637",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "<@Owen> Isn't that O(n) on the size of the new collection though? Why not just `(into [] (filter-nth ...) input)`"
  },
  {
    "timestamp": "2017-07-05T17:50:09.467814",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "(that is, if your deps is earlier in the deps list it overrides)"
  },
  {
    "timestamp": "2017-07-05T17:51:52.505760",
    "conversation_id": 180,
    "user": "Owen",
    "message": "<@Sandy> yea the underlying impl is O(n), but your snippet looks like O(n) as well"
  },
  {
    "timestamp": "2017-07-05T17:52:17.515141",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "oh it is"
  },
  {
    "timestamp": "2017-07-05T17:52:47.525821",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "but the whole idea behind conj and the like is that they are not O(n) on the size of the new collection"
  },
  {
    "timestamp": "2017-07-05T17:53:11.534971",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "so I would flag both of our approaches in a code review for being a possible bottleneck"
  },
  {
    "timestamp": "2017-07-05T17:53:30.542016",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I don't think you can do better than O(n) for that task on a vector"
  },
  {
    "timestamp": "2017-07-05T17:54:00.552495",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "that's why we suggested finger trees"
  },
  {
    "timestamp": "2017-07-05T17:54:40.567557",
    "conversation_id": 180,
    "user": "Owen",
    "message": "performance and just being able to do the task elegantly are two separate things"
  },
  {
    "timestamp": "2017-07-05T17:55:03.575861",
    "conversation_id": 180,
    "user": "Owen",
    "message": "sometimes you need to remove an element from the middle of a vector and it's not a bottleneck"
  },
  {
    "timestamp": "2017-07-05T17:55:24.583502",
    "conversation_id": 180,
    "user": "Owen",
    "message": "unreasonable to require every operation to be O(1)"
  },
  {
    "timestamp": "2017-07-05T17:55:36.587965",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "even then I'd be tempted to use take + drop to do the same thing"
  },
  {
    "timestamp": "2017-07-05T17:55:43.590699",
    "conversation_id": 180,
    "user": "Willow",
    "message": "`(apply concat ((juxt (partial take 3) (partial drop (inc 3))) [1 2 3 4 5 6]))`"
  },
  {
    "timestamp": "2017-07-05T17:55:48.592404",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "or split-at or whatever it's called"
  },
  {
    "timestamp": "2017-07-05T17:56:10.600931",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "core.rrb-vector could be used aswell to keep performance sub linear"
  },
  {
    "timestamp": "2017-07-05T17:56:12.601461",
    "conversation_id": 180,
    "user": "Owen",
    "message": "`nthpath` can encapsulate the optimal method"
  },
  {
    "timestamp": "2017-07-05T17:56:18.603843",
    "conversation_id": 180,
    "user": "Owen",
    "message": "whatever it is"
  },
  {
    "timestamp": "2017-07-05T17:56:25.606516",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "has log subvec & log vector cat"
  },
  {
    "timestamp": "2017-07-05T17:56:54.616994",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I haven't investigated the optimal implementation for this particular task, but whatever it is it can be encapsulated behind the abstraction"
  },
  {
    "timestamp": "2017-07-05T17:57:16.625351",
    "conversation_id": 180,
    "user": "Owen",
    "message": "specter is optimal for most of its functionality"
  },
  {
    "timestamp": "2017-07-05T17:57:27.629826",
    "conversation_id": 180,
    "user": "Trudie",
    "message": "<@Margaret> Thanks, that worked! What a relief! Nothing more annoying than debugging the dev environment when in a hurry :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-05T17:57:30.631108",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "on that we'll agree to disagree"
  },
  {
    "timestamp": "2017-07-05T17:57:44.636169",
    "conversation_id": 180,
    "user": "Owen",
    "message": "what are we disagreeing on?"
  },
  {
    "timestamp": "2017-07-05T17:58:08.645013",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "I think nathan was talking about performance & tim about api?"
  },
  {
    "timestamp": "2017-07-05T17:58:37.655816",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "yeah, I mean the problem is that specter in this case abstracts so much away that I really don't know what it's going to do"
  },
  {
    "timestamp": "2017-07-05T17:59:12.668521",
    "conversation_id": 180,
    "user": "Owen",
    "message": "you don't know what it will do semantically or performance-wise?"
  },
  {
    "timestamp": "2017-07-05T17:59:58.686457",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "performance wise, there's a underlying assumption in specter that it will do \"the right thing\" while maintaining the data type. Many times I don't care about the datatype, instead I care about performance."
  },
  {
    "timestamp": "2017-07-05T18:00:29.699511",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "so our definitions of \"optimal\" differ"
  },
  {
    "timestamp": "2017-07-05T18:01:17.717874",
    "conversation_id": 180,
    "user": "Owen",
    "message": "the original questioner asked about removing an element from a vector, which sounds like he cared about maintaining the datatype"
  },
  {
    "timestamp": "2017-07-05T18:02:04.734927",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "perhaps, but sadly I've run into too much code already that falls apart because someone did (nth ...) on a seq."
  },
  {
    "timestamp": "2017-07-05T18:03:33.767322",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I really don't understand what you're asserting there"
  },
  {
    "timestamp": "2017-07-05T18:03:43.770800",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "And what does \"the same type\" mean in the face of PersistentArrayMap? (I'm actually wondering on this one)"
  },
  {
    "timestamp": "2017-07-05T18:04:50.793994",
    "conversation_id": 180,
    "user": "Owen",
    "message": "`MAP-VALS` or `ALL` on a `PersistentArrayMap` output another `PersistentArrayMap`"
  },
  {
    "timestamp": "2017-07-05T18:05:05.799114",
    "conversation_id": 180,
    "user": "Owen",
    "message": "even one that's already above the threshold"
  },
  {
    "timestamp": "2017-07-05T18:05:15.802518",
    "conversation_id": 180,
    "user": "Owen",
    "message": "which is surprisingly possible"
  },
  {
    "timestamp": "2017-07-05T18:05:50.814523",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "and if I do something that grows it?"
  },
  {
    "timestamp": "2017-07-05T18:06:02.818115",
    "conversation_id": 180,
    "user": "Owen",
    "message": "you can't grow it with those operations"
  },
  {
    "timestamp": "2017-07-05T18:06:24.825505",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "whatabout ops that you can grow with"
  },
  {
    "timestamp": "2017-07-05T18:06:49.833980",
    "conversation_id": 180,
    "user": "Owen",
    "message": "they'll convert to PersistentHashMap"
  },
  {
    "timestamp": "2017-07-05T18:07:51.854808",
    "conversation_id": 180,
    "user": "Owen",
    "message": "maintaining the literal type isn't the goal of specter, rather to maintain a type with the same expected semantics"
  },
  {
    "timestamp": "2017-07-05T18:08:23.865264",
    "conversation_id": 180,
    "user": "Owen",
    "message": "PersistentHashMap and PersistentArrayMap are implementation details"
  },
  {
    "timestamp": "2017-07-05T18:09:04.879088",
    "conversation_id": 180,
    "user": "Owen",
    "message": "that specter maintains PersistentArrayMap on `ALL` and `MAP-VALS` is because that's the most performance optimal way to do the transformation"
  },
  {
    "timestamp": "2017-07-05T18:10:15.902308",
    "conversation_id": 180,
    "user": "Willow",
    "message": "I've used an array map to maintain ordering for writing out columnar data, a persistenhashmap would make my site more dynamic than i like."
  },
  {
    "timestamp": "2017-07-05T18:10:44.912102",
    "conversation_id": 180,
    "user": "Owen",
    "message": "yea there are isolated cases like that where it matters but not for 99% of use cases"
  },
  {
    "timestamp": "2017-07-05T18:10:48.913340",
    "conversation_id": 180,
    "user": "Willow",
    "message": "for sure"
  },
  {
    "timestamp": "2017-07-05T18:11:10.920471",
    "conversation_id": 180,
    "user": "Willow",
    "message": "i hate some of the subtleties of the clojure datatypes"
  },
  {
    "timestamp": "2017-07-05T18:11:33.927890",
    "conversation_id": 180,
    "user": "Willow",
    "message": "like conj being beginning of a vector and end of a seq"
  },
  {
    "timestamp": "2017-07-05T18:11:42.930837",
    "conversation_id": 180,
    "user": "Willow",
    "message": "or backwards sorry"
  },
  {
    "timestamp": "2017-07-05T18:12:36.948601",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "I also hate some of the side effects of these datatypes, and that's why I've backed off a bit from specter, hiding all these complexities behind a abstraction is nice, but it leaks in performance. How fast is \"remove nth\"? Well it depends..."
  },
  {
    "timestamp": "2017-07-05T18:12:48.952941",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "Same is true of recursive concat, conj, etc."
  },
  {
    "timestamp": "2017-07-05T18:13:05.958370",
    "conversation_id": 180,
    "user": "Willow",
    "message": "what do you mean \"side effects of these datatypes\"?"
  },
  {
    "timestamp": "2017-07-05T18:13:12.960780",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "bad wording, sorry"
  },
  {
    "timestamp": "2017-07-05T18:13:29.966029",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "\"subtleties of these datatypes\""
  },
  {
    "timestamp": "2017-07-05T18:13:32.967312",
    "conversation_id": 180,
    "user": "Willow",
    "message": "figured. but wanted to know what you meant"
  },
  {
    "timestamp": "2017-07-05T18:13:38.969170",
    "conversation_id": 180,
    "user": "Willow",
    "message": "ah yeah"
  },
  {
    "timestamp": "2017-07-05T18:14:43.988910",
    "conversation_id": 180,
    "user": "Owen",
    "message": "actually for most uses of specter it's extremely difficult to outperform it"
  },
  {
    "timestamp": "2017-07-05T18:14:47.989999",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "So yeah, back to the original problem, I think we should educate users of Clojure to say: \"What you are trying to do isn't supported natively by the datatype, you can fake it in these ways, but it's going to have performance problems with larger collections\"."
  },
  {
    "timestamp": "2017-07-05T18:15:02.994698",
    "conversation_id": 180,
    "user": "Owen",
    "message": "for most programmers I would say it's impossible because it requires too much internal knowledge of clojure"
  },
  {
    "timestamp": "2017-07-05T18:15:06.995859",
    "conversation_id": 180,
    "user": "Owen",
    "message": "<https://github.com/nathanmarz/specter/blob/master/src/clj/com/rpl/specter/navs.cljc#L253>"
  },
  {
    "timestamp": "2017-07-05T18:15:55.011554",
    "conversation_id": 180,
    "user": "Owen",
    "message": "that's 60% faster than next best method for transforming every value of a small map"
  },
  {
    "timestamp": "2017-07-05T18:16:39.025437",
    "conversation_id": 180,
    "user": "Owen",
    "message": "as for \"remove nth\", specter is probably not currently optimal but that's only because the work hasn't been put into it"
  },
  {
    "timestamp": "2017-07-05T18:16:54.029622",
    "conversation_id": 180,
    "user": "Owen",
    "message": "the abstraction can be optimal"
  },
  {
    "timestamp": "2017-07-05T18:18:03.051179",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "optimal given the input data type...that's the catch"
  },
  {
    "timestamp": "2017-07-05T18:18:27.058915",
    "conversation_id": 180,
    "user": "Owen",
    "message": "how is that a catch?"
  },
  {
    "timestamp": "2017-07-05T18:18:34.061183",
    "conversation_id": 180,
    "user": "Owen",
    "message": "it can run different code for different data types"
  },
  {
    "timestamp": "2017-07-05T18:20:31.097948",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "remove-nth will always be O(n) on a vector. No way to improve that. However, by educating users as to how the underlying collections work, maybe the'll reach for a different more optimal datatype."
  },
  {
    "timestamp": "2017-07-05T18:22:03.126784",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I 100% agree it's the programmer's responsibility to understand the data types they're using and the impacts of that, but that's completely orthogonal to specter"
  },
  {
    "timestamp": "2017-07-05T18:23:50.159800",
    "conversation_id": 180,
    "user": "Owen",
    "message": "specter lets you manipulate your data way more elegantly, especially compound or recursive data, and in many cases with far better performance"
  },
  {
    "timestamp": "2017-07-05T18:24:11.166375",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I completely reject characterizing it like some magic library with performance \"leaks\""
  },
  {
    "timestamp": "2017-07-05T18:25:35.191792",
    "conversation_id": 180,
    "user": "Berry",
    "message": "I don't think <@Sandy> was blaming specter for the \"leaks\" -- but rather, unless you already have a mental model of how the nested datatype looks, you can have a single piece of Specter code that is (1) very fast for certai nstructures and (2) very slow for other structures, because some stuff are O(log n) or O(n) depending on the underlying datastructure"
  },
  {
    "timestamp": "2017-07-05T18:27:07.219007",
    "conversation_id": 180,
    "user": "Owen",
    "message": "whatever the underlying types are, specter will do the operation in the fastest way"
  },
  {
    "timestamp": "2017-07-05T18:27:38.228675",
    "conversation_id": 180,
    "user": "Owen",
    "message": "it's the responsibility of the programmer to choose the most appropriate types for their app"
  },
  {
    "timestamp": "2017-07-05T18:28:10.238393",
    "conversation_id": 180,
    "user": "Owen",
    "message": "criticizing specter for a programmer choosing inappropriate types doesn't make sense"
  },
  {
    "timestamp": "2017-07-05T18:30:44.284436",
    "conversation_id": 180,
    "user": "Berry",
    "message": "1. I've studied specter a bit, even tried to implement a mini one myself. 2. I don't think I could do a better job myself. 3. I think \"leaky\" here just means -- as a programmer, you have to keep track of the underlying data structures, i.e. it's \"leaky\" in that you can't ignore the underlying details; not \"leaky\" as in space/time leakage."
  },
  {
    "timestamp": "2017-07-05T18:31:05.290781",
    "conversation_id": 180,
    "user": "Berry",
    "message": "I think this is the standard definition of \"leaky abstraction.\""
  },
  {
    "timestamp": "2017-07-05T18:31:19.294691",
    "conversation_id": 180,
    "user": "Owen",
    "message": "I wouldn't call that leaky"
  },
  {
    "timestamp": "2017-07-05T18:31:52.304260",
    "conversation_id": 180,
    "user": "Owen",
    "message": "\"leaky\" more appropriately refers to details that you have to worry about that should be encapsulated"
  },
  {
    "timestamp": "2017-07-05T18:33:24.330818",
    "conversation_id": 180,
    "user": "Berry",
    "message": "Quoting wikipedia: In software development, a leaky abstraction is an abstraction that exposes details and limitations of its underlying implementation to its users that should ideally be hidden away. But here, Spectre queries (or any other queries for that matter) are 'leaky' in that different data structures have different runtimes for different ops, and the programmer has to keep them in mind, so this isn't really abstracted away from the programmer. [I don't know a way to do this better.] [I think this 'leakiness' problem can not be solved -- i.e. any attempt to build a DSL that allows easy manip of heterogeneous datastructures will have to deal with this[]"
  },
  {
    "timestamp": "2017-07-05T18:34:17.346585",
    "conversation_id": 180,
    "user": "Berry",
    "message": "Just to be clear, I don't know of a way to improve Specter -- I think it's hit local optima -- and this 'leakiness' is a fundeamtanl problem due to different data structures having different runtimes."
  },
  {
    "timestamp": "2017-07-05T18:34:27.349599",
    "conversation_id": 180,
    "user": "Owen",
    "message": "data structures are never a detail that should be hidden away"
  },
  {
    "timestamp": "2017-07-05T18:35:15.363162",
    "conversation_id": 180,
    "user": "Owen",
    "message": "we're just quibbling over terminology, I think we agree on the underlying principle"
  },
  {
    "timestamp": "2017-07-05T18:36:02.376927",
    "conversation_id": 180,
    "user": "Berry",
    "message": "To someone who expects specter code to be \"what, not how\" it is leaky because they have to consider underlying datastructures. To somehow who expects to always keep data structuresin mind, it's not leaky. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-05T18:36:28.384609",
    "conversation_id": 180,
    "user": "Berry",
    "message": "Let's argue over something else,"
  },
  {
    "timestamp": "2017-07-05T18:36:43.388833",
    "conversation_id": 180,
    "user": "Berry",
    "message": "like ... where can i get a good set of exercises for learning how to write a nanopass compiler :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-05T18:37:00.393654",
    "conversation_id": 180,
    "user": "Berry",
    "message": "I'm watching the 2013 clojure conj <https://www.youtube.com/watch?v=Os7FE3J-U5Q> talk ... and I really want to try this out."
  },
  {
    "timestamp": "2017-07-05T18:39:45.440177",
    "conversation_id": 180,
    "user": "Owen",
    "message": "we can agree on that :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-05T18:41:17.465586",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "<@Berry> records for the AST, postwalk for the passes, run till fixpoint, about all there is too it"
  },
  {
    "timestamp": "2017-07-05T18:41:37.471014",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "or hashmaps even for the ast, whatever you prefer"
  },
  {
    "timestamp": "2017-07-05T18:43:15.497850",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "or you could get creative and event source a queue of characters and fold over it to generate a projection representing your compiled code"
  },
  {
    "timestamp": "2017-07-05T18:43:20.499063",
    "conversation_id": 180,
    "user": "Margaret",
    "message": "just kidding, don’t do that"
  },
  {
    "timestamp": "2017-07-05T18:43:34.502931",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "depending on your source and target you can do it without an ast"
  },
  {
    "timestamp": "2017-07-05T18:44:05.511724",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "if you say your target is a superset of your source, it is macroexpansion"
  },
  {
    "timestamp": "2017-07-05T18:44:12.513523",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "(or pretty close)"
  },
  {
    "timestamp": "2017-07-05T18:44:34.519740",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "true, but working with order dependant types is unpleasant"
  },
  {
    "timestamp": "2017-07-05T18:45:07.528686",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "may be better with spec, but {:keys [fn-name body]}) is easier than `[_ fn-name _ body]`"
  },
  {
    "timestamp": "2017-07-05T18:45:41.538347",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "sure"
  },
  {
    "timestamp": "2017-07-05T18:46:27.550805",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "<https://github.com/hiredman/qwerty> \"macroexpands\" a lisp in to something like go in parens, then the emitter strips the parens so you can feed it to the go compiler"
  },
  {
    "timestamp": "2017-07-05T18:46:45.555621",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "cool!"
  },
  {
    "timestamp": "2017-07-05T18:47:31.568442",
    "conversation_id": 180,
    "user": "Rebeca",
    "message": "I dunno if it rates an exclamation point, it was fun to fiddle with it for a while, then I gave up on it"
  },
  {
    "timestamp": "2017-07-05T18:47:36.569779",
    "conversation_id": 180,
    "user": "Berry",
    "message": "hmm, and if I write the passes as transducers, can I easily get a monolithic compiler out o fthis?"
  },
  {
    "timestamp": "2017-07-05T18:48:04.577556",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "you can, but you'll quickly find that some passes need to be run more than once, or need to be run before/after other passes"
  },
  {
    "timestamp": "2017-07-05T18:48:30.585030",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "tools.analyzer is a nano-pass compiler imo."
  },
  {
    "timestamp": "2017-07-05T18:48:33.585621",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "and in different traversal orders"
  },
  {
    "timestamp": "2017-07-05T18:48:51.590696",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "yeah that too."
  },
  {
    "timestamp": "2017-07-05T18:49:39.604165",
    "conversation_id": 180,
    "user": "Sandy",
    "message": "<@Kareen> does tools.analyzer.jvm still walk the AST backwards for locals clearing? Maybe I'm mis-remembering, but I thought that was cool the first time I saw it."
  },
  {
    "timestamp": "2017-07-05T18:50:00.609879",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "yeah"
  },
  {
    "timestamp": "2017-07-05T18:50:21.615730",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "makes the algorithm much simpler than walking forward & collecting usage points"
  },
  {
    "timestamp": "2017-07-05T18:50:45.622841",
    "conversation_id": 180,
    "user": "Kareen",
    "message": "I did it that way just because I couldn't understand the forward algorithm implemented in Compiler.java TBH :)"
  },
  {
    "timestamp": "2017-07-05T19:30:25.242282",
    "conversation_id": 182,
    "user": "Celestine",
    "message": "I'm struggling to wrap my head around clj-oauth. All the examples use twitter, but I can't seem to get it to work with Google. Google and twitter's terminology doesn't seem to be the same, and it's confusing the heck out of me. Are there any examples using google's api I can look at?"
  },
  {
    "timestamp": "2017-07-05T19:41:14.393296",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I'm having trouble with core.async pub/sub. It seems like there must be something I'm not understanding. I can see that my system sometimes is publishing a lot of events really close together. Say 20 within 2 seconds. There are times that all but one of my subscribe loops (event listeners) aren't doing anything during this burst of activity. Then a while later (a couple of min sometimes) during another burst of publish activity the subscribe loops come to life and grab some data and push on to the subscriber channels."
  },
  {
    "timestamp": "2017-07-05T19:41:44.400485",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I started out by not using any buffering on the channels. I'm not really clear when additional buffering makes sense or not"
  },
  {
    "timestamp": "2017-07-05T19:42:03.404722",
    "conversation_id": 182,
    "user": "Nita",
    "message": "It really seems like some of my published events are being lost"
  },
  {
    "timestamp": "2017-07-05T19:43:52.430126",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "the first thing to do is check that your topic-fn is returning values from the set of things you are subscribing to"
  },
  {
    "timestamp": "2017-07-05T19:43:53.430310",
    "conversation_id": 182,
    "user": "Nita",
    "message": "when just using (chan) for pub should my source threads block if the subscribers are idle?"
  },
  {
    "timestamp": "2017-07-05T19:44:15.435383",
    "conversation_id": 182,
    "user": "Nita",
    "message": "yea, I have lots of debug messages that all looks pretty good"
  },
  {
    "timestamp": "2017-07-05T19:44:25.437697",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "how sure are you?"
  },
  {
    "timestamp": "2017-07-05T19:44:35.440293",
    "conversation_id": 182,
    "user": "Nita",
    "message": "well I currently only have one topic"
  },
  {
    "timestamp": "2017-07-05T19:44:40.441418",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "like, are we talking strings you know are byte for byte the same?"
  },
  {
    "timestamp": "2017-07-05T19:45:05.447438",
    "conversation_id": 182,
    "user": "Nita",
    "message": "my topic is just a keyword"
  },
  {
    "timestamp": "2017-07-05T19:46:34.467820",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "the next thing to log would be the identity (pr-str prints out the identity hash if I recall) of each thing involved"
  },
  {
    "timestamp": "2017-07-05T19:47:17.477134",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "to make sure you are creating the pub/sub on the same channel you are publishing to, and you are subscribing to the same pub/sub you are publishing to"
  },
  {
    "timestamp": "2017-07-05T19:48:20.490996",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "if the channel you are publishing to isn't being consumed for some reason, your publishes with block if there is no buffer, and will block once the buffer is full"
  },
  {
    "timestamp": "2017-07-05T19:48:47.497467",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "if I recall, a pubsub will consume everything and just ignore messages it has no subscribers for"
  },
  {
    "timestamp": "2017-07-05T19:48:58.500167",
    "conversation_id": 182,
    "user": "Nita",
    "message": "right, that's the thing, it appears that my publishers never block"
  },
  {
    "timestamp": "2017-07-05T19:49:34.508442",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "so I would double check your topic-fn, make sure it returns what you think it does on the inputs to the channel"
  },
  {
    "timestamp": "2017-07-05T19:49:51.512636",
    "conversation_id": 182,
    "user": "Nita",
    "message": "when no buffer is supplied to the channel, does that mean it will block after the first put, until the first take?"
  },
  {
    "timestamp": "2017-07-05T19:50:28.521141",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "e.g. if your topic-fn is a keyword, and your messages are maps, calling a keyword on a map that doesn't contain it would just return nil"
  },
  {
    "timestamp": "2017-07-05T19:51:02.528780",
    "conversation_id": 182,
    "user": "Nita",
    "message": "yes, that is how my events are structured just as maps"
  },
  {
    "timestamp": "2017-07-05T19:51:36.536594",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "so invoke your topic-fn on one of the maps to see what it returns"
  },
  {
    "timestamp": "2017-07-05T19:52:28.548409",
    "conversation_id": 182,
    "user": "Nita",
    "message": "that's the thing it all works fine when I do it by hand, things get weird once there is lots of simulatneous activity"
  },
  {
    "timestamp": "2017-07-05T19:52:56.554664",
    "conversation_id": 182,
    "user": "Nita",
    "message": "based on my logging I can see all the topics that are published and those that are received by the listenr loops"
  },
  {
    "timestamp": "2017-07-05T19:52:57.554909",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "how do you know your publishers don't block?"
  },
  {
    "timestamp": "2017-07-05T19:54:48.580297",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I say that just based on my theads that push out lots of messges saying that they're publishing.... hmm wait you might be on to something"
  },
  {
    "timestamp": "2017-07-05T19:55:10.585370",
    "conversation_id": 182,
    "user": "Nita",
    "message": "my log message happens right before I push not after, I might be misinterpreting whats going on"
  },
  {
    "timestamp": "2017-07-05T19:55:24.588662",
    "conversation_id": 182,
    "user": "Nita",
    "message": "push=publish"
  },
  {
    "timestamp": "2017-07-05T19:57:41.620998",
    "conversation_id": 182,
    "user": "Nita",
    "message": "ok, made some changes to logging and restarting everyting,"
  },
  {
    "timestamp": "2017-07-05T19:58:18.629256",
    "conversation_id": 182,
    "user": "Nita",
    "message": "so could you help clarify about when is it appropriate to specify a buffer in these sceanrios?"
  },
  {
    "timestamp": "2017-07-05T19:58:23.630631",
    "conversation_id": 182,
    "user": "Margaret",
    "message": "If things lock up under lots of activity, and you aren't buffering, and lots is < thousands, I'd double check for blocking ops in your go blocks."
  },
  {
    "timestamp": "2017-07-05T19:59:04.639999",
    "conversation_id": 182,
    "user": "Nita",
    "message": "yea I'm not into thousands of events, generally should be less than 50/sec"
  },
  {
    "timestamp": "2017-07-05T20:00:25.660704",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "buffering is going to mask any problems with feedback you have"
  },
  {
    "timestamp": "2017-07-05T20:02:26.690351",
    "conversation_id": 182,
    "user": "Nita",
    "message": "ok, just got a big burst, it looks like I'm not blocking when I publish, the pre/postpublish log messages are all within the same millisecond"
  },
  {
    "timestamp": "2017-07-05T20:02:32.691718",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "it sounds like you are interfacing regular thread using code and core.async, and my bet is you are either using put! to publish or (async/go (>! ...)), when you should be using >!!"
  },
  {
    "timestamp": "2017-07-05T20:03:22.703307",
    "conversation_id": 182,
    "user": "Margaret",
    "message": "Also, go blocks can die without visible feedback or error messages, you could just get backed up as consumers silently fail."
  },
  {
    "timestamp": "2017-07-05T20:03:23.703677",
    "conversation_id": 182,
    "user": "Nita",
    "message": "yes, I'm using async/go >!"
  },
  {
    "timestamp": "2017-07-05T20:03:44.708545",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "the question is how you using it"
  },
  {
    "timestamp": "2017-07-05T20:03:48.709480",
    "conversation_id": 182,
    "user": "Nita",
    "message": "its funny but every example of pubsub I came across did it this way"
  },
  {
    "timestamp": "2017-07-05T20:04:24.717473",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "if you create a go block from a normal thread, you should wait for its result using <!!"
  },
  {
    "timestamp": "2017-07-05T20:05:09.727576",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "I mean, I am kind of guessing here and what are likely to be issues"
  },
  {
    "timestamp": "2017-07-05T20:05:42.735429",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "I still think it is some kind of issue with your topic-fn, but you have assured me it isn't"
  },
  {
    "timestamp": "2017-07-05T20:07:07.755203",
    "conversation_id": 182,
    "user": "Berry",
    "message": "is identical? guaranteed to be an O(1) time pointer comparison"
  },
  {
    "timestamp": "2017-07-05T20:07:28.760259",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "if the publishers aren't actually blocking, all the symptoms point to a disconnect between pub and sub, the likely reason is the result of topic-fn isn't what you think"
  },
  {
    "timestamp": "2017-07-05T20:08:25.773060",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "so I might do something like replace the topic fn with `(constantly 1)` make a channel subbed to 1, and verify it is getting all the traffic"
  },
  {
    "timestamp": "2017-07-05T20:08:59.780616",
    "conversation_id": 182,
    "user": "Nita",
    "message": "<@Rebeca> ok, but I think based on what <@Margaret> was saying is that my usage of go (>! ...) could be the prob"
  },
  {
    "timestamp": "2017-07-05T20:09:51.791639",
    "conversation_id": 182,
    "user": "Nita",
    "message": "literally all of my topics are the same {:transformer-event :ev1 or :ev2 or ev3}"
  },
  {
    "timestamp": "2017-07-05T20:10:23.798914",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "definitely, like I said, \"if publishers aren't actually blocking\" if they are blocking and you just can't tell, or they are just dying, then that would be your problem"
  },
  {
    "timestamp": "2017-07-05T20:11:10.808995",
    "conversation_id": 182,
    "user": "Nita",
    "message": "cool, I'm gonna change my publish to use >!! and see how that affects the situation"
  },
  {
    "timestamp": "2017-07-05T20:12:48.830482",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "`>!!` is really blocking, not for use in go blocks, only for use on real threads"
  },
  {
    "timestamp": "2017-07-05T20:13:12.835583",
    "conversation_id": 182,
    "user": "Nita",
    "message": "yea I took out the go block"
  },
  {
    "timestamp": "2017-07-05T20:13:38.841491",
    "conversation_id": 182,
    "user": "Nita",
    "message": "doesn't seem to be making any different behavior"
  },
  {
    "timestamp": "2017-07-05T20:14:01.846519",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "your producer threads are still not blocked?"
  },
  {
    "timestamp": "2017-07-05T20:15:08.861158",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I have a log message before the publish and another after, and they are always within a millisecond"
  },
  {
    "timestamp": "2017-07-05T20:15:18.863615",
    "conversation_id": 182,
    "user": "Nita",
    "message": "doesn't look blocked to me"
  },
  {
    "timestamp": "2017-07-05T20:16:10.875540",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "are you sure those aren't spurious log messages coming from threads left running from a previous attempt?"
  },
  {
    "timestamp": "2017-07-05T20:18:13.902869",
    "conversation_id": 182,
    "user": "Nita",
    "message": "valid question, I'll restart the whole shebang"
  },
  {
    "timestamp": "2017-07-05T20:19:10.915167",
    "conversation_id": 182,
    "user": "Nita",
    "message": "this is really puzzling to me."
  },
  {
    "timestamp": "2017-07-05T20:19:32.920092",
    "conversation_id": 182,
    "user": "Nita",
    "message": "given that I'm not buffering what are the scenarious that would cause events to be dropped?"
  },
  {
    "timestamp": "2017-07-05T20:21:21.943528",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "well, you could think events are being published when they are not, because your producers are just blocking. the topic-fn could be returning something you are not subscribed to so messages get dropped, or your subscribers do get the messages and just don't do anything"
  },
  {
    "timestamp": "2017-07-05T20:22:40.959941",
    "conversation_id": 182,
    "user": "Nita",
    "message": "givent that I only have 1 publication on one channel there should be no pub log messages that are publishing into nothing"
  },
  {
    "timestamp": "2017-07-05T20:22:53.962592",
    "conversation_id": 182,
    "user": "Nita",
    "message": "there are however of course several sub channels and loops"
  },
  {
    "timestamp": "2017-07-05T20:23:17.967525",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "are you sure you are subscribing to the same pubsub you are publishing to?"
  },
  {
    "timestamp": "2017-07-05T20:23:20.968290",
    "conversation_id": 182,
    "user": "Nita",
    "message": "ok, now i'm finally seeing some blocking"
  },
  {
    "timestamp": "2017-07-05T20:23:51.974550",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I see several pre publish logs, with no coresponding post publis logs"
  },
  {
    "timestamp": "2017-07-05T20:24:15.979522",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "right, that blocking is back pressure being communicated back from the downstream async bits, which are stuck where or going really slow"
  },
  {
    "timestamp": "2017-07-05T20:24:37.983930",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "are the down stream bits re-publishing to the same pubsub?"
  },
  {
    "timestamp": "2017-07-05T20:26:45.009623",
    "conversation_id": 182,
    "user": "Nita",
    "message": "no thats part of this whole business I've never been too clear on. I have no logic for re-publishing"
  },
  {
    "timestamp": "2017-07-05T20:27:49.022796",
    "conversation_id": 182,
    "user": "Nita",
    "message": "by downstream bits are you referring to the sub handlers?"
  },
  {
    "timestamp": "2017-07-05T20:28:06.026232",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "yes, things downstream of the pubsub"
  },
  {
    "timestamp": "2017-07-05T20:28:46.034648",
    "conversation_id": 182,
    "user": "Nita",
    "message": "oh, well my sub handler loops publish on to the sub channels, is that what you mean?"
  },
  {
    "timestamp": "2017-07-05T20:29:00.037364",
    "conversation_id": 182,
    "user": "Nita",
    "message": "the sub channels are obviously differnt than the pub channel"
  },
  {
    "timestamp": "2017-07-05T20:29:14.040105",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "that could be the source of deadlock"
  },
  {
    "timestamp": "2017-07-05T20:29:47.046948",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "whenever you have a feedback loop (a process that feeds output back in to its input) it is really easy to deadlock"
  },
  {
    "timestamp": "2017-07-05T20:30:27.055479",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "since the sub channels don't have a buffer, publishing to them blocks until someone else consumes from them"
  },
  {
    "timestamp": "2017-07-05T20:31:17.065790",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "depending on what you are doing, adding a buffer might fix it, or might not, because a buffer is fixed in size, and if you feedback more than the size of the buffer, you are deadlocked again"
  },
  {
    "timestamp": "2017-07-05T20:32:53.084765",
    "conversation_id": 182,
    "user": "Nita",
    "message": "ok let me get this straight, my listener loops take off of the sub channel"
  },
  {
    "timestamp": "2017-07-05T20:33:16.089440",
    "conversation_id": 182,
    "user": "Nita",
    "message": "the clojure publisher logic puts on to the sub channel based on the topic-fn"
  },
  {
    "timestamp": "2017-07-05T20:33:51.096296",
    "conversation_id": 182,
    "user": "Nita",
    "message": "all of my sub loopse run forever taking from the sub channels and then calling a handler"
  },
  {
    "timestamp": "2017-07-05T20:34:45.107071",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I think you're saying if my sub loops get stuck then that could be causing the deadlock, like handler never returning I guess"
  },
  {
    "timestamp": "2017-07-05T20:35:21.114054",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "oh"
  },
  {
    "timestamp": "2017-07-05T20:35:35.116789",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "if you are calling a function that never returns that is another problem"
  },
  {
    "timestamp": "2017-07-05T20:35:45.118821",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "you cannot do that kind of thing from a go block"
  },
  {
    "timestamp": "2017-07-05T20:35:48.119377",
    "conversation_id": 182,
    "user": "Nita",
    "message": "that would all make sense if the whole thing locked up and never recovered, but that doesn't happen"
  },
  {
    "timestamp": "2017-07-05T20:35:57.121062",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "it will block the threadpool go blocks use"
  },
  {
    "timestamp": "2017-07-05T20:36:00.121615",
    "conversation_id": 182,
    "user": "Nita",
    "message": "no I don't thnk I'm calling a function that runs forever"
  },
  {
    "timestamp": "2017-07-05T20:36:06.122779",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I'm not seeing anything like that"
  },
  {
    "timestamp": "2017-07-05T20:36:30.127505",
    "conversation_id": 182,
    "user": "Nita",
    "message": "if my handlers got stuck the whole system should eventually lock up, and that never happens"
  },
  {
    "timestamp": "2017-07-05T20:36:59.133474",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "or if they run slow, or if they do blocking stuff on the async threadpool"
  },
  {
    "timestamp": "2017-07-05T20:38:14.148157",
    "conversation_id": 182,
    "user": "Nita",
    "message": "the handlers can be slow compared to the publishers, when there is lots of activity, they all run in their own go blocks"
  },
  {
    "timestamp": "2017-07-05T20:38:34.152130",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "you are ddosing the async threadpool"
  },
  {
    "timestamp": "2017-07-05T20:39:14.159588",
    "conversation_id": 182,
    "user": "Nita",
    "message": "too much activity for the go blocks that the handlers are in?"
  },
  {
    "timestamp": "2017-07-05T20:39:24.161753",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "I dunno about too much"
  },
  {
    "timestamp": "2017-07-05T20:39:54.167815",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "it sounds like everything is behaving as designed, feedback is slowing your publishers to a rate that matches the consuming"
  },
  {
    "timestamp": "2017-07-05T20:40:15.172125",
    "conversation_id": 182,
    "user": "Nita",
    "message": "well except for the lost events"
  },
  {
    "timestamp": "2017-07-05T20:40:23.173699",
    "conversation_id": 182,
    "user": "Nita",
    "message": "that I still don't understand"
  },
  {
    "timestamp": "2017-07-05T20:40:29.174722",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "in this case, the processes reading from the sub channels aren't able to get time on the threadpool to run"
  },
  {
    "timestamp": "2017-07-05T20:40:56.179905",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "are you sure they are lost? or are they just waiting to run in a completely backed up system"
  },
  {
    "timestamp": "2017-07-05T20:42:13.194604",
    "conversation_id": 182,
    "user": "Nita",
    "message": "you see the thing is, my publishers are bursty, there are short periods of busy activity and long periods of relative calm,"
  },
  {
    "timestamp": "2017-07-05T20:42:49.201441",
    "conversation_id": 182,
    "user": "Nita",
    "message": "given that the system never locks up, all events should eventually be handled in the calm period, but that isn't what is happening."
  },
  {
    "timestamp": "2017-07-05T20:43:29.209034",
    "conversation_id": 182,
    "user": "Nita",
    "message": "aggh, I'm gonna have head home soon, thanks for being a sounding board on this pub/sub stuff"
  },
  {
    "timestamp": "2017-07-05T20:44:12.217488",
    "conversation_id": 182,
    "user": "Rebeca",
    "message": "you might want to look at one of the pipeline variants, it may simplify things a lot"
  },
  {
    "timestamp": "2017-07-05T20:45:19.230939",
    "conversation_id": 182,
    "user": "Nita",
    "message": "I didn't even know about pipelines, something new to learn tomorrow I guess"
  },
  {
    "timestamp": "2017-07-05T20:45:58.238505",
    "conversation_id": 182,
    "user": "Nita",
    "message": "cool, thanks, have a good evening (or what ever timezone appropriate part of day is appropriate)"
  },
  {
    "timestamp": "2017-07-14T14:35:08.754673",
    "conversation_id": 291,
    "user": "Roger",
    "message": "I am trying to rename the keys from a hashmap with rename-keys I have ``` (def a {a \"A\", b \"B\"} ```"
  },
  {
    "timestamp": "2017-07-14T14:35:55.779685",
    "conversation_id": 291,
    "user": "Roger",
    "message": "and use ``` (set/rename-keys a {:a :aa, :b :bb} ```"
  },
  {
    "timestamp": "2017-07-14T14:36:33.800262",
    "conversation_id": 291,
    "user": "Roger",
    "message": "but nothing changes"
  },
  {
    "timestamp": "2017-07-14T14:37:17.822611",
    "conversation_id": 291,
    "user": "Roger",
    "message": "Am I doing something wrong?"
  },
  {
    "timestamp": "2017-07-14T14:38:00.845802",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "nice"
  },
  {
    "timestamp": "2017-07-14T14:38:24.857754",
    "conversation_id": 291,
    "user": "Ok",
    "message": "Try `(def a {:a \"A\", :b \"B\"})`"
  },
  {
    "timestamp": "2017-07-14T14:38:25.858392",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "well for one, `a` and `b` are both unquote symbols which evaluate to some value where `:a` and `:b` are keywords that evaluate to themselves"
  },
  {
    "timestamp": "2017-07-14T14:40:50.935535",
    "conversation_id": 291,
    "user": "Roger",
    "message": "the problem is that I receive the Json as it is"
  },
  {
    "timestamp": "2017-07-14T14:41:03.942176",
    "conversation_id": 291,
    "user": "Roger",
    "message": "I can not change the a variable"
  },
  {
    "timestamp": "2017-07-14T14:41:22.952551",
    "conversation_id": 291,
    "user": "Roger",
    "message": "it was just an example; But i need to modify the names of the keys"
  },
  {
    "timestamp": "2017-07-14T14:41:39.961536",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "sounds like your real problem is that you aren’t using the return value of rename-keys"
  },
  {
    "timestamp": "2017-07-14T14:42:06.975148",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "nothing in clojure actually modifies the built in maps, vectors, lists, etc. - they return new ones you can use"
  },
  {
    "timestamp": "2017-07-14T14:42:10.977489",
    "conversation_id": 291,
    "user": "Roger",
    "message": "I did a println"
  },
  {
    "timestamp": "2017-07-14T14:42:16.980261",
    "conversation_id": 291,
    "user": "Ok",
    "message": "You’re probably getting string keys."
  },
  {
    "timestamp": "2017-07-14T14:42:18.981447",
    "conversation_id": 291,
    "user": "Roger",
    "message": "but it printed the same a"
  },
  {
    "timestamp": "2017-07-14T14:42:37.991059",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "don’t use println to look at data, use prn"
  },
  {
    "timestamp": "2017-07-14T14:42:47.996178",
    "conversation_id": 291,
    "user": "Brady",
    "message": "If you are working with JSON, you're likely getting the map as `{\"a\" \"A\", \"b\" \"B\"}`"
  },
  {
    "timestamp": "2017-07-14T14:42:49.997425",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "I bet a is actually “a” yeah"
  },
  {
    "timestamp": "2017-07-14T14:43:02.004009",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "so you need rename-keys {“a” :aa} etc."
  },
  {
    "timestamp": "2017-07-14T14:44:12.041222",
    "conversation_id": 291,
    "user": "Roger",
    "message": "mmm I tried but I got this error :"
  },
  {
    "timestamp": "2017-07-14T14:44:21.045385",
    "conversation_id": 291,
    "user": "Roger",
    "message": "java.lang.ClassCastException: clojure.core$map$fn__4781 cannot be cast to clojure.lang.IPersistentMap"
  },
  {
    "timestamp": "2017-07-14T14:45:14.073386",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "that means you used `(map f)` where it expected a hash-map"
  },
  {
    "timestamp": "2017-07-14T14:45:56.095301",
    "conversation_id": 291,
    "user": "Roger",
    "message": "wait, yes!!!!"
  },
  {
    "timestamp": "2017-07-14T14:46:18.107318",
    "conversation_id": 291,
    "user": "Roger",
    "message": "I was doing it to another functionality"
  },
  {
    "timestamp": "2017-07-14T14:46:22.109356",
    "conversation_id": 291,
    "user": "Roger",
    "message": "now it is working"
  },
  {
    "timestamp": "2017-07-14T14:46:35.116096",
    "conversation_id": 291,
    "user": "Roger",
    "message": "rename-keys with \"a\" as key"
  },
  {
    "timestamp": "2017-07-14T14:47:46.153806",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "for future reference, this is the difference between `println` and `prn` ```kingfisher.core=> (println {\"a\" 0 \"b\" 1}) {a 0, b 1} nil kingfisher.core=> (prn {\"a\" 0 \"b\" 1}) {\"a\" 0, \"b\" 1} nil```"
  },
  {
    "timestamp": "2017-07-14T14:49:15.200540",
    "conversation_id": 291,
    "user": "Ok",
    "message": "There’s probably other option — you can get json with keys as keywords, just look to documentation of your json lib."
  },
  {
    "timestamp": "2017-07-14T14:49:47.217670",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "that’s sloppy though - there are valid json keys that are not valid keywords, so then you end up creating keywords that shouldn’t exist"
  },
  {
    "timestamp": "2017-07-14T14:55:10.390767",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "well that is a whole other thing"
  },
  {
    "timestamp": "2017-07-14T14:56:03.419242",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "(are valid keywords only those keywords that can be produced by the reader?)"
  },
  {
    "timestamp": "2017-07-14T14:57:05.452427",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "but generally, turning keys in to keywords all the time is something every project (I have worked on) does, and I hate it"
  },
  {
    "timestamp": "2017-07-14T14:57:29.465074",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "but if you do it you are doing the same thing that everyone does"
  },
  {
    "timestamp": "2017-07-14T15:04:28.685267",
    "conversation_id": 291,
    "user": "Aldo",
    "message": "\"valid keywords\" are those that follow the rules in the docs imo, but the reader will create some keywords that don't if asked"
  },
  {
    "timestamp": "2017-07-14T15:09:04.822526",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "which docs?"
  },
  {
    "timestamp": "2017-07-14T15:09:43.841775",
    "conversation_id": 291,
    "user": "Aldo",
    "message": "<https://clojure.org/reference/reader#_literals>"
  },
  {
    "timestamp": "2017-07-14T15:09:59.849087",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "those a docs on keywords that the reader can read"
  },
  {
    "timestamp": "2017-07-14T15:10:12.855514",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "(which is why they are under the reader section)"
  },
  {
    "timestamp": "2017-07-14T15:11:28.892269",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "I've seen this discussion play out over and over again in chat, on the mailing list, and in jira issues, and it seems like the core team's general stance is what the reader excepts doesn't define what is valid"
  },
  {
    "timestamp": "2017-07-14T15:12:41.926889",
    "conversation_id": 291,
    "user": "Aldo",
    "message": "the reader accepts more than those docs, but those docs do give a guarantee of what the reader will accept. so for me they make sense as a definition of valid. not the same thing as \"whatever the reader accepts\""
  },
  {
    "timestamp": "2017-07-14T15:13:13.941699",
    "conversation_id": 291,
    "user": "Aldo",
    "message": "eg ``` cljs.user=> :& :& ```"
  },
  {
    "timestamp": "2017-07-14T15:13:43.955746",
    "conversation_id": 291,
    "user": "Aldo",
    "message": "but it's not documented that that will always work (or become reserved for some special system/core usage) so I wouldn't use it"
  },
  {
    "timestamp": "2017-07-14T15:14:07.967367",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "<https://dev.clojure.org/jira/browse/CLJ-1527>"
  },
  {
    "timestamp": "2017-07-14T15:15:11.998371",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "the point is, just because the reader only constructs certain kinds of symbols and keywords, that doesn't restrict the Symbol and Keyword data types to only construct those types of symbols and keywords"
  },
  {
    "timestamp": "2017-07-14T15:15:36.010371",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "<https://dev.clojure.org/jira/browse/CLJ-17>"
  },
  {
    "timestamp": "2017-07-14T15:17:22.059541",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "<https://dev.clojure.org/jira/browse/CLJ-2009>"
  },
  {
    "timestamp": "2017-07-14T15:17:25.060919",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "etc etc etc"
  },
  {
    "timestamp": "2017-07-14T15:17:42.069167",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "And at one point, very specifically, the Clojure/core team made `:1` (numeric keywords) illegal in the reader on the grounds that they weren't sanctioned by the docs -- and they broke a bunch of code out there in the wild so they reverted the reader change."
  },
  {
    "timestamp": "2017-07-14T15:18:55.103783",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "I was affected by that change (one of the OSS libraries I maintain) but I would have been perfectly happy to change `:1` to `(keyword \"1\")` -- which they said they would _not_ break... but they still reverted the change :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-14T15:19:53.132351",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "So we have prior art for the reader being publicly known to accept things that are not considered \"correct\" and not getting fixed -- and a statement that `keyword` (and, similarly, `symbol`) being able to produce \"junk\" output from arbitrary input :neutral_face:"
  },
  {
    "timestamp": "2017-07-14T15:20:06.138625",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "the issue isn't that the reader and the reader docs are not in 100% agreement about what is a readable keyword (that is another issue) the issue is that a valid readable keyword is not the same as a valid keyword"
  },
  {
    "timestamp": "2017-07-14T15:20:31.150682",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "for example, the keywords json libraries create for map keys never pass through the reader"
  },
  {
    "timestamp": "2017-07-14T15:20:42.156074",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "so they can be any crazy thing"
  },
  {
    "timestamp": "2017-07-14T15:20:50.159882",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "Exactly my point, yes."
  },
  {
    "timestamp": "2017-07-14T15:21:36.181745",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "which negates the purpose of turning them in to keywords in the first place, because the only reason people turn them in to keywords is since most maps in clojure use keyword keys, they more comfortable with them"
  },
  {
    "timestamp": "2017-07-14T15:22:07.196083",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "Speed of lookup over plain strings. In theory."
  },
  {
    "timestamp": "2017-07-14T15:23:30.234825",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "maybe"
  },
  {
    "timestamp": "2017-07-14T15:23:42.240198",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "`(identical? :abc (keyword (str \"a\" \"bc\")))` => true"
  },
  {
    "timestamp": "2017-07-14T15:24:24.259887",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "So map lookup will be faster if it can check for `identical?` before falling back to \"equal\"."
  },
  {
    "timestamp": "2017-07-14T15:24:30.263100",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "but do you want to be interning json coming in over the wire?"
  },
  {
    "timestamp": "2017-07-14T15:24:43.269371",
    "conversation_id": 291,
    "user": "Noella",
    "message": "what am I missing here? ``` user=> (defn foo [args] (apply hash-map args)) #'user/foo user=> (binding [*data-readers* {'foo #'user/foo}] #foo [1 2 3 4]) java.lang.RuntimeException: No reader function for tag foo clojure.lang.LispReader$ReaderException: java.lang.RuntimeException: No reader function for tag foo java.lang.RuntimeException: Unmatched delimiter: ) clojure.lang.LispReader$ReaderException: java.lang.RuntimeException: Unmatched delimiter: ) ```"
  },
  {
    "timestamp": "2017-07-14T15:25:07.280733",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "the whole form is read before the binding is run"
  },
  {
    "timestamp": "2017-07-14T15:25:18.285447",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "Good question, given that converting arbitrary strings to keywords can open you up to a denial of service attack."
  },
  {
    "timestamp": "2017-07-14T15:26:08.309644",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "I mean, you will likely be fine, and keyword's intern a weakreference, so the they will get cleared"
  },
  {
    "timestamp": "2017-07-14T15:26:27.318837",
    "conversation_id": 291,
    "user": "Daniell",
    "message": "Ya, but... :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-14T15:27:04.335810",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "```user=> (defn foo [args] (apply hash-map args)) #'user/foo user=> (binding [*data-readers* {'foo #'user/foo}] (read-string \"#foo [1 2 3 4]\")) {1 2, 3 4}```"
  },
  {
    "timestamp": "2017-07-14T15:27:05.336375",
    "conversation_id": 291,
    "user": "Noella",
    "message": "<@Rebeca> ahh, so you need this? `(binding [*data-readers* {'foo #'user/foo}] (read-string \"#foo [1 2 3 4]\"))`"
  },
  {
    "timestamp": "2017-07-14T15:27:14.340631",
    "conversation_id": 291,
    "user": "Noella",
    "message": "haha, timing :smile:"
  },
  {
    "timestamp": "2017-07-14T15:27:17.342134",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "yes"
  },
  {
    "timestamp": "2017-07-14T15:28:34.379196",
    "conversation_id": 291,
    "user": "Noella",
    "message": "while on the topic of tagged literals: is there anything special you need to do to get it to work with `tools.namespace`?"
  },
  {
    "timestamp": "2017-07-14T15:29:20.401239",
    "conversation_id": 291,
    "user": "Noella",
    "message": "I’ve placed a `data_readers.clj` in my classpath root, but when I try to use it in the REPL I get something like “Can’t call unbound Var”"
  },
  {
    "timestamp": "2017-07-14T15:29:33.407377",
    "conversation_id": 291,
    "user": "Noella",
    "message": "lemme dig up the exact exception"
  },
  {
    "timestamp": "2017-07-14T15:29:40.411299",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "you need to require the namespace before you can use the reader"
  },
  {
    "timestamp": "2017-07-14T15:30:31.436275",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "data_readers.clj sets up the tag, but doesn't actually cause the namespace where the function is defined to load"
  },
  {
    "timestamp": "2017-07-14T15:31:00.450343",
    "conversation_id": 291,
    "user": "Noella",
    "message": "I’m pretty sure I did that, but let me double check"
  },
  {
    "timestamp": "2017-07-14T15:33:18.514544",
    "conversation_id": 291,
    "user": "Noella",
    "message": "ok, so my `data_readers.clj` contains `{foo kleinheit.pg.impl/foo}`"
  },
  {
    "timestamp": "2017-07-14T15:33:39.523907",
    "conversation_id": 291,
    "user": "Noella",
    "message": "`(defn foo [vs] (apply hash-map vs))`"
  },
  {
    "timestamp": "2017-07-14T15:34:25.545762",
    "conversation_id": 291,
    "user": "Noella",
    "message": "wait a minute!"
  },
  {
    "timestamp": "2017-07-14T15:34:33.549404",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "and every place where you read something using that tag, before that does a require of that namespace execute?"
  },
  {
    "timestamp": "2017-07-14T15:35:42.580670",
    "conversation_id": 291,
    "user": "Noella",
    "message": "okay, I see the problem: if I use `(require 'kleinheit.pg.impl :reload)` first thing in the REPL, it works"
  },
  {
    "timestamp": "2017-07-14T15:36:01.589427",
    "conversation_id": 291,
    "user": "Noella",
    "message": "but if I do `clojure.tools.namespace.repl/refresh`, it doesn’t"
  },
  {
    "timestamp": "2017-07-14T15:38:13.648647",
    "conversation_id": 291,
    "user": "Noella",
    "message": "yep, `tool.namespace` clobbers it somehow"
  },
  {
    "timestamp": "2017-07-14T15:51:16.009607",
    "conversation_id": 291,
    "user": "Noella",
    "message": "the prevailing wisdom on the internet when having problems with data readers is to call `(#'clojure.core/load-data-readers)`, but then I get: ```dev=> (#'clojure.core/load-data-readers) clojure.lang.ExceptionInfo: Conflicting data-reader mapping```"
  },
  {
    "timestamp": "2017-07-14T15:59:48.249134",
    "conversation_id": 291,
    "user": "Noella",
    "message": "I’m getting a conflict with my own data reader file :neutral_face:"
  },
  {
    "timestamp": "2017-07-14T16:00:18.264969",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "OK - so the data readers are already loaded, you have to reload the code they refer to, right?"
  },
  {
    "timestamp": "2017-07-14T16:01:58.313394",
    "conversation_id": 291,
    "user": "Noella",
    "message": "still get the error after calling `refresh`"
  },
  {
    "timestamp": "2017-07-14T16:02:14.321311",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "right, because somewhere you aren't properly doing the require"
  },
  {
    "timestamp": "2017-07-14T16:02:43.334513",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "so find all the places you use the tag, ensure in that namespace you require the namespace where the function the tag maps to is"
  },
  {
    "timestamp": "2017-07-14T16:03:34.358630",
    "conversation_id": 291,
    "user": "Noella",
    "message": "```dev=> (dev/refresh) :reloading (... kleinheit.pg.impl ...) :ok dev=> #foo [1 2 3 4] java.lang.IllegalStateException: Attempting to call unbound fn: #'kleinheit.pg.impl/foo clojure.lang.LispReader$ReaderException: java.lang.IllegalStateException: Attempting to call unbound fn: #'kleinheit.pg.impl/foo ```"
  },
  {
    "timestamp": "2017-07-14T16:05:08.401674",
    "conversation_id": 291,
    "user": "Noella",
    "message": "and it works if I just skipped the `refresh` and do the regular `(require ...)`, so I’m at a loss ¯\\_(ツ)_/¯"
  },
  {
    "timestamp": "2017-07-14T16:05:23.408647",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "what kind of repl you are using?"
  },
  {
    "timestamp": "2017-07-14T16:05:29.411370",
    "conversation_id": 291,
    "user": "Noella",
    "message": "`lein repl`"
  },
  {
    "timestamp": "2017-07-14T16:06:04.427583",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "lein repl can be kind of weird"
  },
  {
    "timestamp": "2017-07-14T16:06:29.439134",
    "conversation_id": 291,
    "user": "Noella",
    "message": "ehh… errhmm… how do I launch a REPL without lein? :sweat_smile:"
  },
  {
    "timestamp": "2017-07-14T16:07:03.454724",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "that depends, ```java -cp `lein classpath` clojure.main``` often works"
  },
  {
    "timestamp": "2017-07-14T16:07:49.475215",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "rlwrap is very handy when doing it that way"
  },
  {
    "timestamp": "2017-07-14T16:09:42.525819",
    "conversation_id": 291,
    "user": "Noella",
    "message": "still get the same behavior in that REPL unfortunately :confused:"
  },
  {
    "timestamp": "2017-07-14T16:10:35.549531",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "put a println at the top of the kleinheit.pg.impl namespace to see if it is actually getting reloaded"
  },
  {
    "timestamp": "2017-07-14T16:12:36.605032",
    "conversation_id": 291,
    "user": "Noella",
    "message": "yessir, it prints"
  },
  {
    "timestamp": "2017-07-14T16:13:37.632865",
    "conversation_id": 291,
    "user": "Noella",
    "message": "well, I’m gonna give this a rest for now, appreciate all your help folks"
  },
  {
    "timestamp": "2017-07-14T16:14:43.663507",
    "conversation_id": 291,
    "user": "Rebeca",
    "message": "ah, I bet refresh breaks var interning, so you end up with two vars with the same name"
  },
  {
    "timestamp": "2017-07-14T16:15:34.687305",
    "conversation_id": 291,
    "user": "Noella",
    "message": "ohh, now that sounds like it might be it!"
  },
  {
    "timestamp": "2017-07-14T16:15:49.693824",
    "conversation_id": 291,
    "user": "Noella",
    "message": "time to dig into the source…"
  },
  {
    "timestamp": "2017-07-14T16:16:34.714409",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "yeah, it destroys namespaces which might also include doing something wacky with vars that other code has captured…"
  },
  {
    "timestamp": "2017-07-14T16:16:52.722848",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "you might just want to blacklist the namespaces that define readers from auto-reload"
  },
  {
    "timestamp": "2017-07-14T16:22:27.872966",
    "conversation_id": 291,
    "user": "Noella",
    "message": "yeah, I’ll see if I can figure out a way to do that, thanks!"
  },
  {
    "timestamp": "2017-07-14T16:23:42.907178",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "<@Noella> it’s documented here <https://github.com/clojure/tools.namespace#disabling-refresh-in-a-namespace>"
  },
  {
    "timestamp": "2017-07-14T16:26:08.971940",
    "conversation_id": 291,
    "user": "Noella",
    "message": "yeah, the problem with that is if I call `disable-unload!` in the file, the “do not refresh” metadata will be added on the first refresh and I’m stuck again"
  },
  {
    "timestamp": "2017-07-14T16:26:25.979151",
    "conversation_id": 291,
    "user": "Noella",
    "message": "can you add metadata to a namespace in the `ns` call?"
  },
  {
    "timestamp": "2017-07-14T16:27:07.997817",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "yeah- iirc it makes tools.namespace unhappy though (and various tools that use that, like eastwood)"
  },
  {
    "timestamp": "2017-07-14T16:27:14.001013",
    "conversation_id": 291,
    "user": "Margaret",
    "message": "but maybe that’s old info…"
  },
  {
    "timestamp": "2017-07-14T16:33:20.164200",
    "conversation_id": 291,
    "user": "Noella",
    "message": "well, that didn’t work :smile:"
  },
  {
    "timestamp": "2017-07-14T16:33:56.179907",
    "conversation_id": 291,
    "user": "Noella",
    "message": "talking about interning got me thinking about a great clojure talk I need to rewatch: <https://www.youtube.com/watch?v=8NUI07y1SlQ>"
  },
  {
    "timestamp": "2017-07-14T16:34:35.197506",
    "conversation_id": 291,
    "user": "Noella",
    "message": "(thanks for the preview Slack….)"
  },
  {
    "timestamp": "2017-07-14T16:51:56.648413",
    "conversation_id": 291,
    "user": "Evelin",
    "message": "woot i just made a graphics library for clojure! if anyone interested in that kind of thing could run some of the examples, i'd be thrilled to know if they work for you or not."
  },
  {
    "timestamp": "2017-07-14T16:52:20.658773",
    "conversation_id": 291,
    "user": "Evelin",
    "message": "<https://github.com/bcbradle/gl>"
  },
  {
    "timestamp": "2017-07-21T02:45:33.947630",
    "conversation_id": 375,
    "user": "Ofelia",
    "message": "I'm using boot for my build system. Is there a library to help with the following task. I have a function TRANSLATE, which does *.foo -> *.clj. I also have a bunch of *.foo files. Whenever any of them changes, I want TRANSLATE to be called to generate the corresponding *.clj file. Is there a library to handle this for me?"
  },
  {
    "timestamp": "2017-07-21T02:47:35.973936",
    "conversation_id": 375,
    "user": "Giovanna",
    "message": "<@Ofelia> This should probably do the trick <https://github.com/wkf/hawk>"
  },
  {
    "timestamp": "2017-07-21T02:49:01.993305",
    "conversation_id": 375,
    "user": "Giovanna",
    "message": "Or, actually, I think boot has that as a built in task"
  },
  {
    "timestamp": "2017-07-21T02:49:23.998306",
    "conversation_id": 375,
    "user": "Ofelia",
    "message": "I see now. The core of my problem is just a \"watch + notify.\" Right, there's a boot task. Boot can do this already for me."
  },
  {
    "timestamp": "2017-07-21T08:27:22.322366",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "The arm jvm is not so great last I checked, and startup times go into the multiple minutes if using nrepl and lein"
  },
  {
    "timestamp": "2017-07-21T12:24:53.030646",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "nrepl is a network library, it doesn’t share stdio between processes"
  },
  {
    "timestamp": "2017-07-21T12:25:01.034816",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "you’d need some other infrastructure entirely"
  },
  {
    "timestamp": "2017-07-21T12:26:07.070058",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "you could set something up for multicast output to clients, but it would require new middleware on both the client and server sides"
  },
  {
    "timestamp": "2017-07-21T12:26:23.078466",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "hm.. maybe only server side"
  },
  {
    "timestamp": "2017-07-21T12:37:52.446355",
    "conversation_id": 375,
    "user": "Carmelina",
    "message": "Thanks! <@Margaret> I guess nirvana is not for this world. I'll just do the unix hackery"
  },
  {
    "timestamp": "2017-07-21T13:00:01.152600",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "“trigger” is more general, “event” assumes a specific interpretation of how the state machine interacts with an unknown outside world"
  },
  {
    "timestamp": "2017-07-21T13:00:14.160634",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "by unknown I mean “something not specified by the machine itself”"
  },
  {
    "timestamp": "2017-07-21T13:01:39.209852",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "you can of course describe all things as events, but that’s a more specific term, and some semantics prefer to draw a distinction between eg. an event and a start of a timer"
  },
  {
    "timestamp": "2017-07-21T13:01:51.216561",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "since that can be triggered internally by another part of the machine"
  },
  {
    "timestamp": "2017-07-21T13:02:35.241332",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "maybe I did that already as you were typing? if a change in one part of the machine activates another part of the same machine, that’s a trigger, but not an event because it came from inside the machine itself"
  },
  {
    "timestamp": "2017-07-21T13:03:26.269915",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "so let’s say a parser: if your language rules say “you are now in a closure” that’s a trigger but not an event, if you read a semicolon and that means you end the closure, that is an event that is also a trigger"
  },
  {
    "timestamp": "2017-07-21T13:03:36.275115",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "I have a feeling, that having both events and triggers (which are followed with guards (predicates)) - is somewhat excessive, at least in the clojure/edn/library context"
  },
  {
    "timestamp": "2017-07-21T13:04:08.292461",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "they are different levels of abstraction - an event is a special kind of trigger and most users of fsms differentiate them"
  },
  {
    "timestamp": "2017-07-21T13:04:33.305513",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "definitely implement in terms of triggers first, if you do it right you can build events on top if you need them?"
  },
  {
    "timestamp": "2017-07-21T13:05:50.347205",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "but calling a trigger that is totally internal to the state of the machine an event seems weird (unless you also reify the trigger as some output and re-consume it I guess? I’ve done that for coordination)"
  },
  {
    "timestamp": "2017-07-21T13:06:32.369762",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "I get that there are less/more specific events. what I cannot pin point, is why some would be triggers, not events (or vise versa)"
  },
  {
    "timestamp": "2017-07-21T13:07:24.397116",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "so basically: internal=trigger, external=event? (interna/external to machine, not particular state)"
  },
  {
    "timestamp": "2017-07-21T13:09:45.470909",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "or even: event/type is a trigger, but event is an entire \"object\"? sort of"
  },
  {
    "timestamp": "2017-07-21T13:14:23.614418",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "no, event is not the general thing, a trigger is the general thing"
  },
  {
    "timestamp": "2017-07-21T13:14:38.621921",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "all things that cause transitions are triggers, period"
  },
  {
    "timestamp": "2017-07-21T13:14:51.628576",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "if you only want one abstraction, it’s a trigger"
  },
  {
    "timestamp": "2017-07-21T13:14:57.631633",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "an event is a special kind of trigger"
  },
  {
    "timestamp": "2017-07-21T13:16:08.668436",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "thank you for the input"
  },
  {
    "timestamp": "2017-07-21T13:18:02.727459",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> it could be that what you really want is event sourcing. That works very nicely with clojure / immutable data."
  },
  {
    "timestamp": "2017-07-21T13:18:23.737804",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "while a state machine is kind of designed for c or assembly, it’s all about when to do what mutation"
  },
  {
    "timestamp": "2017-07-21T13:19:06.759743",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "if so, yeah, everything should be an event, you have a log of events to consume, and you project various views from the events via a projection (aka fold, aka `clojure.core/reductions`)."
  },
  {
    "timestamp": "2017-07-21T13:20:21.798988",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "I’m currently building a system around that, and it’s very nice (especially the fact that when I hit a bug I can just dump an excerpt of the log, and replaying that log builds my regression test)"
  },
  {
    "timestamp": "2017-07-21T13:27:55.040004",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "<@Margaret> I am trying to reconcile my understanding of the components of: rule based systems, FSMs, and event sourcing, to \"solve\" single page apps state management for myself. I tried basic event sourcing, but when you have: few audio/video html tags with their own states, some i/o, a bunch of buttons depending on the above, and custom performance-sensitive progress bar – it kind of is not enough, and coordinating all of this is not much easier, than just a bunch of atoms with a page of `add-watch`es connecting them. So i went looking for a better way, or just to improve my understanding of the building blocks."
  },
  {
    "timestamp": "2017-07-21T13:28:47.067762",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> OK - I suggest checking out petri nets btw because they are async and have a formal provable semantics"
  },
  {
    "timestamp": "2017-07-21T13:29:17.083949",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "those are on my reading list, yes"
  },
  {
    "timestamp": "2017-07-21T13:29:26.088784",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> also the very high level response to that problem is “when event sourcing leads to local state changes, reify the state change by sending it out as a new event and then consuming it”"
  },
  {
    "timestamp": "2017-07-21T13:29:51.102046",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "that way you still have the events as the canonical source of all truth"
  },
  {
    "timestamp": "2017-07-21T13:30:18.117058",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "when you have local state changes that will guide behavior that are not visible in the events, you’ve undermined the event sourcing system because you now have an irreproducible state"
  },
  {
    "timestamp": "2017-07-21T13:30:26.121345",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "it’s actually not event sourced any more"
  },
  {
    "timestamp": "2017-07-21T13:31:54.168767",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "I sort of did that. But having few \"a pure state {} depending on side-effectful io/video/audio and vice versa\" loops messes things up. So I went for specs to get some vocabulary for \"internal/external/pure/io events\", etc."
  },
  {
    "timestamp": "2017-07-21T13:34:19.245644",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "the challenge is: from event sourcing pov: there are like 100 states, but from ui components' pov: 10, and I am looking for a way to manage those 2 \"projections\""
  },
  {
    "timestamp": "2017-07-21T13:35:14.274601",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "(basically states vs. <https://en.wikipedia.org/wiki/UML_state_machine#Extended_states>)"
  },
  {
    "timestamp": "2017-07-21T13:35:22.279398",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "my solution was to base things on a petri net - which have two kinds of things, places and transitions, a transition consumes tokens from 1 or more places and puts tokens into 0 or more places. All canonical state is the content of places (keys in a hash-map, obviously) and transitions are described by predicates on the contents under those keys and an update that removes tokens from N places and places tokens in N places"
  },
  {
    "timestamp": "2017-07-21T13:36:17.308509",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "but yes, I have dealt with that problem you describe in my reagent app"
  },
  {
    "timestamp": "2017-07-21T13:36:21.310214",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "what do tokens represent? \"should I run this predicate?\"?"
  },
  {
    "timestamp": "2017-07-21T13:36:29.314139",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "tokens are immutable data"
  },
  {
    "timestamp": "2017-07-21T13:36:47.324134",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "the predicate says “given these tokens that currently exist, do I fire?”"
  },
  {
    "timestamp": "2017-07-21T13:37:00.330593",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "and firing consumes some tokens and maybe produces some in other places"
  },
  {
    "timestamp": "2017-07-21T13:37:14.338118",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "it’s like actors without the data hiding"
  },
  {
    "timestamp": "2017-07-21T13:38:52.388857",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "instead of mailboxes they have some places they watch (and anyone else can watch), and instead of sending messages they remove data from one place and maybe put new immutable data in places"
  },
  {
    "timestamp": "2017-07-21T13:39:30.408226",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "so the places are basically like queues?"
  },
  {
    "timestamp": "2017-07-21T13:39:36.411475",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "they aren’t ordered"
  },
  {
    "timestamp": "2017-07-21T13:40:06.426662",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "like an (atom {}), which you take values from or put into?"
  },
  {
    "timestamp": "2017-07-21T13:40:37.443152",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "and you might say “I only fire if I can consume 3 from :a plus one from :b” - eg. that is what assigning work to a worker ends up looking like - you have a token for a worker and a token for the job, you consume both and create a new token representing a pending result"
  },
  {
    "timestamp": "2017-07-21T13:40:46.448024",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "so 10 places (nodes) = 10 atoms?"
  },
  {
    "timestamp": "2017-07-21T13:40:57.453599",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "no, you don’t even need an atom"
  },
  {
    "timestamp": "2017-07-21T13:41:30.471064",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "I put it all in one hash map, but you could eg. represent the whole thing with `reductions` which would mean each state is another item in the lazy-seq that reductions outputs"
  },
  {
    "timestamp": "2017-07-21T13:41:55.483930",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "(free history!)"
  },
  {
    "timestamp": "2017-07-21T13:42:06.489764",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "or reduce on an atom"
  },
  {
    "timestamp": "2017-07-21T13:42:08.490610",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "or whatever"
  },
  {
    "timestamp": "2017-07-21T13:42:44.509483",
    "conversation_id": 375,
    "user": "Wilhemina",
    "message": "thats how i designed my deterministic game simulation"
  },
  {
    "timestamp": "2017-07-21T13:43:08.522354",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Wilhemina> hehe my event / petri based library is called “ludic” and the primary metaphor is playing chess by mail"
  },
  {
    "timestamp": "2017-07-21T13:43:28.532909",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "but really it’s doing a bunch of data transitions based on a petri net model from an event source :smile:"
  },
  {
    "timestamp": "2017-07-21T13:43:45.542005",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "(ludic is a super intellectual word describing playfulness)"
  },
  {
    "timestamp": "2017-07-21T13:44:00.549770",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "so you have a list of \"workers\", and just (while true) apply them on the same {}? and each of those modify it, if \"there is enough of particular tokens\""
  },
  {
    "timestamp": "2017-07-21T13:44:23.561847",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> one thing it does is manage workers and tasks, but that’s just because I’m running a computation cluster"
  },
  {
    "timestamp": "2017-07-21T13:44:46.574256",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "if you are in the browser, you don’t need workers - make places / tokens that model your domain"
  },
  {
    "timestamp": "2017-07-21T13:45:09.586683",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "eg. a place could be a dom node and the tokens represent the data driving it… (maybe?)"
  },
  {
    "timestamp": "2017-07-21T13:46:31.631176",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "or maybe better would be a place being a UI state, tokens describing it, and transitions deciding where it should go next"
  },
  {
    "timestamp": "2017-07-21T13:46:42.636755",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "I'll read your lib's readme first. Did not quite get the analogy yet : )"
  },
  {
    "timestamp": "2017-07-21T13:46:56.644123",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Lucio> sets don’t have “first” anything, they are unordered"
  },
  {
    "timestamp": "2017-07-21T13:47:28.661453",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "if you want an implementation-derived item that will change when you change contents in odd ways, sure, you can call `ffirst`"
  },
  {
    "timestamp": "2017-07-21T13:47:34.664500",
    "conversation_id": 375,
    "user": "Lucio",
    "message": "<@Margaret> right; in my case I don’t care about which element of the set gets picked; hopefully it should be a singleton set, or empty set"
  },
  {
    "timestamp": "2017-07-21T13:47:35.665372",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "but don’t count on any particular item coming out"
  },
  {
    "timestamp": "2017-07-21T13:47:48.672068",
    "conversation_id": 375,
    "user": "Daniell",
    "message": "There's a `ffirst` function."
  },
  {
    "timestamp": "2017-07-21T13:48:16.686700",
    "conversation_id": 375,
    "user": "Lucio",
    "message": "ffirst is exactly what I was looking for; thank you!"
  },
  {
    "timestamp": "2017-07-21T13:49:40.732239",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> I almost regret mentioning my lib - it’s still super young and I don’t think the examples are good yet and it’s still changing fast"
  },
  {
    "timestamp": "2017-07-21T13:49:43.734103",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "just FYI"
  },
  {
    "timestamp": "2017-07-21T13:50:16.752614",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "I only brought it up because of the game thing"
  },
  {
    "timestamp": "2017-07-21T13:51:53.805838",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "<@Margaret> I just need lots of input and analogies to straighten my thoughts at this point :)"
  },
  {
    "timestamp": "2017-07-21T13:54:10.881311",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Merrie> on that account, this book is very well written, has beautiful illustrations and typography <https://www.amazon.com/gp/product/3642332773/ref=oh_aui_detailpage_o04_s00?ie=UTF8&psc=1>"
  },
  {
    "timestamp": "2017-07-21T13:54:22.888178",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "(it’s a book about petri nets, since the url doesn’t reveal that)"
  },
  {
    "timestamp": "2017-07-21T13:54:51.903867",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "definitely the most beautiful CS book I own"
  },
  {
    "timestamp": "2017-07-21T13:55:29.925501",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "no kindle edition :harold:"
  },
  {
    "timestamp": "2017-07-21T13:55:39.931303",
    "conversation_id": 375,
    "user": "Willow",
    "message": "just a reminder that the first element of a set is not a well defined concept. it may be consistent but this would only be due to implementation details"
  },
  {
    "timestamp": "2017-07-21T13:56:22.955290",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "thank you. everything was really helpful"
  },
  {
    "timestamp": "2017-07-21T13:57:21.988026",
    "conversation_id": 375,
    "user": "Lucio",
    "message": "<@Willow> thanks! I’m aware of that however, and in my case it doesn’t matter. The set should always be either empty or a singleton"
  },
  {
    "timestamp": "2017-07-21T13:57:24.989551",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "np - and keep in mind you might not need the petri net model - you might just want eg. CSP instead (since core.async is right there) - but do think about how well the foo you connect your events to is something that works nicely in the clojure ecosystem"
  },
  {
    "timestamp": "2017-07-21T13:57:44.000979",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "events -> datalog works great too"
  },
  {
    "timestamp": "2017-07-21T13:57:45.001483",
    "conversation_id": 375,
    "user": "Willow",
    "message": "sounds good. just wanted to remind just incase"
  },
  {
    "timestamp": "2017-07-21T13:58:22.021694",
    "conversation_id": 375,
    "user": "Lucio",
    "message": "thanks :slightly_smiling_face: it could have introduced a nasty bug if I relied on the first element being stable.."
  },
  {
    "timestamp": "2017-07-21T13:59:40.065367",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "about that :kappa:"
  },
  {
    "timestamp": "2017-07-21T14:01:28.128003",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "the bigger picture I keep in mind, is some kind of format, which can help describe system in concise way, so you could see it all at once, to some level of details"
  },
  {
    "timestamp": "2017-07-21T14:01:54.142604",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "like: <http://www.thelogbook.com/phosphor/2008/frisky.gif>"
  },
  {
    "timestamp": "2017-07-21T14:04:28.228224",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "channels are cool, but when all the plumbing is spread across entire project - it becomes challenging to see the \"project mini map\". And anything I encountered so far – are either one way graph wiz pngs, or completely new visual-first language."
  },
  {
    "timestamp": "2017-07-21T14:06:33.294484",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "it was pretty straightforward to make a function that consumed my rules and based on the places they consume from and produce to (fields on the rule record) generate a `.dot` file for graphviz showing a petri net."
  },
  {
    "timestamp": "2017-07-21T14:07:03.310056",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "not the precise petri net my code implements (since my code can easily break that abstraction…) but at least a diagram that is helpful"
  },
  {
    "timestamp": "2017-07-21T14:07:55.338005",
    "conversation_id": 375,
    "user": "Merrie",
    "message": "yeah, I saw the .dot support"
  },
  {
    "timestamp": "2017-07-21T14:10:08.408875",
    "conversation_id": 375,
    "user": "Lucia",
    "message": "you also might find Milner' Pi Calc useful <https://www.amazon.com/Communicating-Mobile-Systems-Pi-Calculus/dp/0521658691>"
  },
  {
    "timestamp": "2017-07-21T14:10:24.417265",
    "conversation_id": 375,
    "user": "Margaret",
    "message": "<@Lucia> oh nice thanks for reminding me of that"
  },
  {
    "timestamp": "2017-07-21T14:12:03.468538",
    "conversation_id": 375,
    "user": "Lucia",
    "message": "np, thanks for the petri book ref, always wanted to find sth like that!"
  },
  {
    "timestamp": "2017-07-21T15:32:57.901156",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Is <https://github.com/stuartsierra/component> “state of the art” to structure a system in Clojure? Or does anyone have better advice?"
  },
  {
    "timestamp": "2017-07-21T15:34:10.934255",
    "conversation_id": 382,
    "user": "Darci",
    "message": "I prefer <https://github.com/tolitius/mount> by far. Simpler, less opinionated, less viral."
  },
  {
    "timestamp": "2017-07-21T15:34:54.953818",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "mount is just terrible though"
  },
  {
    "timestamp": "2017-07-21T15:35:10.961437",
    "conversation_id": 382,
    "user": "Darci",
    "message": "could be. I rather don't like component."
  },
  {
    "timestamp": "2017-07-21T15:35:51.979592",
    "conversation_id": 382,
    "user": "Malka",
    "message": "<@Lucio> check out integrant: <https://github.com/weavejester/integrant>"
  },
  {
    "timestamp": "2017-07-21T15:35:52.980272",
    "conversation_id": 382,
    "user": "Lucio",
    "message": ":smile: well, let me turn my question around then: what would be your preferred way to structure a system to as to make dependency injection / mocking easy?"
  },
  {
    "timestamp": "2017-07-21T15:36:03.984925",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "component"
  },
  {
    "timestamp": "2017-07-21T15:36:07.986589",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I am new to clojure and about to build my first app"
  },
  {
    "timestamp": "2017-07-21T15:36:07.986877",
    "conversation_id": 382,
    "user": "Darci",
    "message": "mount :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:36:20.992505",
    "conversation_id": 382,
    "user": "Darci",
    "message": "lol"
  },
  {
    "timestamp": "2017-07-21T15:36:24.994302",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Integrant :wink:"
  },
  {
    "timestamp": "2017-07-21T15:36:24.994398",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "mount is a formalized system of global state, component gets rid of global state"
  },
  {
    "timestamp": "2017-07-21T15:36:29.996640",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I guess I’ll try all three then"
  },
  {
    "timestamp": "2017-07-21T15:36:30.997225",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "But I might be a touch biased"
  },
  {
    "timestamp": "2017-07-21T15:36:30.997320",
    "conversation_id": 382,
    "user": "Lucio",
    "message": ":smile:"
  },
  {
    "timestamp": "2017-07-21T15:36:45.004108",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "oh, integrant is your project <@Ramonita>"
  },
  {
    "timestamp": "2017-07-21T15:36:48.005168",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "<@Rebeca> why is mount terrible?"
  },
  {
    "timestamp": "2017-07-21T15:36:54.008253",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Component is the most used. Integrant is a little new, but YMMV."
  },
  {
    "timestamp": "2017-07-21T15:36:57.009353",
    "conversation_id": 382,
    "user": "Darci",
    "message": "yeah, I guess that's the best thing to do: try all :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:37:01.011407",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> what does integrant do better than mount and component?"
  },
  {
    "timestamp": "2017-07-21T15:37:09.015174",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "mount is based on global state in global atoms"
  },
  {
    "timestamp": "2017-07-21T15:37:16.018113",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "I've done that, it sucked"
  },
  {
    "timestamp": "2017-07-21T15:37:55.036380",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "component turns your system in to another first class value you can pass around, have multiple copies of, etc"
  },
  {
    "timestamp": "2017-07-21T15:37:56.036963",
    "conversation_id": 382,
    "user": "Darci",
    "message": "<@Rebeca> we've all done all kinds of stuff, I never liked component. No need to argue with : I like it - I don't."
  },
  {
    "timestamp": "2017-07-21T15:38:02.039557",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I fear I’ve asked a more contentious question than “should I use VIM or Emacs?”"
  },
  {
    "timestamp": "2017-07-21T15:38:03.040107",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "<@Lucio> Compared to Mount, Integrant doesn’t have global state. Compared to Component, Integrant can have dependencies between things that aren’t maps/records."
  },
  {
    "timestamp": "2017-07-21T15:38:45.059088",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "I feel like Vim and Emacs users can be collectively smug toward users of lesser editors :wink:"
  },
  {
    "timestamp": "2017-07-21T15:38:48.060663",
    "conversation_id": 382,
    "user": "Darci",
    "message": "we know <@Rebeca> doesn't like mount : <https://gist.github.com/pandeiro/9a1c8fd431e1b4c78c99>"
  },
  {
    "timestamp": "2017-07-21T15:39:24.076731",
    "conversation_id": 382,
    "user": "Darci",
    "message": "That discussion actually drew my attention to mount, and I like it since. Thanks to <@Rebeca> :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:39:50.088257",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "huh, I didn't know there was acopy of that floating around"
  },
  {
    "timestamp": "2017-07-21T15:39:54.089867",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "``` seems bad, like sticking (def state (atom {})) in every namespace would be ``` isn't this the way I am supposed to do things? :kappa:"
  },
  {
    "timestamp": "2017-07-21T15:40:04.094487",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "god no"
  },
  {
    "timestamp": "2017-07-21T15:40:36.109266",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "singleton global state is bad and sprinkling clojure on it doesn't make it good"
  },
  {
    "timestamp": "2017-07-21T15:40:57.118594",
    "conversation_id": 382,
    "user": "Darci",
    "message": "still, thanks for pointing me to mount :wink:"
  },
  {
    "timestamp": "2017-07-21T15:41:06.122720",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "actually, I'd love to see good example of not doing global atoms, asking for a friend™"
  },
  {
    "timestamp": "2017-07-21T15:42:11.152133",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "I guess good component example would suffice as well"
  },
  {
    "timestamp": "2017-07-21T15:43:11.179905",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "all the main component projects I have worked on have been closed source apps"
  },
  {
    "timestamp": "2017-07-21T15:43:26.186683",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Oh, I didn’t realise you’re the maintainer of Ring and Compojure!"
  },
  {
    "timestamp": "2017-07-21T15:43:33.190088",
    "conversation_id": 382,
    "user": "Martina",
    "message": "Here is the problem with global state: you don’t know beforehand how you will want to use your code later. So, inevitably the system grows to the point where your previous “application” is subsumed in some larger structure, and you have to refactor all the global state out of it. Which is a much bigger pain later."
  },
  {
    "timestamp": "2017-07-21T15:43:59.201700",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Indeed. Feel free to hit me up with any questions when/if you happen to have any."
  },
  {
    "timestamp": "2017-07-21T15:44:05.204502",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Read the discussion... it's enlightening"
  },
  {
    "timestamp": "2017-07-21T15:44:09.206082",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "<https://github.com/hiredman/songs-of-future-past/blob/master/src/com/manigfeald/sofp.clj> is an example of something using component, I don't know that it is good"
  },
  {
    "timestamp": "2017-07-21T15:44:35.218102",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "thank you"
  },
  {
    "timestamp": "2017-07-21T15:44:36.218382",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "it doesn't have any tests, which is where the lack of global state would really shine"
  },
  {
    "timestamp": "2017-07-21T15:45:53.253674",
    "conversation_id": 382,
    "user": "Martina",
    "message": "I only say this because I went through this before. Component solves a problem I was having, and has been great ever since."
  },
  {
    "timestamp": "2017-07-21T15:46:21.266591",
    "conversation_id": 382,
    "user": "Martina",
    "message": "I feel like you can go through this yourself, maybe that is the only way to see it"
  },
  {
    "timestamp": "2017-07-21T15:47:37.301110",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "hmaurer: in that case, build it yourself. once you've got that experience under your belt you'll be able to evaluate mount, component, etc. walk before you run."
  },
  {
    "timestamp": "2017-07-21T15:48:01.312707",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "I would say it is a classic easy/simple split, component is way simpler (<https://gist.github.com/hiredman/075b45eaeb01e4b526ce6f8854685487> implements all the functionality of component in 30 lines, but lacks refinement), but mount is going to be easier because using globals is always easier for a few months"
  },
  {
    "timestamp": "2017-07-21T15:48:23.322687",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Lucia> good point. that has been my general philosophy so far"
  },
  {
    "timestamp": "2017-07-21T15:48:53.336730",
    "conversation_id": 382,
    "user": "Martina",
    "message": "I think of it as an “easier now”/“easier later” divide"
  },
  {
    "timestamp": "2017-07-21T15:49:33.355447",
    "conversation_id": 382,
    "user": "Martina",
    "message": "Global state is easy now. You don’t have to learn anything and it doesn’t take work to set up"
  },
  {
    "timestamp": "2017-07-21T15:49:43.360155",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Going the 'simpler' and 'easier' way, are we?"
  },
  {
    "timestamp": "2017-07-21T15:50:33.383683",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "hmaurer: fwiw all that stuff is interesting and useful, i suppose, but i've not needed to use any of them. mastering clojure is already a tall order, those things are for ninjas (imho). good luck!"
  },
  {
    "timestamp": "2017-07-21T15:50:43.388281",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Right, it may be easier, and if it solves the problem, why make it more difficult? - What is the problem you want to solve? This may be the first question to <@Lucio>"
  },
  {
    "timestamp": "2017-07-21T15:51:12.400982",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Having a viral framework, I never liked that. Component is more a framework - I will be screwed as well"
  },
  {
    "timestamp": "2017-07-21T15:51:16.403058",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Lucia> thanks! any tip on mastering clojure itself?"
  },
  {
    "timestamp": "2017-07-21T15:51:25.407131",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Darci> Agreed. <@Lucio> If you are trying to learn Clojure, just use a global atom"
  },
  {
    "timestamp": "2017-07-21T15:51:30.409553",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Have used enough frameworks, they always hit you in the face as well... and hard :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:52:10.427295",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I don’t really want to use a global state atom. While I am new to clojure I’ve been interested in functional programming for quite a while; if there are ways to avoid global state I rather do so"
  },
  {
    "timestamp": "2017-07-21T15:52:15.429732",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "But I’ll try out mount either way"
  },
  {
    "timestamp": "2017-07-21T15:52:18.430986",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Darci> We disagree in general, it is okay"
  },
  {
    "timestamp": "2017-07-21T15:52:20.431925",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I might learn some valuable lessons"
  },
  {
    "timestamp": "2017-07-21T15:52:32.437632",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Lucio> That is good context. In that case I think you will appreciate component"
  },
  {
    "timestamp": "2017-07-21T15:52:36.439414",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "fwiw, there is a yurt for mount <https://github.com/tolitius/yurt> ```Multiple brand new local Yurts with components can be created and passed down to the application / REPL to be used simultaneously in the same Clojure runtime for fun and profit.```"
  },
  {
    "timestamp": "2017-07-21T15:52:37.439792",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Exactly - check what works out for you."
  },
  {
    "timestamp": "2017-07-21T15:52:40.441415",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "integrant seems ok, I haven't looked at in depth, but it looks like it uses multimethods for dispatch, which I've done with component before, but is annoying if you want to create an anonymous sort of mock of something in a test"
  },
  {
    "timestamp": "2017-07-21T15:53:17.457481",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Lucio> Once you understand it, it is not as bad as people make it out to be"
  },
  {
    "timestamp": "2017-07-21T15:53:18.457984",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "A global state atom also sounds a bit messy for mocking"
  },
  {
    "timestamp": "2017-07-21T15:53:21.459706",
    "conversation_id": 382,
    "user": "Martina",
    "message": "It is a conceptual hurdle"
  },
  {
    "timestamp": "2017-07-21T15:53:25.461657",
    "conversation_id": 382,
    "user": "Martina",
    "message": "not a technical one"
  },
  {
    "timestamp": "2017-07-21T15:53:31.464216",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I mean, you could set the global state atom before runing your tests with the mock dependency"
  },
  {
    "timestamp": "2017-07-21T15:53:33.465178",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "but it sounds a bit dirty"
  },
  {
    "timestamp": "2017-07-21T15:53:38.467292",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "<@Lucio> the beating heart of mount <https://github.com/tolitius/mount/blob/master/src/mount/core.cljc#L12-L16>"
  },
  {
    "timestamp": "2017-07-21T15:54:04.479333",
    "conversation_id": 382,
    "user": "Darci",
    "message": "<@Martina> right... one prefers frameworks, the other doesn't. Fine with me :slightly_smiling_face:."
  },
  {
    "timestamp": "2017-07-21T15:54:37.494182",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Global state atom can be bad, of course. That's why mount manages it, so you don't have to."
  },
  {
    "timestamp": "2017-07-21T15:54:55.502020",
    "conversation_id": 382,
    "user": "Merrie",
    "message": ":opieop:"
  },
  {
    "timestamp": "2017-07-21T15:54:59.503875",
    "conversation_id": 382,
    "user": "Martina",
    "message": "I would call component more of a pattern. It is not doing much for you, most of it is explicit"
  },
  {
    "timestamp": "2017-07-21T15:55:24.515444",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Anyway, we'll never agree on that part - that discussion was pretty clear about how it's not that different from component (passing in state everywhere)"
  },
  {
    "timestamp": "2017-07-21T15:55:34.519659",
    "conversation_id": 382,
    "user": "Martina",
    "message": "It is a pattern of state access, treating state as a value"
  },
  {
    "timestamp": "2017-07-21T15:55:56.529803",
    "conversation_id": 382,
    "user": "Darci",
    "message": "<@Martina> right... it does not do much... I like that :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:56:16.539240",
    "conversation_id": 382,
    "user": "Martina",
    "message": "Basically, it is the functional way to do things: you have to pass everything in"
  },
  {
    "timestamp": "2017-07-21T15:56:48.554518",
    "conversation_id": 382,
    "user": "Darci",
    "message": "yes, that's a dogmatic reason. I prefer pragmatism in many cases."
  },
  {
    "timestamp": "2017-07-21T15:57:10.564570",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "write code, heh. to me the key is compositionality. it was not obvious to me just what that means when i was starting. i guess i would recommend focussing on the small stuff first - sequuences, laziness, core.async, etc. explore the api - what does juxt do? how to use protocols? etc."
  },
  {
    "timestamp": "2017-07-21T15:57:26.572247",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Is there a good blog/book/resource somewhere on clojure ways of doing things? (i am already familiar with “programming clojure” and “the joy of clojure”)"
  },
  {
    "timestamp": "2017-07-21T15:58:04.590513",
    "conversation_id": 382,
    "user": "Wilhemina",
    "message": "I've heard good things of <http://www.braveclojure.com/>"
  },
  {
    "timestamp": "2017-07-21T15:58:14.595166",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "better: forget the app for now, just spend a lot of time in the repl experimenting."
  },
  {
    "timestamp": "2017-07-21T15:58:22.598781",
    "conversation_id": 382,
    "user": "Vannessa",
    "message": "heh, I went to Mount after a couple years of Component straitjacket. In a bigger team I’d use Component though :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T15:58:25.600214",
    "conversation_id": 382,
    "user": "Darci",
    "message": "clojure does have state management constructs because you don't pass everything in. There's a reason why clojure isn't dogmatic on FP."
  },
  {
    "timestamp": "2017-07-21T15:59:08.620036",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "<https://leanpub.com/elementsofclojure> isn’t finished but has some interesting ideas. It’s not a general purpose programming book, though. I think the first chapter on naming is free."
  },
  {
    "timestamp": "2017-07-21T15:59:12.622265",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "As someone who initially went down a Mount-like path when building a system and has since switched to Component, I'll \"vote\" for <@Rebeca>'s position here that global state is a *terrible* idea."
  },
  {
    "timestamp": "2017-07-21T15:59:37.633613",
    "conversation_id": 382,
    "user": "Darci",
    "message": "It is a terrible idea in general, right. The dogmatic reason. I can understand it."
  },
  {
    "timestamp": "2017-07-21T15:59:55.642062",
    "conversation_id": 382,
    "user": "Darci",
    "message": "But having a viral framework has hit me many times, including component."
  },
  {
    "timestamp": "2017-07-21T16:00:20.654987",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "We're still feeling the pain of the global state approach as we piecemeal migrate away from it (by using Component instead but having its `start`/`stop` functions keep the legacy global state in sync until we can replace it)."
  },
  {
    "timestamp": "2017-07-21T16:00:42.665944",
    "conversation_id": 382,
    "user": "Darci",
    "message": "That's why I prefer mount - pragmatism, and as long as you manage state, it's ok."
  },
  {
    "timestamp": "2017-07-21T16:00:52.670479",
    "conversation_id": 382,
    "user": "Wilhemina",
    "message": "single global atom is the rallying cry for frontend projects lately"
  },
  {
    "timestamp": "2017-07-21T16:01:03.675602",
    "conversation_id": 382,
    "user": "Darci",
    "message": ":slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:01:15.681365",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "<@Lucio> as you can tell from this thread, there is always More Than One Way to Do It. Master the basics first, then you'll see just how true that is!"
  },
  {
    "timestamp": "2017-07-21T16:01:28.687900",
    "conversation_id": 382,
    "user": "Darci",
    "message": "lol true!"
  },
  {
    "timestamp": "2017-07-21T16:01:33.690324",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "Component is not a \"viral framework\". Functions need to be based stuff as arguments, not reach out to global state for it."
  },
  {
    "timestamp": "2017-07-21T16:01:48.697466",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Haha, I am glad it sparked a discussion though. It would have been quite boring if someone linked me a lib and 5 people thumbed up"
  },
  {
    "timestamp": "2017-07-21T16:01:51.699039",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Once you start using component, it's hard not to use it everywhere in your code base."
  },
  {
    "timestamp": "2017-07-21T16:01:57.701448",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "<@Wilhemina>"
  },
  {
    "timestamp": "2017-07-21T16:02:13.709287",
    "conversation_id": 382,
    "user": "Darci",
    "message": "So well, I call that viral (inside the code base)."
  },
  {
    "timestamp": "2017-07-21T16:02:19.711824",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "<@Wilhemina> I wouldn't be surprised if that is the primary split front end / back end on mount / component"
  },
  {
    "timestamp": "2017-07-21T16:02:39.721134",
    "conversation_id": 382,
    "user": "Darci",
    "message": "You do it 'the component way' or not. There's nothing in between... using component."
  },
  {
    "timestamp": "2017-07-21T16:02:39.721252",
    "conversation_id": 382,
    "user": "Martina",
    "message": "I think it is more about providing each part of your system the minimal amount of information it needs to do its job. That way you can decompose and rearrange it later. Which at some point will become very important."
  },
  {
    "timestamp": "2017-07-21T16:02:59.730234",
    "conversation_id": 382,
    "user": "Martina",
    "message": "global state creates interdependence, which is weakness"
  },
  {
    "timestamp": "2017-07-21T16:03:05.733061",
    "conversation_id": 382,
    "user": "Guillermo",
    "message": "Hate to make an argument by authority, but it's really not insignificant that some of the most veteran clojure developers (<@Rebeca> / <@Daniell> ) favor component. Personally I think mount teaches new clojure users bad habits."
  },
  {
    "timestamp": "2017-07-21T16:03:13.736577",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Same with mount, honestly. Check that discussion I posted above, it's really all not that different."
  },
  {
    "timestamp": "2017-07-21T16:03:19.739613",
    "conversation_id": 382,
    "user": "Guillermo",
    "message": "s/mount/global state patterns/"
  },
  {
    "timestamp": "2017-07-21T16:03:29.744017",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "<@Darci> any given function just needs to be passed what it _needs_ -- not the whole system -- and that's just functional cleanliness. You initialize all your resources at application startup, put them in a map, pass the relevant bits down the call chain. Component just formalizes that and manages dependencies for you."
  },
  {
    "timestamp": "2017-07-21T16:03:39.748565",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "can you do that with component? don’t you pass the whole context around usually? or do you intentionally strip some keys from the context?"
  },
  {
    "timestamp": "2017-07-21T16:03:57.756975",
    "conversation_id": 382,
    "user": "Darci",
    "message": "Same with mount, really, if you like so."
  },
  {
    "timestamp": "2017-07-21T16:04:12.763281",
    "conversation_id": 382,
    "user": "Vannessa",
    "message": "<@Guillermo> - even though I prefer Mount - I agree :slightly_smiling_face: Mount should only be allowed once you spent a year with Component"
  },
  {
    "timestamp": "2017-07-21T16:04:28.770521",
    "conversation_id": 382,
    "user": "Darci",
    "message": "<@Vannessa> :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:04:51.780673",
    "conversation_id": 382,
    "user": "Martina",
    "message": "You only give each component access to the components it asks for (basically you declare a dependency). Your component only ever sees the state that it asks for"
  },
  {
    "timestamp": "2017-07-21T16:05:30.797931",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "Perhaps the pain level with Mount doesn't show up until you have a large enough system? Just like global state only causes you pain after a certain point?"
  },
  {
    "timestamp": "2017-07-21T16:05:41.802794",
    "conversation_id": 382,
    "user": "Guillermo",
    "message": "The `mount` readme describing `component` is disingenuous <https://github.com/tolitius/mount/blob/master/doc/differences-from-component.md#differences-from-component>"
  },
  {
    "timestamp": "2017-07-21T16:05:54.808805",
    "conversation_id": 382,
    "user": "Martina",
    "message": "which makes it really nice, because your systems are modular by default"
  },
  {
    "timestamp": "2017-07-21T16:06:33.825440",
    "conversation_id": 382,
    "user": "Vannessa",
    "message": "<@Daniell> it’s probably true. In my case I’ve avoided building large applications (modules). I just have many of them."
  },
  {
    "timestamp": "2017-07-21T16:06:57.836505",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "We have about 60,000 lines of Clojure right now..."
  },
  {
    "timestamp": "2017-07-21T16:07:11.842516",
    "conversation_id": 382,
    "user": "Vannessa",
    "message": "I have half that, but I’m the only dev"
  },
  {
    "timestamp": "2017-07-21T16:07:29.850671",
    "conversation_id": 382,
    "user": "Darci",
    "message": "LOC - so?"
  },
  {
    "timestamp": "2017-07-21T16:07:38.854526",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Vannessa> I kind of fear your codebase ; )"
  },
  {
    "timestamp": "2017-07-21T16:07:59.863672",
    "conversation_id": 382,
    "user": "Vannessa",
    "message": "you should :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:08:13.869663",
    "conversation_id": 382,
    "user": "Martina",
    "message": "Sweet, your glyphs and wards are working"
  },
  {
    "timestamp": "2017-07-21T16:08:16.871299",
    "conversation_id": 382,
    "user": "Darci",
    "message": "anyway, as said before, one prefers dogmatic, other prefer pragmatism. One prefers frameworks, other prefer libs/patterns. One likes pink, the other blue. Whatever :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:08:57.888776",
    "conversation_id": 382,
    "user": "Martina",
    "message": "If you want to do things functionally, component is what you want"
  },
  {
    "timestamp": "2017-07-21T16:09:41.908280",
    "conversation_id": 382,
    "user": "Darci",
    "message": "(some ran away from component, others ran away from mount, so maybe we all should try integrant and decide it's not a silver bullet either :slightly_smiling_face: )"
  },
  {
    "timestamp": "2017-07-21T16:10:01.917010",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "can you elaborate on the potential issues with multimethods please?"
  },
  {
    "timestamp": "2017-07-21T16:10:12.922242",
    "conversation_id": 382,
    "user": "Darci",
    "message": "lol - because someone has an opinion? Nice."
  },
  {
    "timestamp": "2017-07-21T16:13:26.008145",
    "conversation_id": 382,
    "user": "Daniell",
    "message": "Like I say, hard lessons learned building a system the \"easy\" way with Mount-like managed state, instead of the \"simple\" way with Component-like managed dependencies."
  },
  {
    "timestamp": "2017-07-21T16:14:19.030909",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "zzzzz. clojurians having another vigorous debate/ disagreement _without calling each other names_. wtf is wrong with you people?! :wink:"
  },
  {
    "timestamp": "2017-07-21T16:16:41.091578",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "<@Lucia> I dunno, can't we just hate each other's software without hating each other?"
  },
  {
    "timestamp": "2017-07-21T16:17:24.109703",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "(hating your own software is of course also acceptable)"
  },
  {
    "timestamp": "2017-07-21T16:17:26.110556",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "hate the code, not the coder!"
  },
  {
    "timestamp": "2017-07-21T16:18:23.017078",
    "conversation_id": 382,
    "user": "Lucia",
    "message": "anyway that was a lame attempt at irony - the clojure community is extraordinarily irenic. (look, i made a pun! whee!)"
  },
  {
    "timestamp": "2017-07-21T16:18:35.021847",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "generally multi methods are also global, created with defmulti (technically you could create an anonymous one, but I have never actually seen anyone do that, and it would kind of defeat the purpose)"
  },
  {
    "timestamp": "2017-07-21T16:19:06.035004",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> quick question on Integrant (I’m half way through the talk): how would I proceed to mock the implementation of one of the services?"
  },
  {
    "timestamp": "2017-07-21T16:19:08.035746",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "so if you want to create a mock, you have to use defmethod which effects the global multimethod"
  },
  {
    "timestamp": "2017-07-21T16:19:33.046021",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "if you use protocols you can generally reify the protocol inline in the test, and outside of the test there is no effect"
  },
  {
    "timestamp": "2017-07-21T16:19:34.046707",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "ah, so the latest defmethod will be used, overriding a previous definition?"
  },
  {
    "timestamp": "2017-07-21T16:19:53.054521",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "that’s a bit nasty"
  },
  {
    "timestamp": "2017-07-21T16:19:54.054978",
    "conversation_id": 382,
    "user": "Merrie",
    "message": "_\"hate a la carte\" joke_"
  },
  {
    "timestamp": "2017-07-21T16:19:59.057265",
    "conversation_id": 382,
    "user": "Martina",
    "message": "<@Lucia> Online peace is a noble goal"
  },
  {
    "timestamp": "2017-07-21T16:20:26.068824",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "For that, I tend to use protocols. In Duct (which builds on Integrant), I call them “boundary protocols”, as they define the I/O boundary of the system."
  },
  {
    "timestamp": "2017-07-21T16:20:29.070096",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "ah nevermind, got an answer by <@Rebeca> :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:20:39.074555",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "oh, I’ll check Duct"
  },
  {
    "timestamp": "2017-07-21T16:20:45.077177",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "uh, yes, but that is not what I meant"
  },
  {
    "timestamp": "2017-07-21T16:20:46.077450",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "For example: <https://github.com/duct-framework/database.sql/blob/master/src/duct/database/sql.clj>"
  },
  {
    "timestamp": "2017-07-21T16:21:09.087403",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Instead of just returning the database spec, I wrap it in a record."
  },
  {
    "timestamp": "2017-07-21T16:21:38.099547",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "This allows me to write a protocol against it, and I can mock out the protocol for tests using a tool like Shrubbery."
  },
  {
    "timestamp": "2017-07-21T16:21:57.107706",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "each multi method has a dispatch table for behaviors, so say you want stick in a :my-special-mock, well that goes in the table associated with the multimethod, less likely to cause harm than actually replacing the dispatch, but still kind of a drag"
  },
  {
    "timestamp": "2017-07-21T16:22:00.109083",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "It’s also useful for having a “local” service that fakes out cloud services or external APIs etc."
  },
  {
    "timestamp": "2017-07-21T16:22:36.124179",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Yes that’s exactly the sort of application I’m thinking. Two more projects to look at on my list :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-07-21T16:22:47.129558",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "(following the thread with <@Ramonita>) it looks like he uses protocols for some stuff, so maybe that is less of a problem"
  },
  {
    "timestamp": "2017-07-21T16:23:41.152479",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> the last web framework I looked into was Pedestal. Do you have any opinions on it?"
  },
  {
    "timestamp": "2017-07-21T16:23:56.158611",
    "conversation_id": 382,
    "user": "Rebeca",
    "message": "at my last job we used component but had a team member who hated defrecords, so we more or less retro-fitted component to use multimethods instead (which is pretty easy to do) which is where my experience with the pain of mocking that kind of thing comes from"
  },
  {
    "timestamp": "2017-07-21T16:25:47.206033",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "I haven’t use Pedestal in anger. Some ideas it has are good, but it feels more complex than what I need, and it’s web-focused."
  },
  {
    "timestamp": "2017-07-21T16:44:12.681607",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> sorry, watching the rest of your talk and reading a bit of Duct’s doc I realise this was a silly question. Duct seems more like an approach to structure an application around Integrant"
  },
  {
    "timestamp": "2017-07-21T16:45:48.723163",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Right. It provides a template, a bunch of integrant-compatible libraries, and “modules” which are essentially pure functions that transform the Integrant configuration."
  },
  {
    "timestamp": "2017-07-21T16:46:32.741654",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Modules provide a way of automating gluing together libraries"
  },
  {
    "timestamp": "2017-07-21T16:47:30.767502",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> do you have an example of how a module would work?"
  },
  {
    "timestamp": "2017-07-21T16:48:08.784079",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "An example, or an explanation?"
  },
  {
    "timestamp": "2017-07-21T16:48:39.797879",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "explanation, or an explanatory example :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T16:49:12.812148",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Okay, let me find something quick…"
  },
  {
    "timestamp": "2017-07-21T16:52:31.898120",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Actually, I wrote a blog post about this, which might be more useful: <https://www.booleanknot.com/blog/2017/05/09/advancing-duct.html>"
  },
  {
    "timestamp": "2017-07-21T16:53:18.917621",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> ah that’s perfect, thank you!"
  },
  {
    "timestamp": "2017-07-21T16:53:27.921734",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "One module is `:duct.module/web`. That sets up a handler and middleware, and looks through the configuration for a web server. If it finds one, it connects the handler to the existing web server. If none exist, then it creates a new one."
  },
  {
    "timestamp": "2017-07-21T16:53:48.930200",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "There’s also: <https://www.booleanknot.com/blog/2017/05/29/building-web-services-with-duct.html>"
  },
  {
    "timestamp": "2017-07-21T16:54:18.942910",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "The explanation I find myself often using for modules are web sessions that are stored in a SQL database."
  },
  {
    "timestamp": "2017-07-21T16:54:25.945856",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "how does it “find the web server” in the config? based on the name of popular web servers?"
  },
  {
    "timestamp": "2017-07-21T16:54:31.948156",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "or a special key?"
  },
  {
    "timestamp": "2017-07-21T16:54:55.958053",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Keyword inheritance. The `:duct.server.http/jetty` key is derived from `:duct.server/http`."
  },
  {
    "timestamp": "2017-07-21T16:55:21.969429",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "So to find all the web servers in a Duct config, you just run `(ig/find-derived config :duct.server/http)`"
  },
  {
    "timestamp": "2017-07-21T16:56:31.998957",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "The idea is to use `derive` a little like a dictionary definition or a thesaurus. It allows us to describe what a keyword is, to give it some meaning."
  },
  {
    "timestamp": "2017-07-21T16:56:35.000844",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "keyword inheritance is just based on the name + namespace of the keywords? e.g. a keyword X inherits from a keyword Y if X’s namespace is Y’s namespace plus its name?"
  },
  {
    "timestamp": "2017-07-21T16:57:02.012120",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "No, it’s its own thing. Any namespaced keyword can `derive` from any other."
  },
  {
    "timestamp": "2017-07-21T16:57:13.016424",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Namespaced keywords have multiple inheritance in Clojure."
  },
  {
    "timestamp": "2017-07-21T16:58:06.039102",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "ah, I wasn’t familiar with Clojure’s `clojure.core/derive` function. I’ll look into it before bothering you further"
  },
  {
    "timestamp": "2017-07-21T16:58:10.040927",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Thanks!"
  },
  {
    "timestamp": "2017-07-21T16:58:26.047682",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "It’s not often used, but I feel like it has some important niches"
  },
  {
    "timestamp": "2017-07-21T16:58:59.061988",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "<https://clojure.org/reference/multimethods>"
  },
  {
    "timestamp": "2017-07-21T17:00:29.100963",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "mmh, so `derive` is effectful from what I gather"
  },
  {
    "timestamp": "2017-07-21T17:01:00.114421",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Where does it hold the relationship data between keywords? A global registry? I can’t see it setting metadata on the keywords themselves"
  },
  {
    "timestamp": "2017-07-21T17:01:58.139294",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "A global registry. Derive *can* be used functionally if you supply a hierarchy, but mostly it’s used globally."
  },
  {
    "timestamp": "2017-07-21T17:02:12.144841",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "To my mind it’s like vars, or specs."
  },
  {
    "timestamp": "2017-07-21T17:02:22.149050",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Oh, I think I get what you meant by a “grammar” then. You use keywords + derive to build a sort of ontology?"
  },
  {
    "timestamp": "2017-07-21T17:02:29.152086",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Exactly :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T17:03:44.183801",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Jetty, for instance, is a HTTP server that supports synchronous and asynchronous handlers. So we could write: ``` (derive :duct.server.http/jetty :duct.server/http) (derive :duct.server.http/jetty :duct.server.http/async) (derive :duct.server.http/jetty :duct.server.http/sync) ```"
  },
  {
    "timestamp": "2017-07-21T17:03:59.189742",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "that’s brilliant"
  },
  {
    "timestamp": "2017-07-21T17:04:18.197229",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "If Integrant is the “grammar”, Duct is attempting to build a “vocabulary”."
  },
  {
    "timestamp": "2017-07-21T17:04:44.208065",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "So duct is an ontology for configuration + tools that understand and work with this ontology"
  },
  {
    "timestamp": "2017-07-21T17:05:13.219237",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Right. That, plus a way of transforming configurations via a preprocessing “prep” stage."
  },
  {
    "timestamp": "2017-07-21T17:05:20.222295",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Basically query+transformation"
  },
  {
    "timestamp": "2017-07-21T17:05:58.237501",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I’ll check out Duct’s code if it’s not too complex"
  },
  {
    "timestamp": "2017-07-21T17:06:08.241266",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "That’s super exciting"
  },
  {
    "timestamp": "2017-07-21T17:06:12.243156",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Start with duct/core"
  },
  {
    "timestamp": "2017-07-21T17:06:34.251976",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "<https://github.com/duct-framework/core/blob/master/src/duct/core.clj>"
  },
  {
    "timestamp": "2017-07-21T17:07:19.269128",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Essentially Duct tries to solve the problem of wiring up libraries. Even something seemingly trivial, like storing sessions in a SQL database, requires a lot of wiring."
  },
  {
    "timestamp": "2017-07-21T17:07:33.274446",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "You need a database migration to create the SQL table to store the sessions"
  },
  {
    "timestamp": "2017-07-21T17:07:38.276521",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "You need a DB connection"
  },
  {
    "timestamp": "2017-07-21T17:07:40.277203",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Middleware"
  },
  {
    "timestamp": "2017-07-21T17:07:46.279581",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Session storage protocol"
  },
  {
    "timestamp": "2017-07-21T17:07:58.283993",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "And a worker process to clean up old sessions"
  },
  {
    "timestamp": "2017-07-21T17:08:52.304703",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Very hard to do with a normal library, but a module could ask questions like “Where do I register a new periodic cleanup job?” “Where do I add new middleware?” “Where can I add a database migration?”"
  },
  {
    "timestamp": "2017-07-21T17:10:15.336311",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "I guess it’s a form of convention over configuration"
  },
  {
    "timestamp": "2017-07-21T17:10:42.346658",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "But in the sense that with Duct you establish a language to talk about your configuration, deriving Duct concepts"
  },
  {
    "timestamp": "2017-07-21T17:10:56.352138",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "then modules can use this language to understand your configuration and act on it"
  },
  {
    "timestamp": "2017-07-21T17:12:05.378363",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Right. It borrows a lot from tools like Rails, but whereas Rails used the filesystem as the basis for its convention, Duct uses an immutable data structure."
  },
  {
    "timestamp": "2017-07-21T17:12:06.378916",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Instead of following some predefined key structure for your configuration, you just need to follow an ontology/grammar"
  },
  {
    "timestamp": "2017-07-21T17:12:24.385976",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Exactly :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-21T17:13:09.402830",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "It’s still early days, but that’s ultimately where Duct is going."
  },
  {
    "timestamp": "2017-07-21T17:13:13.404269",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "Are there any other projects that you know of which take this approach? Obviously ontologies are quite talked about in the context of the semantic web / knowledge bases / etc, but I think this is the first time I’ve seen it applied to a dev tool"
  },
  {
    "timestamp": "2017-07-21T17:15:38.458767",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Arachne is another of Duct’s inspirations"
  },
  {
    "timestamp": "2017-07-21T17:16:13.471858",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "It takes a similar approach, but I don’t think it emphasises the semantic ontology angle"
  },
  {
    "timestamp": "2017-07-21T17:16:56.487621",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "And rather than a data structure, it uses a bunch of scripting functions to create an in-memory datomic database, which is then translated into a Component system."
  },
  {
    "timestamp": "2017-07-21T17:17:04.490288",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "Duct IMO is a little simpler."
  },
  {
    "timestamp": "2017-07-21T17:20:03.554783",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> thanks for taking the time to explain this out! I’ll read up on Duct/Integrant. The theory sounds great; let’s see if it holds up in practice :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-07-21T17:20:25.562889",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "No problem - let me know what you think"
  },
  {
    "timestamp": "2017-07-21T17:21:12.579676",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "The two blog posts I linked, especially the later API-focused one, should give you a good idea of how to start."
  },
  {
    "timestamp": "2017-07-21T17:22:56.615854",
    "conversation_id": 382,
    "user": "Gus",
    "message": "If you want to evaluate mount/component/integrant, I’d recommend starting by just reading them"
  },
  {
    "timestamp": "2017-07-21T17:23:09.620374",
    "conversation_id": 382,
    "user": "Gus",
    "message": "they’re all in the 300-500 LoC range"
  },
  {
    "timestamp": "2017-07-21T17:23:42.632220",
    "conversation_id": 382,
    "user": "Lucio",
    "message": "<@Ramonita> I think I am going to have some fun with `clojure.core/derive` itself too. Such a neat little function"
  },
  {
    "timestamp": "2017-07-21T17:24:37.652131",
    "conversation_id": 382,
    "user": "Ramonita",
    "message": "I wouldn’t say it’s a function that should commonly be used; it’s got niche functionality. But I also think it’s underused. Not many people seem to have heard of it."
  },
  {
    "timestamp": "2017-07-21T17:25:11.664235",
    "conversation_id": 382,
    "user": "Gus",
    "message": "I mean there are things you can only learn by using them in a large project for a long time, or talking to someone who has, but I think reading them is a reasonable starting point"
  },
  {
    "timestamp": "2017-07-25T10:08:09.197684",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "I can't `apply` macro, can I?"
  },
  {
    "timestamp": "2017-07-25T10:10:25.283563",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "I essentially want to ``` (let [specs [:a :b]] (apply clojure.spec.alpha/cat (interleave specs specs))) ``` what my options are?"
  },
  {
    "timestamp": "2017-07-25T10:12:58.381872",
    "conversation_id": 438,
    "user": "Jodie",
    "message": "write a macro to do it :disappointed:"
  },
  {
    "timestamp": "2017-07-25T10:13:13.390981",
    "conversation_id": 438,
    "user": "Weston",
    "message": "or eval"
  },
  {
    "timestamp": "2017-07-25T10:13:14.391671",
    "conversation_id": 438,
    "user": "Corine",
    "message": "Nope. See <https://stackoverflow.com/a/9273469>"
  },
  {
    "timestamp": "2017-07-25T10:13:19.394821",
    "conversation_id": 438,
    "user": "Weston",
    "message": "pick your poison :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T10:14:14.430436",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "oh, wait, there is a ~@"
  },
  {
    "timestamp": "2017-07-25T10:14:27.438997",
    "conversation_id": 438,
    "user": "Weston",
    "message": "``` (let [specs [:a :b]] (eval `(clojure.spec.alpha/cat ~@(interleave specs specs)))) ```"
  },
  {
    "timestamp": "2017-07-25T10:14:28.439521",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "forgot about it"
  },
  {
    "timestamp": "2017-07-25T10:14:39.446731",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "exactly, thanks"
  },
  {
    "timestamp": "2017-07-25T10:14:56.457948",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "wait, why eval?"
  },
  {
    "timestamp": "2017-07-25T10:15:12.468560",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "ah, it's not wrapped in macro."
  },
  {
    "timestamp": "2017-07-25T10:15:50.493383",
    "conversation_id": 438,
    "user": "Weston",
    "message": "yep, I prefer eval personally for that stuff. a macro def will stay here in all its uselessness after you used it to generate your spec"
  },
  {
    "timestamp": "2017-07-25T10:16:04.502193",
    "conversation_id": 438,
    "user": "Weston",
    "message": "depends if you need to do that a lot or not"
  },
  {
    "timestamp": "2017-07-25T10:16:53.534166",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "I wanted a macro initially, because I have too many `s/cat`s where I basically reuse spec names as dispatch keys"
  },
  {
    "timestamp": "2017-07-25T10:18:08.582606",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "figured I'd try to just re-use spec names instead of coming up with throw-away names time and time again."
  },
  {
    "timestamp": "2017-07-25T10:20:02.656902",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "<@Corine> thanks, I just forgot about ~@ splicing. it's all good now"
  },
  {
    "timestamp": "2017-07-25T10:26:45.918558",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "while we are on macro subject: how do grown ups validate macro's input (e.g. with spec)?"
  },
  {
    "timestamp": "2017-07-25T11:19:22.041907",
    "conversation_id": 438,
    "user": "Sonny",
    "message": "<@Merrie> s/conform"
  },
  {
    "timestamp": "2017-07-25T12:53:51.786602",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "is there a way to get fn's arity? like ``` (arity filter) ;; => [1 2] ``` actually I am not even sure why I am asking this :dafuq:"
  },
  {
    "timestamp": "2017-07-25T12:57:04.905102",
    "conversation_id": 438,
    "user": "Sonny",
    "message": "no"
  },
  {
    "timestamp": "2017-07-25T13:10:27.396032",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "<@Merrie> In cljs, you can do `(.-length (.-constructor (.-prototype render)))`"
  },
  {
    "timestamp": "2017-07-25T13:13:04.486700",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "Or why not `(-> render .-prototype .-constructor .-length)`. We’re not barbarians after all."
  },
  {
    "timestamp": "2017-07-25T13:13:21.496127",
    "conversation_id": 438,
    "user": "Berry",
    "message": "anyone else find code written via reduce to be \"obfuscated\" ?"
  },
  {
    "timestamp": "2017-07-25T13:13:46.510434",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "<@Berry> Example?"
  },
  {
    "timestamp": "2017-07-25T13:13:49.512205",
    "conversation_id": 438,
    "user": "Berry",
    "message": "for some reason, when writing code involving reduce, it's always: 1. how can I write this imperatively ? 2. then I reformulate it as reduce"
  },
  {
    "timestamp": "2017-07-25T13:14:39.541132",
    "conversation_id": 438,
    "user": "Berry",
    "message": "<@Nilda>: no concrete example, just that most of the time, I want to do: ``` (let [state (atom ...)] (doseq ...)) ```"
  },
  {
    "timestamp": "2017-07-25T13:14:57.551827",
    "conversation_id": 438,
    "user": "Berry",
    "message": "then I end up \"inverting\" the doseq / modification to the @state atom in order to get my reduce code"
  },
  {
    "timestamp": "2017-07-25T13:17:30.640829",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "<@Berry> There’s nothing inherently wrong with that, in my opinion. For me, it’s a quite common pattern that I pull out the transducers once I start noticing boilerplate and repeating patterns in the code."
  },
  {
    "timestamp": "2017-07-25T13:18:30.675969",
    "conversation_id": 438,
    "user": "Berry",
    "message": "<@Nilda>: have you used Haskell? the haskell solution to this would be the 'state' monad, then an external sequence_"
  },
  {
    "timestamp": "2017-07-25T13:19:23.705808",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "<@Berry> Unfortunately I haven’t used it beyond the tutorial on the home page (which is quite nice)"
  },
  {
    "timestamp": "2017-07-25T13:22:54.831779",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "`map` does seem to be easier to visualize than `reduce` though. I think `map` corresponds more to everyday patterns of life. You can imagine walking along a row of potted plants and watering each for example, getting a row of watered plants."
  },
  {
    "timestamp": "2017-07-25T13:23:33.855746",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "But what would be the `reduce` version of that? Repot them in one large pot, one plant at a time?"
  },
  {
    "timestamp": "2017-07-25T13:24:43.898131",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "But also, the order in which they were repotted would somehow matter. I don’t know, it’s not _as_ straightforward."
  },
  {
    "timestamp": "2017-07-25T13:24:46.899453",
    "conversation_id": 438,
    "user": "Lizette",
    "message": "<@Berry> in Haskell how would you solve the problem?"
  },
  {
    "timestamp": "2017-07-25T13:25:27.924462",
    "conversation_id": 438,
    "user": "Lizette",
    "message": "(I'm just curious)"
  },
  {
    "timestamp": "2017-07-25T13:25:36.929670",
    "conversation_id": 438,
    "user": "Berry",
    "message": "<@Lizette> : I would write the code \"imperatively\" with putState / getState, then put it on a do block + use sequence_ if there's a list"
  },
  {
    "timestamp": "2017-07-25T13:26:14.952448",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "I find it easier to go `write using loop/recur` -> `refactor to reduce`"
  },
  {
    "timestamp": "2017-07-25T13:26:30.962690",
    "conversation_id": 438,
    "user": "Berry",
    "message": "the point is that the code goes something like: ``` s <- getState ... do some processing ... putState s' ``` but then the reduce somehow causes me to \"invert\" the state manipulation"
  },
  {
    "timestamp": "2017-07-25T13:26:42.969635",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "generally, than doseq. because that way you just delete a bunch of code and change some keywords. refactoring doseq and atom updates is annoying"
  },
  {
    "timestamp": "2017-07-25T13:27:17.990815",
    "conversation_id": 438,
    "user": "Berry",
    "message": "<@Aldo> : loop/recur is definitely closer to reduce than doseq/atom"
  },
  {
    "timestamp": "2017-07-25T13:27:48.010013",
    "conversation_id": 438,
    "user": "Berry",
    "message": "nevertheless, it seems that in an otherwise clean language, there's this mismatch between \"mental thought\" and \"how code has to be written\""
  },
  {
    "timestamp": "2017-07-25T13:28:09.022704",
    "conversation_id": 438,
    "user": "Berry",
    "message": "or maybe I just haven't mastered reduce idioms"
  },
  {
    "timestamp": "2017-07-25T13:29:02.054915",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "mmmmmm my assumption is that that mismatch is just a result of spending so much time in imperative languages. I definitely find myself having to go through that interim step a lot less than I did 4 years ago when I moved ruby->clojure. could be wrong though"
  },
  {
    "timestamp": "2017-07-25T13:30:01.091107",
    "conversation_id": 438,
    "user": "Berry",
    "message": "haskell is not exactly '"
  },
  {
    "timestamp": "2017-07-25T13:30:08.095632",
    "conversation_id": 438,
    "user": "Berry",
    "message": "imperative' -- some would say it's even more 'functional' :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T13:30:29.109496",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "<@Berry> Is there no notion of `reduce` in Haskell though?"
  },
  {
    "timestamp": "2017-07-25T13:30:39.115125",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "that’s foldl"
  },
  {
    "timestamp": "2017-07-25T13:30:43.117779",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "there is, and it would be considered *way* more idiomatic than using the state monad"
  },
  {
    "timestamp": "2017-07-25T13:30:46.119631",
    "conversation_id": 438,
    "user": "Berry",
    "message": "haskell definitely has foldl / foldr, but it also has state monads + sequence_"
  },
  {
    "timestamp": "2017-07-25T13:31:10.133923",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "and it’s provable that everything you can do via state manipulation you can do in a left fold / reduce, it’s just a different code pattern to do it"
  },
  {
    "timestamp": "2017-07-25T13:31:19.139619",
    "conversation_id": 438,
    "user": "Berry",
    "message": "I would say, any time you're bashing state, state monad is more idiomatic than folds"
  },
  {
    "timestamp": "2017-07-25T13:31:30.145782",
    "conversation_id": 438,
    "user": "Berry",
    "message": "and with reduce, the initial value is basically your 'local state'"
  },
  {
    "timestamp": "2017-07-25T13:31:33.147737",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "the state monad is a \"purely functional statically typed\" math trick around writing an imperative looking thing and still keeping it pure"
  },
  {
    "timestamp": "2017-07-25T13:33:07.204870",
    "conversation_id": 438,
    "user": "Berry",
    "message": "yeah, I guess 99% of the problems I have with clojure is: it doesn't have haskell's type system :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T13:33:27.216877",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "funny, that's my favourite thing about clojure :laughing:"
  },
  {
    "timestamp": "2017-07-25T13:34:43.263261",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "<@Berry> frege is haskell for the jvm, and it would even be usable except it is too hard to use interfaces or extend java types (because it really does implement haskell’s type system - which is better but also alien to the platform)"
  },
  {
    "timestamp": "2017-07-25T13:35:24.287652",
    "conversation_id": 438,
    "user": "Berry",
    "message": "I tried using frege once; I found neither the documentation nor the community helpful."
  },
  {
    "timestamp": "2017-07-25T13:35:29.290899",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "I would have totally used it for some things in my codebase but not being able to define or implement interfaces (not to mention concrete inheritence, which clojure taught me how to do without), it was a no go"
  },
  {
    "timestamp": "2017-07-25T13:35:32.292625",
    "conversation_id": 438,
    "user": "Carry",
    "message": "Is there a way that others are using tools like `eastwood` with files that contain namespaced keywords?"
  },
  {
    "timestamp": "2017-07-25T13:35:51.304062",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "<@Berry> I think their assumption is “just do it the way you would in haskell”"
  },
  {
    "timestamp": "2017-07-25T13:35:53.305305",
    "conversation_id": 438,
    "user": "Aldo",
    "message": "thing is clojure just has no need for a state monad, because if imperative code is what's appropriate there *are* mutable options"
  },
  {
    "timestamp": "2017-07-25T13:35:57.307979",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "Well, cognitively, our problem solving is very pattern based. A problem occurs->go fetch the nearest solution from memory that approximately fits problem->apply to problem. Certain mismatch is bound to happen when encountering a somewhat different paradigm."
  },
  {
    "timestamp": "2017-07-25T13:42:27.545252",
    "conversation_id": 438,
    "user": "Nilda",
    "message": "Personally, I find macros to be some of the most intractable marshlands of the language. The parser in my head doesn’t predict the output of a macro well at all."
  },
  {
    "timestamp": "2017-07-25T13:57:12.100265",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "<@Margaret> I really liked the promise of Frege and spent quite a bit of time working with it -- I wrote a Leiningen plugin for it and put out some mixed Clojure / Frege code examples. But, ultimately, I just found it too frustrating to use and kept going back to Clojure... which kinda fits in with the love/hate relationship I've had with Haskell ever since it appeared (I always hoped Haskell would rule the world but it seemed like the team behind it tried very hard to make sure that didn't happen!)."
  },
  {
    "timestamp": "2017-07-25T13:57:59.130169",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "yeah I think I might have first heard of frege from you - and if I could have just defined / implemented interfaces I could have used it for my project…"
  },
  {
    "timestamp": "2017-07-25T13:58:35.154132",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "I just watched Prof Turner's talk about \"Some History of Functional Programming Languages\" from the Poland FP conference this year. Great to hear how everything came together (he was going to be my external examiner for my PhD thesis back in '86... if I'd actually completed it!)."
  },
  {
    "timestamp": "2017-07-25T13:59:53.204037",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "We used Miranda at my university and I was familiar with ML and SASL and a bunch of the other FP languages that all merged into Haskell. I created my own (SURE), just like all the other FP researchers in England at the time! :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T14:00:10.215916",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "Whereabout did you study?"
  },
  {
    "timestamp": "2017-07-25T14:00:51.242898",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "I remember checking out CLEAN shortly after I got into software (by reading “tech yourself C++ in 21 days”)"
  },
  {
    "timestamp": "2017-07-25T14:01:10.255003",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "in retrospect I’m amazed I got turned to such an interesting direction so early on"
  },
  {
    "timestamp": "2017-07-25T14:01:25.264726",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "<https://www.youtube.com/watch?v=QVwm9jlBTik&__s=csfyzpydsvfikkqz5bvw> (for those who missed the link in Eric's <http://PurelyFunctional.tv|PurelyFunctional.tv> newsletter)"
  },
  {
    "timestamp": "2017-07-25T14:01:59.287541",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "University of Surrey (Guildford)."
  },
  {
    "timestamp": "2017-07-25T14:02:19.300430",
    "conversation_id": 438,
    "user": "Daniell",
    "message": "SURE was Surrey University Recursive Evaluator :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T14:02:25.304140",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "ooh, makes sense!"
  },
  {
    "timestamp": "2017-07-25T14:20:38.997516",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "Hi! I have the following in a Datalog query: ``` '[:find ... :where [(wef-backend.app.identity/past-expiry? ?expiry)]]] ```"
  },
  {
    "timestamp": "2017-07-25T14:21:01.011233",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "Due to how Datomic/Datalog works I must fully qualify the past-expiry? function, even though it is available in the namespace where I wrote this query"
  },
  {
    "timestamp": "2017-07-25T14:21:09.016516",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "is there some clever trick that would let me omit the full qualifier?"
  },
  {
    "timestamp": "2017-07-25T14:21:27.027258",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "I tried syntax quoting on the query but that doesn’t work, as it fully qualifies the `?expiry, etc` variables too"
  },
  {
    "timestamp": "2017-07-25T14:22:07.052151",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "Essentially I would like to fully qualify some symbols in that quoted expression"
  },
  {
    "timestamp": "2017-07-25T14:22:11.053835",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "but not others"
  },
  {
    "timestamp": "2017-07-25T14:24:35.144405",
    "conversation_id": 438,
    "user": "Charlene",
    "message": "I don't recall any problems with namespaced keywords, but I seem to remember I had problems with namespaced maps. As these were limited to my test classes, I added these namespaces to the ignore list I think. Also, I think there were some fixes on the master branch that remain unreleased. A bit vague I realise, but if you're still stuck tomorrow (unlikely) then I'll check when I'm back in front of a computer..."
  },
  {
    "timestamp": "2017-07-25T14:31:08.387949",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "<@Lucio> you can use ` for this, and selectively use ~ for the symbols you want to namespace qualify"
  },
  {
    "timestamp": "2017-07-25T14:31:37.406632",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "<@Margaret> how so? I tried variations on your suggestion but didn’t manage to get it to work"
  },
  {
    "timestamp": "2017-07-25T14:32:56.456571",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "```peregrine.circle=> `[:find ... :where [identity ~'?foo]] [:find ... :where [clojure.core/identity ?foo]]```"
  },
  {
    "timestamp": "2017-07-25T14:33:11.466026",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "I just picked a random thing with identity in the name, but I hope it translates"
  },
  {
    "timestamp": "2017-07-25T14:34:22.510743",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "ah"
  },
  {
    "timestamp": "2017-07-25T14:34:26.513223",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "I guess I should have explicitly mentioned the `~'` idiom to prevent namespacing"
  },
  {
    "timestamp": "2017-07-25T14:34:36.519558",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "is there a way to do the opposite? selectively pick the symbols I want to namespace qualify"
  },
  {
    "timestamp": "2017-07-25T14:34:43.524070",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "that’s harder"
  },
  {
    "timestamp": "2017-07-25T14:34:46.525473",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "instead of the ones I do not want to namespace qualify"
  },
  {
    "timestamp": "2017-07-25T14:34:49.527555",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "mmh ok"
  },
  {
    "timestamp": "2017-07-25T14:34:51.528562",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "nevermind then"
  },
  {
    "timestamp": "2017-07-25T14:34:53.529508",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "thanks :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-25T14:35:37.556918",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "this is close, but no cigar ```peregrine.circle=> '[:find ... :where [`identity ?foo]] [:find ... :where [(quote clojure.core/identity) ?foo]]```"
  },
  {
    "timestamp": "2017-07-25T14:35:51.565085",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "yep, not quite :confused:"
  },
  {
    "timestamp": "2017-07-25T14:36:14.579551",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "why wouldn’t this work: ``` '[:find ... :where [~`identity ?foo]] ``` ?"
  },
  {
    "timestamp": "2017-07-25T14:36:34.591687",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "~ doesn’t make sense outside `"
  },
  {
    "timestamp": "2017-07-25T14:36:52.602991",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "why does it make sense here: ``` `[:find ... :where [identity ~'?foo]] ``` ?"
  },
  {
    "timestamp": "2017-07-25T14:37:10.614296",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "it’s inside the ` at the beginning of the vector"
  },
  {
    "timestamp": "2017-07-25T14:37:11.615245",
    "conversation_id": 438,
    "user": "Merrie",
    "message": "thanks"
  },
  {
    "timestamp": "2017-07-25T14:37:55.642722",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "right, but why does swapping out the use of syntax quoting vs normal quoting makes it different in use?"
  },
  {
    "timestamp": "2017-07-25T14:38:01.646719",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "(I’m not familiar enough with quoting yet)"
  },
  {
    "timestamp": "2017-07-25T14:38:08.650934",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "because ~ is only valid in syntax quote"
  },
  {
    "timestamp": "2017-07-25T14:38:13.653895",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "oh"
  },
  {
    "timestamp": "2017-07-25T14:38:35.667554",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "it’s a special operation that is only defined in that context"
  },
  {
    "timestamp": "2017-07-25T14:39:35.704077",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "using it outside throws ```java.lang.IllegalStateException: Attempting to call unbound fn: #'clojure.core/unquote```"
  },
  {
    "timestamp": "2017-07-25T14:39:41.707426",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "does this only get bound within a syntax quote?"
  },
  {
    "timestamp": "2017-07-25T14:39:50.712595",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "or is that a different error?"
  },
  {
    "timestamp": "2017-07-25T14:39:54.715018",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "right, it exapands to unquote, that is undefined outside `"
  },
  {
    "timestamp": "2017-07-25T14:40:14.727242",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "this is all stuff implemented in the java code of the reader"
  },
  {
    "timestamp": "2017-07-25T14:40:25.733891",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "it isn’t built on the normal machinery, it’s the basis for it"
  },
  {
    "timestamp": "2017-07-25T14:40:42.744637",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "is unquote a special form?"
  },
  {
    "timestamp": "2017-07-25T14:40:59.754696",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "syntax-quote ` is special, and it handles unquote"
  },
  {
    "timestamp": "2017-07-25T14:41:18.766382",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "so unquote will get evaluate somehow within a syntax quote"
  },
  {
    "timestamp": "2017-07-25T14:41:23.769207",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "but outside of it it has no meaning"
  },
  {
    "timestamp": "2017-07-25T14:41:27.771653",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "and even inside, it’s not a function"
  },
  {
    "timestamp": "2017-07-25T14:41:32.774793",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "it’s just a symbol that ` interprets"
  },
  {
    "timestamp": "2017-07-25T14:41:35.776420",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "correct?"
  },
  {
    "timestamp": "2017-07-25T14:41:37.777804",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "right, it’s a parser machinery basically"
  },
  {
    "timestamp": "2017-07-25T14:42:04.793894",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "we’re at the point in this convo where I’d probably have to read more code to answer more questions though"
  },
  {
    "timestamp": "2017-07-25T14:42:23.805487",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "Luckily for you I don’t have more questions at the moment :smile:"
  },
  {
    "timestamp": "2017-07-25T14:42:34.812122",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "like whether there’s an actual unquote method somewhere in Compiler.java or if it’s entirely a figment of syntax-quote"
  },
  {
    "timestamp": "2017-07-25T14:43:13.835072",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "For now I think I am contempt with the answer that clojure.core/unquote is not a function, but something that has a special interpretation within a syntax quote"
  },
  {
    "timestamp": "2017-07-25T14:43:44.853974",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "there’s this, but I am not totally sure what it means - UNQUOTE used to be defined as a special symbol but now it is commented out <https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Compiler.java#L70>"
  },
  {
    "timestamp": "2017-07-25T14:45:39.925193",
    "conversation_id": 438,
    "user": "Carry",
    "message": "Ah, to be more specific, I am using `lein eastwood '{:add-linters [:unused-namespaces] :namespaces [:source-paths] :exclude-linters [:unlimited-use]}'` as my command, and I get an error for a namespaced spec (so you might be right that a namespaced keyword would not create problems, sorry!)."
  },
  {
    "timestamp": "2017-07-25T14:45:41.926138",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "unquote never makes it to the compiler"
  },
  {
    "timestamp": "2017-07-25T14:46:04.940432",
    "conversation_id": 438,
    "user": "Carry",
    "message": "```== Eastwood 0.2.4 Clojure 1.9.0-alpha17 JVM 1.8.0_121 Exception in thread \"main\" clojure.lang.ExceptionInfo: Invalid token: ::spec-ns/spec-name {:type :reader-exception}```"
  },
  {
    "timestamp": "2017-07-25T14:46:06.941307",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "it's handled by the reader earlier than that"
  },
  {
    "timestamp": "2017-07-25T14:47:21.986367",
    "conversation_id": 438,
    "user": "Carry",
    "message": "```(ns acme.spec-ns (:require [clojure.spec.alpha :as s])) (s/def ::spec-name string?) ```"
  },
  {
    "timestamp": "2017-07-25T14:47:39.997116",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "<@Kareen> could you point at where exactly it is handled?"
  },
  {
    "timestamp": "2017-07-25T14:48:00.009847",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "<https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L986-L990>"
  },
  {
    "timestamp": "2017-07-25T14:48:15.018936",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "<https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L1040-L1044>"
  },
  {
    "timestamp": "2017-07-25T14:48:26.026034",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "from within the implementation of syntax quote"
  },
  {
    "timestamp": "2017-07-25T14:49:08.050763",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "the tl;dr is that when the compiler sees `~foo` it expands into `(clojure.core/unquote foo)`"
  },
  {
    "timestamp": "2017-07-25T14:49:23.060026",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "<@Kareen> ah, so if it’s an unquote form it simply gets rid of the “unquote” and “quote” bits at reading time?"
  },
  {
    "timestamp": "2017-07-25T14:49:38.069261",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "then syntax-quote walks its expression and expands all the unquoted forms"
  },
  {
    "timestamp": "2017-07-25T14:50:22.095845",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "you can see how that gets transformed by quoting a syntax-quoted expression"
  },
  {
    "timestamp": "2017-07-25T14:50:34.102802",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "```user=> '`(~a) (clojure.core/seq (clojure.core/concat (clojure.core/list a))) ```"
  },
  {
    "timestamp": "2017-07-25T14:50:38.105650",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "so the reader would transform `(clojure.core/unquote 'foo)` into `foo`?"
  },
  {
    "timestamp": "2017-07-25T14:50:46.110164",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "it's more complex than that"
  },
  {
    "timestamp": "2017-07-25T14:50:47.111243",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "oh"
  },
  {
    "timestamp": "2017-07-25T14:50:49.111985",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "because of splicing"
  },
  {
    "timestamp": "2017-07-25T14:51:08.123826",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "if there was no splicing then it would be this simple?"
  },
  {
    "timestamp": "2017-07-25T14:51:16.128774",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "more or less, yes"
  },
  {
    "timestamp": "2017-07-25T14:51:40.142894",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "but because of splicing, it has to wrap every subform that is unquoted in a list & concat them all"
  },
  {
    "timestamp": "2017-07-25T14:51:49.148609",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "so splicing becomes just like unquote w/o the wrapping list"
  },
  {
    "timestamp": "2017-07-25T14:51:57.153033",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "```user=> '`(~@a) (clojure.core/seq (clojure.core/concat a)) user=> ```"
  },
  {
    "timestamp": "2017-07-25T14:52:16.163236",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "because the list is already in `a` (so to speak)"
  },
  {
    "timestamp": "2017-07-25T14:52:51.181943",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "the impl is quite more complex because it has to deal with maps/vectors/sets other than just lists"
  },
  {
    "timestamp": "2017-07-25T14:52:54.183267",
    "conversation_id": 438,
    "user": "Kareen",
    "message": "but that's the basic idea"
  },
  {
    "timestamp": "2017-07-25T14:53:11.191837",
    "conversation_id": 438,
    "user": "Lucio",
    "message": "thanks! that clarifies things"
  },
  {
    "timestamp": "2017-07-25T14:57:26.350282",
    "conversation_id": 438,
    "user": "Renata",
    "message": "has anyone written about how to organize specs when they don’t perfectly map to namespaces etc?"
  },
  {
    "timestamp": "2017-07-25T14:57:46.362109",
    "conversation_id": 438,
    "user": "Carry",
    "message": "When I use `(:require [acme.spec-ns :as spec-ns]) ... (clojure.spec.alpha/validate ::spec-ns/spec-name) ...)`, this is the context I have using a namespaced spec in"
  },
  {
    "timestamp": "2017-07-25T14:58:37.393013",
    "conversation_id": 438,
    "user": "Margaret",
    "message": "I’d be interested to see a well reasoned pitch justifying the practice"
  },
  {
    "timestamp": "2017-07-25T15:01:07.486089",
    "conversation_id": 438,
    "user": "Elvin",
    "message": "Professional software dev is hard, man. Companies are hard."
  },
  {
    "timestamp": "2017-07-25T15:02:58.553747",
    "conversation_id": 438,
    "user": "Rebeca",
    "message": "it seems like people are really tied to namespaces on keywords matching the namespaces code is organized in to"
  },
  {
    "timestamp": "2017-07-25T15:03:06.558435",
    "conversation_id": 438,
    "user": "Rebeca",
    "message": "there is no reason for that"
  },
  {
    "timestamp": "2017-07-25T15:07:20.705839",
    "conversation_id": 438,
    "user": "Renata",
    "message": "ok yeah, that seems like a sensible argument"
  },
  {
    "timestamp": "2017-07-27T13:09:10.233423",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "if you want to measure calculation time (or run for side effects) and don’t need the result, use dorun instead of doall"
  },
  {
    "timestamp": "2017-07-27T13:32:45.068207",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "also, sequence is not typically more efficient than regular lazy ops in most cases iirc"
  },
  {
    "timestamp": "2017-07-27T13:59:35.036290",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I’d start with the general concept of event sourcing, which is more general and more usable than CQRS"
  },
  {
    "timestamp": "2017-07-27T14:00:54.087833",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> right, sorry, I think my question was misphrased. Right now I am more concerned about how to structure my code at the application level (how to organise functions and manage side effects)"
  },
  {
    "timestamp": "2017-07-27T14:01:09.097005",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "event sourcing is a strategy for this"
  },
  {
    "timestamp": "2017-07-27T14:01:14.099660",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Datomic already gives me some level of event sourcing, which is enough for my needs"
  },
  {
    "timestamp": "2017-07-27T14:01:18.102757",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "ah"
  },
  {
    "timestamp": "2017-07-27T14:01:21.104818",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "how so <@Margaret> ?"
  },
  {
    "timestamp": "2017-07-27T14:01:32.111158",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the concept is that events are immutable and describe the actual domain data"
  },
  {
    "timestamp": "2017-07-27T14:01:53.124692",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "then, your db describes state, and is created via a reduce across the events (literally or conceptually)"
  },
  {
    "timestamp": "2017-07-27T14:01:56.126548",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> i mean, I am familiar with what event sourcing is, but I don’t see how it would help with this"
  },
  {
    "timestamp": "2017-07-27T14:02:12.136294",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "because now your state is just a query across your events"
  },
  {
    "timestamp": "2017-07-27T14:02:17.139544",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "it’s an optimization"
  },
  {
    "timestamp": "2017-07-27T14:02:49.159504",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "so you have “all events”, from that you derive a postgress db, or a datomic db, or even a mongo db - via looping over the events, maybe with reduce"
  },
  {
    "timestamp": "2017-07-27T14:02:54.162280",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "that’s your state of the world"
  },
  {
    "timestamp": "2017-07-27T14:03:24.181724",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Right, but Datomic already gives a fairly event-sourced model (except that transactions dont’ represent domain actions, but they can be reified with a key that does represent a domain action)"
  },
  {
    "timestamp": "2017-07-27T14:03:28.183914",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "now, if your events are set up properly (strictly ordered, immutable) - all instances of your app have access to the same time series of immutable states"
  },
  {
    "timestamp": "2017-07-27T14:03:59.203261",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Datomic’s transaction log can be considered as the event log"
  },
  {
    "timestamp": "2017-07-27T14:04:00.204026",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "queries are reads of the current state, “modifications” are insertions into the stream of events (you must loop back up to that level)"
  },
  {
    "timestamp": "2017-07-27T14:04:04.206358",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "right, right"
  },
  {
    "timestamp": "2017-07-27T14:04:17.214882",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "so you are on the right track if using datomic, you don’t need CQRS for this"
  },
  {
    "timestamp": "2017-07-27T14:04:49.233868",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "My concern is more: how do I nicely separate my “business logic” (functions that perform transactions, authorisation and reify transactions with additional infos) from my API"
  },
  {
    "timestamp": "2017-07-27T14:04:58.239302",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "in the application code"
  },
  {
    "timestamp": "2017-07-27T14:05:02.241565",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "sorry if this wasn’t clear"
  },
  {
    "timestamp": "2017-07-27T14:05:25.255726",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I use protocols to describe my domain / API level abstractions"
  },
  {
    "timestamp": "2017-07-27T14:05:25.255892",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "what should the interface for those functions be to make them easy to think about and deal with, etc"
  },
  {
    "timestamp": "2017-07-27T14:05:49.270237",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "then for my implementation, I use functional code over vanilla data structures implementing those protocols"
  },
  {
    "timestamp": "2017-07-27T14:06:20.288526",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the protocols are used as a signal to a reader of the code / user of the library that these names describe domain level concepts, they are the big picture organization of the code"
  },
  {
    "timestamp": "2017-07-27T14:06:32.296064",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "do you have an example of this structure?"
  },
  {
    "timestamp": "2017-07-27T14:06:53.308462",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I’ll have to see if I have a good open source implementation of it…"
  },
  {
    "timestamp": "2017-07-27T14:06:57.310756",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "so protocols are your “public API”, and all other functions are implementation details"
  },
  {
    "timestamp": "2017-07-27T14:07:18.322881",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "right - and the protocol methods are expected to take and return hash maps, vectors, keywords, numbers"
  },
  {
    "timestamp": "2017-07-27T14:07:51.342041",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "so we don’t pile on mountains of OO, we use modeling tools on the boundaries as a line in the sand, so to speak - to declare organizational intention"
  },
  {
    "timestamp": "2017-07-27T14:07:52.342278",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "how do you pass context around (db, conn and auth)? and how do you perform authorisation / reified transactions, if you do so?"
  },
  {
    "timestamp": "2017-07-27T14:08:20.358826",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I use component, so that each subsystem gets the parts of the app that it needs passed in on initialization"
  },
  {
    "timestamp": "2017-07-27T14:09:33.400587",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Could you give me a example of a protocol definition you use in one of your apps?"
  },
  {
    "timestamp": "2017-07-27T14:10:10.421978",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "absolutely - found it!"
  },
  {
    "timestamp": "2017-07-27T14:10:15.425049",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "protocol definition <https://github.com/noisesmith/ludic/blob/master/src/clj/org/noisesmith/ludic/protocol.clj>"
  },
  {
    "timestamp": "2017-07-27T14:10:27.431937",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "implementation <https://github.com/noisesmith/ludic/blob/master/src/clj/org/noisesmith/ludic.clj>"
  },
  {
    "timestamp": "2017-07-27T14:11:41.475511",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "and brilliant, thanks!"
  },
  {
    "timestamp": "2017-07-27T14:11:57.484985",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "oh man - that project is in a slightly weird state, there’s two GameBoard protocols that should have different names, and some protocols that need to be moved to the proto namespace"
  },
  {
    "timestamp": "2017-07-27T14:12:03.488743",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "if those functions were hitting a database, would your record hold its ref?"
  },
  {
    "timestamp": "2017-07-27T14:12:05.490081",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "sorry ! it’s still in heavy development"
  },
  {
    "timestamp": "2017-07-27T14:12:21.499620",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the record would expect the ref, yes"
  },
  {
    "timestamp": "2017-07-27T14:12:57.520732",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Mmh"
  },
  {
    "timestamp": "2017-07-27T14:13:29.539023",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "And if I want to reify *every* transaction with, say, the access token of the current user, how would you do this? Would you provide your own “transact” function, wrapping Datomic’s?"
  },
  {
    "timestamp": "2017-07-27T14:13:40.545601",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Sorry for the messy questions"
  },
  {
    "timestamp": "2017-07-27T14:14:50.586725",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "that’s a usage of reify that doesn’t match what I thought the word meant"
  },
  {
    "timestamp": "2017-07-27T14:15:13.600418",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "do you mean parameterize? I thought reify meant “make an abstract thing into a concrete one”"
  },
  {
    "timestamp": "2017-07-27T14:15:59.626668",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I thought that’s a usage I read in the doc"
  },
  {
    "timestamp": "2017-07-27T14:16:02.628795",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I might be mis-using the term"
  },
  {
    "timestamp": "2017-07-27T14:16:02.629017",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<http://blog.datomic.com/2015/12/reified-transactions.html>"
  },
  {
    "timestamp": "2017-07-27T14:16:20.639209",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I should have said “add an attribute to the reified transaction”"
  },
  {
    "timestamp": "2017-07-27T14:16:32.646352",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "ahh! now I get it, thanks"
  },
  {
    "timestamp": "2017-07-27T14:16:52.658395",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "so yeah, I would make an object that represents that reifications including the user id"
  },
  {
    "timestamp": "2017-07-27T14:17:25.677529",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "this is getting deeper into datomic than my working knowledge of it - I’ve taken a workshop but not gotten far with it in real usage"
  },
  {
    "timestamp": "2017-07-27T14:21:26.820533",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> haha ok, no worries. In general though, would you consider it “good code” if I wrapped all access to Datomic inside a protocol (e.g. IDatomicReaderWriter or something) so as to control how every transaction is made, and add some data to the transactions as I see fit?"
  },
  {
    "timestamp": "2017-07-27T14:22:40.864976",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I’d first see if this is an abstraction datomic itself allows"
  },
  {
    "timestamp": "2017-07-27T14:23:08.881646",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "unless your goal is to be able to swap in another database (which probably means forgoing a bunch of the features that make datomic worth it?)"
  },
  {
    "timestamp": "2017-07-27T14:23:50.907240",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I wouldn’t bother abstracting things that pragmatically wouldn’t be worth replacing ever"
  },
  {
    "timestamp": "2017-07-27T14:23:51.907510",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I wouldn’t want to swap out Datomic. The only thing I would want is “intercept” calls to `datomic/transact` to add some data to the transactions"
  },
  {
    "timestamp": "2017-07-27T14:24:14.921980",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "e.g. add the “current user id” as an attribute on the transaction"
  },
  {
    "timestamp": "2017-07-27T14:24:30.931785",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I’d say make your own function over transact that adds the data, probably parameterized with a hash map so you can generalize and introspect"
  },
  {
    "timestamp": "2017-07-27T14:24:31.932054",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "so that I don’t have to do this manually everywhere I call `datomic/transact` in my application"
  },
  {
    "timestamp": "2017-07-27T14:25:02.951671",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "ok; thanks!"
  },
  {
    "timestamp": "2017-07-27T14:25:51.981871",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "one thing to avoid is opaque wrappers (whether partial or an Object with hidden state - which btw is what a partial or closure is) - use a record implementing datomic’s own protocol if possible, but parameterized by keys you can introspect on the record and access in context"
  },
  {
    "timestamp": "2017-07-27T14:27:07.027910",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> is there a repl command to get the list of all protocols implemented by an object?"
  },
  {
    "timestamp": "2017-07-27T14:27:14.032383",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "well, the record of which an object is an instance"
  },
  {
    "timestamp": "2017-07-27T14:27:30.041732",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "supers"
  },
  {
    "timestamp": "2017-07-27T14:27:44.050407",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "ah right because protocols are just interfaces"
  },
  {
    "timestamp": "2017-07-27T14:27:46.051158",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "oh, supers needs the class, but that’s easy enough"
  },
  {
    "timestamp": "2017-07-27T14:28:04.062736",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "```=> (supers (class {})) #{clojure.lang.IKVReduce clojure.lang.IFn clojure.lang.IMapIterable java.io.Serializable java.lang.Object clojure.lang.IObj clojure.lang.IMeta java.lang.Runnable clojure.lang.MapEquivalence clojure.lang.IHashEq clojure.lang.ILookup clojure.lang.IPersistentMap clojure.lang.Counted clojure.lang.IEditableCollection clojure.lang.Associative java.lang.Iterable clojure.lang.IPersistentCollection clojure.lang.AFn java.util.Map java.util.concurrent.Callable clojure.lang.Seqable clojure.lang.APersistentMap}```"
  },
  {
    "timestamp": "2017-07-27T14:28:06.063477",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "``` wef-backend.core=> (supers (type (get-conn))) #{#<Class@35fc6dc4 java.lang.Object> #<Class@e7b265e clojure.lang.IType> #<Class@6b337969 datomic.Connection>} ```"
  },
  {
    "timestamp": "2017-07-27T14:28:33.079950",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "cool - so you can make a defrecord that implements Connection - the others come free with defrecord"
  },
  {
    "timestamp": "2017-07-27T14:28:44.086621",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "is Connection a protocol there?"
  },
  {
    "timestamp": "2017-07-27T14:29:00.097001",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "this is the point where I end up reading source code usually, heh"
  },
  {
    "timestamp": "2017-07-27T14:29:10.103094",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "I bet it’s documented … somewhere"
  },
  {
    "timestamp": "2017-07-27T14:29:25.112717",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I’ll look into it. Thanks :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-27T14:31:19.183640",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<https://gist.github.com/robert-stuttaford/39d43c011e498542bcf8>"
  },
  {
    "timestamp": "2017-07-27T14:31:33.192726",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I’ll ask <@Delana> , I am sure he has insights on this"
  },
  {
    "timestamp": "2017-07-27T14:33:12.253656",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "cool - thanks for asking about this, I learned a couple of things in trying to find your answer"
  },
  {
    "timestamp": "2017-07-27T14:33:41.271726",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> Glad to hear that! I was afraid I wasted a bit too much of your time"
  },
  {
    "timestamp": "2017-07-27T14:34:44.310915",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<https://blog.clubhouse.io/auditing-with-reified-transactions-in-datomic-f1ea30610285>"
  },
  {
    "timestamp": "2017-07-27T14:34:58.319194",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "In this article they wrap d/transact, as you were suggesting"
  },
  {
    "timestamp": "2017-07-27T14:36:30.375379",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "well - they do it slightly differently than I suggested, because the user-id org-id and tx-data are totally hidden once you call defn"
  },
  {
    "timestamp": "2017-07-27T14:36:41.381896",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "err, I mean once you call transact-wrapper"
  },
  {
    "timestamp": "2017-07-27T14:36:53.389359",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the return value of that function doesn’t expose any of those things as data"
  },
  {
    "timestamp": "2017-07-27T14:36:56.390805",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> do you think that’s an issue? it seems to simplify the life of the caller, especially if he doesn’t care about those"
  },
  {
    "timestamp": "2017-07-27T14:37:22.406008",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "cluttering every function that calls transact with auth data that it doesn’t care about sounds problematic"
  },
  {
    "timestamp": "2017-07-27T14:37:50.422248",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "<@Lucio> until you are trying to debug code using the wrapper (in my experience) - it’s not always neccessary to use the alternative of using a record to store the data instead of a closure, but what this gains is quick access to what the thing actually encompases"
  },
  {
    "timestamp": "2017-07-27T14:38:47.455706",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "you don’t clutter - the record itself is something you can call if you implement IFn - or you just expect people to use a protocol method with it as the first arg (also fairly reasonable but less fancy)"
  },
  {
    "timestamp": "2017-07-27T14:39:15.472783",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> sorry, I think I am missing something. Can you give me a code example of what you mean?"
  },
  {
    "timestamp": "2017-07-27T14:39:26.479218",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "hmm"
  },
  {
    "timestamp": "2017-07-27T14:39:37.485454",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Just a quick snippet here on Slack"
  },
  {
    "timestamp": "2017-07-27T14:40:32.518233",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "OK - I was just looking at this right now, sorry about the distracting details, but the big picture structure should be illustrative of what I am saying ```(defrecord Transmitter [transmit from user-data creator to journey routing] IFn (call [this] (.invoke this [nil this])) (run [this] (.invoke this [nil this])) (applyTo [this coll] (.invoke this (first coll))) (invoke [this [routing-override message]] (let [updated (into this message) routing (or routing-override routing (first journey))] (.invoke this routing updated))) (invoke [_ routing-override message] (let [{:keys [transmit generic]} message message (dissoc message :transmit :generic :routing :from :to) {:keys [journey routing message]} (if generic {:journey [routing-override] :routing :generic/reply :message (assoc message :generic-raw [routing-override message])} {:journey (rest journey) :routing routing-override :message message}) {:keys [request-id birth-time]} user-data final-message (assoc message :journey journey :mediary to)] (when-let [schema-error (check-schema from routing final-message)] (log/error ::Transmitter \"for routing\" (pr-str routing) (pr-str {:journey journey}) (pr-str schema-error))) (log/trace ::simple-kafka-transmit routing \"to\" request-id \"from\" birth-time \"-\" (pull-transmit-info message)) (transmit from routing final-message))))```"
  },
  {
    "timestamp": "2017-07-27T14:41:27.550609",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the transmitter has all this incidental data - who is sending? who is the target? what data did the initiator of the request expect to get back with any responses? what is the path the overall task should take through the system?"
  },
  {
    "timestamp": "2017-07-27T14:41:37.556778",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "But that’s basically the approach I was suggesting with a “DatomicWriter” protocol, no?"
  },
  {
    "timestamp": "2017-07-27T14:41:37.556813",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "v1 wrapped this in calls to partial"
  },
  {
    "timestamp": "2017-07-27T14:41:42.559447",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "that “wraps’ transact"
  },
  {
    "timestamp": "2017-07-27T14:42:01.571162",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "the difference is that this returns an object that acts like a function"
  },
  {
    "timestamp": "2017-07-27T14:42:42.595498",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "maybe I misunderstaood what `@(d/transact ...)` is in the transact-wrapper function"
  },
  {
    "timestamp": "2017-07-27T14:42:46.598359",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "right, but so instead of doing something like ``` (transact transmitter conn tx-data) ``` you would do ``` (transmitter conn tx-data) ```"
  },
  {
    "timestamp": "2017-07-27T14:43:05.609691",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "right"
  },
  {
    "timestamp": "2017-07-27T14:43:11.613215",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> (d/transact returns a promise I think, and @ dereferences it"
  },
  {
    "timestamp": "2017-07-27T14:43:29.623978",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "and if you look at transmitter it shows you all the data it has inside"
  },
  {
    "timestamp": "2017-07-27T14:43:33.626046",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "it acts like a hash-map"
  },
  {
    "timestamp": "2017-07-27T14:43:36.627775",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "that’s the key thing to me"
  },
  {
    "timestamp": "2017-07-27T14:43:36.627818",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<http://docs.datomic.com/clojure/#datomic.api/transact>"
  },
  {
    "timestamp": "2017-07-27T14:43:58.640858",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "OK"
  },
  {
    "timestamp": "2017-07-27T14:44:12.649508",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Ok I see"
  },
  {
    "timestamp": "2017-07-27T14:44:20.654436",
    "conversation_id": 480,
    "user": "Delana",
    "message": "what was the question :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-07-27T14:44:38.664956",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Delana> Hi! 76 messages to read :smile:"
  },
  {
    "timestamp": "2017-07-27T14:44:48.670815",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "just kidding, let me clarify the question:"
  },
  {
    "timestamp": "2017-07-27T14:44:48.670821",
    "conversation_id": 480,
    "user": "Delana",
    "message": "lol"
  },
  {
    "timestamp": "2017-07-27T14:45:28.693846",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I want to add some attributes to every transaction in my sytem (e.g. for audit purposes; things like the current user ID) and I am wondering how I should do it"
  },
  {
    "timestamp": "2017-07-27T14:45:52.708169",
    "conversation_id": 480,
    "user": "Margaret",
    "message": "your question suddenly sounds very focused and pragmatic"
  },
  {
    "timestamp": "2017-07-27T14:45:53.708817",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "e.g. should I wrap all access to Datomic behind a protocol that proxies most calls but does some stuff to transact’s tx-data before proxying"
  },
  {
    "timestamp": "2017-07-27T14:46:06.716333",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "should I have an explicit function wrapping d/transact"
  },
  {
    "timestamp": "2017-07-27T14:46:07.716808",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "etc"
  },
  {
    "timestamp": "2017-07-27T14:46:16.722283",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Margaret> sorry :smile:"
  },
  {
    "timestamp": "2017-07-27T14:46:28.729344",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I guess that’s what talking about something for 80 messages does"
  },
  {
    "timestamp": "2017-07-27T14:46:30.730517",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "it clarifies things"
  },
  {
    "timestamp": "2017-07-27T14:46:30.730654",
    "conversation_id": 480,
    "user": "Delana",
    "message": "we use an explicit function wrapping d/transact and d/transact-async"
  },
  {
    "timestamp": "2017-07-27T14:47:21.760835",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Delana> do you pass the auth context to all your “business functions” and then pass it explicitly to your function wrapping d/transact every time you call it?"
  },
  {
    "timestamp": "2017-07-27T14:48:05.786783",
    "conversation_id": 480,
    "user": "Delana",
    "message": "no; we use middleware and `binding` with a dynamic var"
  },
  {
    "timestamp": "2017-07-27T14:48:11.790398",
    "conversation_id": 480,
    "user": "Delana",
    "message": "and if the var has a value, we annotate"
  },
  {
    "timestamp": "2017-07-27T14:48:24.798412",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I was told using dynamic vars will send me straight to hell"
  },
  {
    "timestamp": "2017-07-27T14:48:42.809137",
    "conversation_id": 480,
    "user": "Delana",
    "message": "we have repl helpers that do the binding so that we also use it when manually altering the db at the repl"
  },
  {
    "timestamp": "2017-07-27T14:48:56.817528",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "do you somehow ensure that no intern misadvertantly uses d/transact instead of your wrapper?"
  },
  {
    "timestamp": "2017-07-27T14:49:47.847976",
    "conversation_id": 480,
    "user": "Delana",
    "message": "no. but in 5 years, it’s not been a problem. we had ONE case where someone retracted more than they should have. it was easy to fix"
  },
  {
    "timestamp": "2017-07-27T14:50:01.856404",
    "conversation_id": 480,
    "user": "Delana",
    "message": "i do live i fear of an accidental d/delete-database though"
  },
  {
    "timestamp": "2017-07-27T14:50:09.861176",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "Ok, thanks a lot. One other thing: how do you handle security? Specifically, do you use d/filter?"
  },
  {
    "timestamp": "2017-07-27T14:50:26.871608",
    "conversation_id": 480,
    "user": "Delana",
    "message": "we can’t use d/filter ; we have too much sharing going on"
  },
  {
    "timestamp": "2017-07-27T14:50:30.873949",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "yeah, it’s a bit odd there is no way to prevent /delete-database tbh"
  },
  {
    "timestamp": "2017-07-27T14:50:40.879586",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I guess with backups every 24 hours it eases the fear"
  },
  {
    "timestamp": "2017-07-27T14:50:46.883631",
    "conversation_id": 480,
    "user": "Delana",
    "message": "d/filter is nice if you have very strict boxes. we don’t."
  },
  {
    "timestamp": "2017-07-27T14:50:54.887894",
    "conversation_id": 480,
    "user": "Delana",
    "message": "hah. try continuously"
  },
  {
    "timestamp": "2017-07-27T14:50:55.888839",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "although I wonder what would happen if the db got deleted, re-created, then a backup was run"
  },
  {
    "timestamp": "2017-07-27T14:51:01.892343",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "would it get rid of the incremental backup?"
  },
  {
    "timestamp": "2017-07-27T14:51:19.903261",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "how do you do access control them? do you have a nice approach?"
  },
  {
    "timestamp": "2017-07-27T14:51:55.924837",
    "conversation_id": 480,
    "user": "Delana",
    "message": "we replicate our backups to off-AWS places, so we have some protection against that"
  },
  {
    "timestamp": "2017-07-27T14:52:06.931376",
    "conversation_id": 480,
    "user": "Delana",
    "message": "access control what, the backups, or the repl access?"
  },
  {
    "timestamp": "2017-07-27T14:52:42.952897",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "data access control"
  },
  {
    "timestamp": "2017-07-27T14:52:52.958848",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "e.g. which users can see what"
  },
  {
    "timestamp": "2017-07-27T14:52:55.960425",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "enforcing it"
  },
  {
    "timestamp": "2017-07-27T14:53:09.968578",
    "conversation_id": 480,
    "user": "Delana",
    "message": "oh, that’s basically normal queries in middleware"
  },
  {
    "timestamp": "2017-07-27T14:55:32.054943",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Delana> middleware as in you filter the query after executing it?"
  },
  {
    "timestamp": "2017-07-27T14:56:09.076804",
    "conversation_id": 480,
    "user": "Delana",
    "message": "no, simpler than that - we explicitly use the viewing user in queries"
  },
  {
    "timestamp": "2017-07-27T14:57:11.114909",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "oh right."
  },
  {
    "timestamp": "2017-07-27T14:57:14.117081",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "what about the entity API?"
  },
  {
    "timestamp": "2017-07-27T14:59:43.207442",
    "conversation_id": 480,
    "user": "Delana",
    "message": "very often we use datalog to find valid entities, map d/entity, and go from there"
  },
  {
    "timestamp": "2017-07-27T15:00:01.218510",
    "conversation_id": 480,
    "user": "Delana",
    "message": "sometimes we d/entity on a lookup ref, query to validate access, and continue"
  },
  {
    "timestamp": "2017-07-27T15:01:56.290092",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "right, what I mean is that d/entity will let you traverse the data tree without access control"
  },
  {
    "timestamp": "2017-07-27T15:02:06.295625",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "but I assume so long as you control what is traversed, it’s fine"
  },
  {
    "timestamp": "2017-07-27T15:02:25.306618",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "I am using GraphQL on my app and d/entity could cause issues if I tried to use it directly"
  },
  {
    "timestamp": "2017-07-27T15:02:35.312650",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "and let the graphql query resolvers hit it directly"
  },
  {
    "timestamp": "2017-07-27T15:02:55.323972",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "as it could potentially go any level deep in the data tree, reaching data that should not be accessible to the current user"
  },
  {
    "timestamp": "2017-07-27T15:02:57.325390",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "if that makes any sense"
  },
  {
    "timestamp": "2017-07-27T15:03:58.360150",
    "conversation_id": 480,
    "user": "Delana",
    "message": "oh right, yes. we totally control the query. we don’t allow arbitrary query from clientside"
  },
  {
    "timestamp": "2017-07-27T15:04:16.370471",
    "conversation_id": 480,
    "user": "Delana",
    "message": "in that case, d/filter is a far safer approach"
  },
  {
    "timestamp": "2017-07-27T15:04:48.389024",
    "conversation_id": 480,
    "user": "Lucio",
    "message": "<@Delana> ok, thanks. Sorry, my questions are not very clear today"
  },
  {
    "timestamp": "2017-07-27T15:05:01.396212",
    "conversation_id": 480,
    "user": "Delana",
    "message": "it’s ok :slightly_smiling_face: hth"
  },
  {
    "timestamp": "2017-09-19T13:46:34.000519",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "I'm quite confused about this example...I have one function that appears to return a long, yet when I call `inc` (or any other numerical function) on it the compiler tells me it's an Object: <https://gist.github.com/Sophia-Gold/6e0abe5080b4db078220031ff3c95d6d> What am I missing here?"
  },
  {
    "timestamp": "2017-09-19T13:50:20.000531",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "by default the params and return vals of all functions are of type Object"
  },
  {
    "timestamp": "2017-09-19T13:50:36.000682",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "you’ll need to type hint the return to get something different"
  },
  {
    "timestamp": "2017-09-19T13:50:44.000714",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "`(defn foo ^long [String string] ...)`"
  },
  {
    "timestamp": "2017-09-19T13:51:14.000566",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "Ah, that's a simple answer. Thanks, Alex."
  },
  {
    "timestamp": "2017-09-19T13:51:54.000075",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "the inner loop of `foo` will used boxed longs as written now, but that could be rewritten with loop/recur to use primitive longs"
  },
  {
    "timestamp": "2017-09-19T13:52:55.000279",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "`type` will also always box the object so it will never return a primitive type"
  },
  {
    "timestamp": "2017-09-19T13:53:05.000210",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "Oh, interesting. I always default to thinking `reduce` would be more performant through using the Iterator interface."
  },
  {
    "timestamp": "2017-09-19T13:53:14.000289",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "<@Kareen>, that's not true"
  },
  {
    "timestamp": "2017-09-19T13:53:21.000380",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "it is"
  },
  {
    "timestamp": "2017-09-19T13:53:31.000182",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "i'm talking about Long vs long"
  },
  {
    "timestamp": "2017-09-19T13:54:04.000676",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "You can see in this example that it returns a Java long. What am I misunderstanding?"
  },
  {
    "timestamp": "2017-09-19T13:54:35.000776",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "primitive means a primitive `long` type, `java.lang.Long` is a boxed object, that's the distinction i was making"
  },
  {
    "timestamp": "2017-09-19T13:54:58.000300",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "I think you mean Clojure long vs. Java long..."
  },
  {
    "timestamp": "2017-09-19T13:55:19.000620",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "no"
  },
  {
    "timestamp": "2017-09-19T13:55:27.000902",
    "conversation_id": 675,
    "user": "Willow",
    "message": "``` ;; => (type (foo \"baz\")) ;; => java.lang.Long ```"
  },
  {
    "timestamp": "2017-09-19T13:55:34.000162",
    "conversation_id": 675,
    "user": "Willow",
    "message": "notice the capital L in your output"
  },
  {
    "timestamp": "2017-09-19T13:55:55.000010",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "The capital L refers to a boxed long?"
  },
  {
    "timestamp": "2017-09-19T13:55:57.000276",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "there's no such thing as a clojure long"
  },
  {
    "timestamp": "2017-09-19T13:57:08.000048",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "<@Kareen> sorry, you're right about that. I for some reason thought there was clojure.lang.long"
  },
  {
    "timestamp": "2017-09-19T13:58:31.000115",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "the jvm has a primitive `long` type (which is not an object type) and a boxed class `java.lang.Long`, `type` will never return `long` even if a function returns a primitive long, because `type` only works on objects and thus will cause a primitive value to be boxed"
  },
  {
    "timestamp": "2017-09-19T13:59:14.000532",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "Gotcha. And I assume `class` and `instance?` are the same?"
  },
  {
    "timestamp": "2017-09-19T13:59:19.000367",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "yes"
  },
  {
    "timestamp": "2017-09-19T13:59:24.000253",
    "conversation_id": 675,
    "user": "Silas",
    "message": "If type can't give you the correct type of primitives, is there anything that can?"
  },
  {
    "timestamp": "2017-09-19T13:59:46.000437",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "no"
  },
  {
    "timestamp": "2017-09-19T13:59:54.000654",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "well"
  },
  {
    "timestamp": "2017-09-19T14:00:02.000101",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "Well, `:warn-on-boxed` will."
  },
  {
    "timestamp": "2017-09-19T14:00:09.000109",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "it would have to be a macro that interopped with the compiler, or a compiler feature"
  },
  {
    "timestamp": "2017-09-19T14:00:40.000222",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "That's a compiler feature, though."
  },
  {
    "timestamp": "2017-09-19T14:00:54.000414",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "no function can because it would have to accept both objects and primitive values, and the clojure compiler would cause values to be either boxed or unboxed as it deems appropriate, so not retaining the real type"
  },
  {
    "timestamp": "2017-09-19T14:01:10.000073",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "<@Jerold> yeah, but it doesn't do what <@Silas> was asking"
  },
  {
    "timestamp": "2017-09-19T14:01:18.000764",
    "conversation_id": 675,
    "user": "Silas",
    "message": "A little annoying when you want to validate you're not using boxing"
  },
  {
    "timestamp": "2017-09-19T14:01:32.000561",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "if that's all that you care about than as <@Jerold> said, `warn-on-boxed`/`warn-on-reflection`"
  },
  {
    "timestamp": "2017-09-19T14:01:33.000198",
    "conversation_id": 675,
    "user": "Margaret",
    "message": "<@Jerold> ~what are you calling a compiler feature?~ I get it now, never mind"
  },
  {
    "timestamp": "2017-09-19T14:01:40.000710",
    "conversation_id": 675,
    "user": "Jerold",
    "message": "<@Silas> `(set! *unchecked-math* :warn-on-boxed)`"
  },
  {
    "timestamp": "2017-09-19T14:01:54.000232",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Ya, I guess."
  },
  {
    "timestamp": "2017-09-19T14:02:42.000741",
    "conversation_id": 675,
    "user": "Silas",
    "message": "And whats with this: ```(defn ^long foo [x] (int x)) (type (foo 12)) => java.lang.Integer ``` ?"
  },
  {
    "timestamp": "2017-09-19T14:02:57.000462",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "that's not ac correct type hint"
  },
  {
    "timestamp": "2017-09-19T14:03:03.000164",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "move it from foo to the argvec"
  },
  {
    "timestamp": "2017-09-19T14:03:14.000344",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "`(defn foo ^long [..`"
  },
  {
    "timestamp": "2017-09-19T14:04:01.000341",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Damn, all this time, using the wrong syntax lol"
  },
  {
    "timestamp": "2017-09-19T14:04:12.000190",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "it's only wrong for primitive type hints"
  },
  {
    "timestamp": "2017-09-19T14:04:30.000915",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "but I suggest using it even for non primitive type hints"
  },
  {
    "timestamp": "2017-09-19T14:05:02.000283",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Primitive type hints have a different syntax?"
  },
  {
    "timestamp": "2017-09-19T14:05:06.000364",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "no"
  },
  {
    "timestamp": "2017-09-19T14:05:18.000258",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "both primitive and non primitive can work in either place"
  },
  {
    "timestamp": "2017-09-19T14:05:46.000626",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "but because the metadata on var names will get evaluated, you'd have to `(defn ^{:tag 'long} foo ..` (i.e. explicitly quoting it)"
  },
  {
    "timestamp": "2017-09-19T14:06:18.000585",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "otherwise you're tagging foo with the value of the `long` function rather than with the `long` symbol"
  },
  {
    "timestamp": "2017-09-19T14:06:22.000264",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "var meta is evaluated. Function type hints are not."
  },
  {
    "timestamp": "2017-09-19T14:06:47.000427",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "moreover, the compiler will not emit primitive versions of the function if you tag the var meta rather than the argvec"
  },
  {
    "timestamp": "2017-09-19T14:07:24.000432",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "I think the takeaway is that you should nearly always type hint the function return, not the var"
  },
  {
    "timestamp": "2017-09-19T14:07:30.000300",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "<@Sonny> sorry i''m not understanding, are you saying what I've said is wrong? because it isn't :)"
  },
  {
    "timestamp": "2017-09-19T14:07:35.000125",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "yep"
  },
  {
    "timestamp": "2017-09-19T14:07:39.000390",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "s/nearly// IMO"
  },
  {
    "timestamp": "2017-09-19T14:07:40.000267",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "no, I’m trying to agree with you :)"
  },
  {
    "timestamp": "2017-09-19T14:07:42.000571",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "ah ok"
  },
  {
    "timestamp": "2017-09-19T14:07:57.000172",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "misunderstood what you meant by \"function type hints\" then"
  },
  {
    "timestamp": "2017-09-19T14:08:11.000359",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Hum, so would the resulting cast be around the var access instead of the function return?"
  },
  {
    "timestamp": "2017-09-19T14:08:12.000306",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "I meant “the type hints interpreted by defn”"
  },
  {
    "timestamp": "2017-09-19T14:08:17.000799",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "yep gotcha"
  },
  {
    "timestamp": "2017-09-19T14:08:56.000339",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "<@Silas> yeah"
  },
  {
    "timestamp": "2017-09-19T14:09:28.000007",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Actually, I'm definitly a bit confused about type hints. I've noticed somtimes you can type hint wrongly, and all works, no warnings or errors, sometimes you get runtime type errors."
  },
  {
    "timestamp": "2017-09-19T14:09:30.000083",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "what happens in `(defn ^{:tag 'long} foo ..)` case is that foo returns an Object and at callsite it *might* get unboxed as a long, if the compiler deems it useful/necessary"
  },
  {
    "timestamp": "2017-09-19T14:10:55.000212",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "<@Silas> yeah, this (afaict) is because of clojure's GIGO attitude. I don't particularly like it in this case (I think we could safely warn at compiler time) but it's gotten a bit better than it used to be"
  },
  {
    "timestamp": "2017-09-19T14:11:36.000334",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "it’s not GIGO, it’s because it’s a hint, and the hint might be wrong"
  },
  {
    "timestamp": "2017-09-19T14:11:58.000616",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "you might not know it’s wrong till runtime"
  },
  {
    "timestamp": "2017-09-19T14:12:02.000493",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "I'd consider it GIGO when the type hint *can't* ever be right, not to warn"
  },
  {
    "timestamp": "2017-09-19T14:12:09.000008",
    "conversation_id": 675,
    "user": "Silas",
    "message": "So does a wrong hint detected by the compiler reverts it back to using reflection?"
  },
  {
    "timestamp": "2017-09-19T14:12:10.000160",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "so you can fall back to Object"
  },
  {
    "timestamp": "2017-09-19T14:12:14.000795",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "yes"
  },
  {
    "timestamp": "2017-09-19T14:12:21.000206",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "well, if something is definitely not a type/class at compile time then it's not a *type* hint"
  },
  {
    "timestamp": "2017-09-19T14:12:31.000354",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "well that I agree with"
  },
  {
    "timestamp": "2017-09-19T14:12:42.000660",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "I can't see how the compiler accepting a funcntion as at type hint w/o warning/erroring out is not GIGO"
  },
  {
    "timestamp": "2017-09-19T14:12:56.000104",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "I’m in full support of that being an error"
  },
  {
    "timestamp": "2017-09-19T14:13:11.000094",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "(gah, I can't write function anymore apparently, fifth time I write funcntion)"
  },
  {
    "timestamp": "2017-09-19T14:13:17.000452",
    "conversation_id": 675,
    "user": "Silas",
    "message": "```(defn foo ^String [x] (int x))``` This still works, no warning or error."
  },
  {
    "timestamp": "2017-09-19T14:13:26.000504",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "patch incoming then :)"
  },
  {
    "timestamp": "2017-09-19T14:13:39.000043",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "that is not the case I'm arguing should warn"
  },
  {
    "timestamp": "2017-09-19T14:13:47.000122",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "that is a validly formed type hint, it's just a nonsensical one"
  },
  {
    "timestamp": "2017-09-19T14:14:06.000240",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "what if `int` got redefed to return a string"
  },
  {
    "timestamp": "2017-09-19T14:14:20.000358",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "then that hint would be correct at some point"
  },
  {
    "timestamp": "2017-09-19T14:14:20.000633",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "it’s the `(defn ^long foo ...)` one"
  },
  {
    "timestamp": "2017-09-19T14:14:27.000186",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "^"
  },
  {
    "timestamp": "2017-09-19T14:14:30.000028",
    "conversation_id": 675,
    "user": "Margaret",
    "message": "it’s more like `(defn foo ^clojure.string/join [x] (int x))` - the hint is a function not a type"
  },
  {
    "timestamp": "2017-09-19T14:14:59.000182",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Right, well ya, that I agree should even more so be warned or even error"
  },
  {
    "timestamp": "2017-09-19T14:16:02.000363",
    "conversation_id": 675,
    "user": "Silas",
    "message": "But, about the other one, I understand maybe it compiling, but why does it work once its compiled to jvm byte code?"
  },
  {
    "timestamp": "2017-09-19T14:16:27.000004",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "depends on your definition of working!"
  },
  {
    "timestamp": "2017-09-19T14:16:36.000129",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "once you start doing interop, the compiler will assume that type hint to be correct"
  },
  {
    "timestamp": "2017-09-19T14:16:45.000173",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "and will dispatch to String methods"
  },
  {
    "timestamp": "2017-09-19T14:16:56.000102",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "if it can't match one, it will use reflection"
  },
  {
    "timestamp": "2017-09-19T14:17:01.000190",
    "conversation_id": 675,
    "user": "Sonny",
    "message": "<@Kareen> patch welcome for <https://dev.clojure.org/jira/browse/CLJ-1674> or whatever other jira is out there for this problem"
  },
  {
    "timestamp": "2017-09-19T14:17:09.000409",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "but if, say, Integer and String had 2 methods with identical signatures, than that would fail at runtime"
  },
  {
    "timestamp": "2017-09-19T14:17:24.000360",
    "conversation_id": 675,
    "user": "Silas",
    "message": "I mean, in java you can't type the return to string and have it return int. So does clojure ignore the hint amd still returns Object?"
  },
  {
    "timestamp": "2017-09-19T14:17:53.000550",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "type hints are not static types"
  },
  {
    "timestamp": "2017-09-19T14:18:18.000191",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "the compiler enforces type hints only if/when it needs to"
  },
  {
    "timestamp": "2017-09-19T14:18:37.000515",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "and for function return types, it only enforces them when that value is used in an interop form"
  },
  {
    "timestamp": "2017-09-19T14:19:04.000187",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "e.g. `(.foo (bar))` will enforce the type hint on the return type of `bar` (at callsite of `foo`!) but `(identity (bar))` won't"
  },
  {
    "timestamp": "2017-09-19T14:19:07.000645",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "because it would be useless"
  },
  {
    "timestamp": "2017-09-19T14:20:27.000015",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "type hints are only to prevent reflection (and in some cases, boxing), they're not to *enforce* static types"
  },
  {
    "timestamp": "2017-09-19T14:20:49.000141",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "and are not guaranteed to cast/box/unbox"
  },
  {
    "timestamp": "2017-09-19T14:21:13.000324",
    "conversation_id": 675,
    "user": "Silas",
    "message": "I see, okay, that explains I think the inconsistency of wrongly typed type hints I've seen. It'll fail at runtime with java interop."
  },
  {
    "timestamp": "2017-09-19T14:21:21.000062",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "yes"
  },
  {
    "timestamp": "2017-09-19T14:22:17.000321",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "an example of this behaviour is ```user=> (deftype Foo [a]) user.Foo user=> (deftype Bar [a]) user.Bar user=> (defn ^Foo x [] (Bar. 1)) #'user/x user=> (x) #object[user.Bar 0x4983159f \"user.Bar@4983159f\"] user=> (.a (x)) ClassCastException user.Bar cannot be cast to user.Foo user/eval158 (NO_SOURCE_FILE:8) ```"
  },
  {
    "timestamp": "2017-09-19T14:22:58.000209",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Right"
  },
  {
    "timestamp": "2017-09-19T14:22:59.000070",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "the incorrect type hint doesn't cause (x) to fail, it causes host interop on (x) to fail"
  },
  {
    "timestamp": "2017-09-19T14:24:17.000119",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Whats the idea of not enforcing the hint to always box/unbox or cast ? I don't see a negative in enforcing, except you'd know quicker that you hinted it wrong"
  },
  {
    "timestamp": "2017-09-19T14:25:24.000187",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "well, the short answer is: type hints are not type assertions, the long(er) answer is: the compiler might now better or enforcing could affect redefinition"
  },
  {
    "timestamp": "2017-09-19T14:26:02.000226",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "and if you want enforcing I guess spec is better suited at that"
  },
  {
    "timestamp": "2017-09-19T14:27:30.000353",
    "conversation_id": 675,
    "user": "Silas",
    "message": "```(defn foo ^String [x] (int x)) (type (foo 12))``` Id expect this to be equal to ```Object foo(Object x) { return (String)((int) x); }``` and fail at the cast at runtime"
  },
  {
    "timestamp": "2017-09-19T14:28:08.000438",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "no, again, type hints are neither type assertions nor type casts"
  },
  {
    "timestamp": "2017-09-19T14:28:42.000016",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "they sometimes act like either, but at the discretion of the compiler"
  },
  {
    "timestamp": "2017-09-19T14:29:14.000003",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "to do what you want, use `(cast String (int x))`"
  },
  {
    "timestamp": "2017-09-19T14:30:16.000073",
    "conversation_id": 675,
    "user": "Silas",
    "message": "I'm not talking static checks. But runtime type errors. Ok, ya I understand, so they're unpredictable and mostly for interop and certain unboxing situation."
  },
  {
    "timestamp": "2017-09-19T14:31:32.000634",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "as to enforcing at return type vs callsite -- I believe it's a performance compromise of sorts"
  },
  {
    "timestamp": "2017-09-19T14:31:47.000067",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "to enforce at return type would require emitting checkcasts at every callsite"
  },
  {
    "timestamp": "2017-09-19T14:31:49.000474",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "vs only when needed"
  },
  {
    "timestamp": "2017-09-19T14:33:27.000211",
    "conversation_id": 675,
    "user": "Silas",
    "message": "I understand how they work now. Thank you."
  },
  {
    "timestamp": "2017-09-19T14:33:32.000466",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "np"
  },
  {
    "timestamp": "2017-09-19T14:35:08.000081",
    "conversation_id": 675,
    "user": "Silas",
    "message": "I guess I'll restrict their usage to only when the compiler warns for boxing or needs it to dispatch."
  },
  {
    "timestamp": "2017-09-19T14:35:18.000331",
    "conversation_id": 675,
    "user": "Kareen",
    "message": "that is when you should be using them, yes"
  },
  {
    "timestamp": "2017-09-19T14:36:29.000402",
    "conversation_id": 675,
    "user": "Silas",
    "message": "Some people use them as programmer hints, like documentation. But that had mislead me, because sometimes the hint is wrong, yet all works. I see that's a pretty bad use of them now. Spec is the way to go."
  },
  {
    "timestamp": "2017-09-22T11:56:27.000183",
    "conversation_id": 731,
    "user": "Mia",
    "message": "anyone know why when starting my app with `lein run` I am getting dozens, maybe hundreds of java processes spinning up?"
  },
  {
    "timestamp": "2017-09-22T11:56:46.000514",
    "conversation_id": 731,
    "user": "Mia",
    "message": "this seemed to have started ever since iTerm shut down when my app was still running"
  },
  {
    "timestamp": "2017-09-22T11:56:56.000158",
    "conversation_id": 731,
    "user": "Mia",
    "message": "I’ve reinstalled leiningen and java"
  },
  {
    "timestamp": "2017-09-22T11:57:00.000203",
    "conversation_id": 731,
    "user": "Mia",
    "message": "and still happens"
  },
  {
    "timestamp": "2017-09-22T11:58:58.000483",
    "conversation_id": 731,
    "user": "Mia",
    "message": "and there are tons more of those same processes"
  },
  {
    "timestamp": "2017-09-22T11:59:21.000183",
    "conversation_id": 731,
    "user": "Jayne",
    "message": "both sinppets are useful"
  },
  {
    "timestamp": "2017-09-22T12:12:04.000513",
    "conversation_id": 731,
    "user": "Myles",
    "message": "<@Mia> maybe I'm missing something, but why would you expect there would be dozens or hundreds of processes?"
  },
  {
    "timestamp": "2017-09-22T12:14:10.000338",
    "conversation_id": 731,
    "user": "Mia",
    "message": "I wouldn’t expect there to be, but there are"
  },
  {
    "timestamp": "2017-09-22T12:14:22.000247",
    "conversation_id": 731,
    "user": "Mia",
    "message": "I have no idea why they’re starting"
  },
  {
    "timestamp": "2017-09-22T12:15:05.000390",
    "conversation_id": 731,
    "user": "Mia",
    "message": "ah, I see. typo"
  },
  {
    "timestamp": "2017-09-22T12:15:27.000692",
    "conversation_id": 731,
    "user": "Detra",
    "message": "Next time it happens, I'll see what I can figure out."
  },
  {
    "timestamp": "2017-09-22T12:17:32.000122",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "<@Mia> are you using core.async? are you using an http server that uses a thread pool?"
  },
  {
    "timestamp": "2017-09-22T12:17:44.000384",
    "conversation_id": 731,
    "user": "Mia",
    "message": "using immutant"
  },
  {
    "timestamp": "2017-09-22T12:17:46.000467",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "sometimes a process manager gets confused and shows all your threads as if they were seperate processes"
  },
  {
    "timestamp": "2017-09-22T12:17:56.000283",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "yes, I'd expect immutant to start a large number of threads"
  },
  {
    "timestamp": "2017-09-22T12:18:02.000210",
    "conversation_id": 731,
    "user": "Mia",
    "message": "nah, it’s bringing my computer to a halt"
  },
  {
    "timestamp": "2017-09-22T12:18:18.000224",
    "conversation_id": 731,
    "user": "Mia",
    "message": "this is new, though"
  },
  {
    "timestamp": "2017-09-22T12:18:31.000637",
    "conversation_id": 731,
    "user": "Mia",
    "message": "‘new’ as in, it just started happening"
  },
  {
    "timestamp": "2017-09-22T12:18:42.000247",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "<@Mia> when it's doing that, hit `Control-\\` to make it show all stack traces, then upload it so we can see it"
  },
  {
    "timestamp": "2017-09-22T12:19:21.000592",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "or if you prefer, run jstack with the pid of the process (same output)"
  },
  {
    "timestamp": "2017-09-22T12:21:02.000230",
    "conversation_id": 731,
    "user": "Mia",
    "message": "even running `lein ancient` starts up a ton of java processes"
  },
  {
    "timestamp": "2017-09-22T12:21:43.000357",
    "conversation_id": 731,
    "user": "Myles",
    "message": "what if you just run `lein`"
  },
  {
    "timestamp": "2017-09-22T12:22:12.000536",
    "conversation_id": 731,
    "user": "Myles",
    "message": "any new lein plugins or anything?"
  },
  {
    "timestamp": "2017-09-22T12:23:15.000342",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "<@Mia> you can execute the c-\\ shortcut or jstack to see what it's doing, even when it's just lein running, the stack traces will show what code is actaully doing it"
  },
  {
    "timestamp": "2017-09-22T12:24:08.000662",
    "conversation_id": 731,
    "user": "Mia",
    "message": "let me check"
  },
  {
    "timestamp": "2017-09-22T12:24:56.000354",
    "conversation_id": 731,
    "user": "Mia",
    "message": "sorry I’m slow. I have to reboot when these processes start up since it brings my computer to a halt. And I have to quickly uninstall leiningen and java before “too many open files in system”"
  },
  {
    "timestamp": "2017-09-22T12:24:58.000453",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "(of course with that many threads it will be a lot of output)"
  },
  {
    "timestamp": "2017-09-22T12:26:26.000317",
    "conversation_id": 731,
    "user": "Mia",
    "message": "<@Myles> yup, just `lein` does the same thing"
  },
  {
    "timestamp": "2017-09-22T12:26:57.000632",
    "conversation_id": 731,
    "user": "Mia",
    "message": "although, let me try outside of my project"
  },
  {
    "timestamp": "2017-09-22T12:28:56.000375",
    "conversation_id": 731,
    "user": "Mia",
    "message": "it’s OK if I’m outside of my project"
  },
  {
    "timestamp": "2017-09-22T12:29:06.000374",
    "conversation_id": 731,
    "user": "Mia",
    "message": "let me try from within a barebones project"
  },
  {
    "timestamp": "2017-09-22T12:30:08.000345",
    "conversation_id": 731,
    "user": "Mia",
    "message": "OK in new project"
  },
  {
    "timestamp": "2017-09-22T12:40:16.000084",
    "conversation_id": 731,
    "user": "Mia",
    "message": "this looks odd `501 19553 402 0 10:37AM ?? 0:00.01 /bin/bash /usr/local/bin/lein run .git`"
  },
  {
    "timestamp": "2017-09-22T12:54:35.000220",
    "conversation_id": 731,
    "user": "Mia",
    "message": "maybe not"
  },
  {
    "timestamp": "2017-09-22T12:54:44.000521",
    "conversation_id": 731,
    "user": "Mia",
    "message": "might have been line cutoff"
  },
  {
    "timestamp": "2017-09-22T13:00:36.000198",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "i want run N threads and in main thread i want wait until they done, how?"
  },
  {
    "timestamp": "2017-09-22T13:01:09.000121",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "<@Gladys> there are hundreds of ways to do that"
  },
  {
    "timestamp": "2017-09-22T13:01:32.000727",
    "conversation_id": 731,
    "user": "Merri",
    "message": "<@Gladys> Look at my `merge` example above. Another good alternative is `pipeline` (blocking if you're going to do IO)"
  },
  {
    "timestamp": "2017-09-22T13:02:12.000146",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "this is for very long I/O operations where input came part by part and output is send part by part. And whole process is running on multi sources."
  },
  {
    "timestamp": "2017-09-22T13:02:40.000159",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "ya, like jstew I'm a fan of pipeline-blocking for parallelising io"
  },
  {
    "timestamp": "2017-09-22T13:03:50.000292",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but there is not transducer, because in each thread i run function to read source part by part and i can’t read next part until i read current part"
  },
  {
    "timestamp": "2017-09-22T13:04:01.000170",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "so i think i can’t use pipeline-blocking here"
  },
  {
    "timestamp": "2017-09-22T13:06:32.000389",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "and *the main problem* is i have to wait until all threads are finish to run next similar operation, because next one is depend on previous"
  },
  {
    "timestamp": "2017-09-22T13:06:41.000185",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "so i have to know when all threads finish"
  },
  {
    "timestamp": "2017-09-22T13:06:53.000521",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "that is the issue which i don’t know how to solve in this context"
  },
  {
    "timestamp": "2017-09-22T13:07:14.000192",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "``` (let [out-chan (chan num-threads)] (pipeline-blocking num-threads out-chan (comp (map long-running-fn) (filter (constantly false))) (to-chan (range num-threads))) (<!! out-chan)) ```"
  },
  {
    "timestamp": "2017-09-22T13:09:25.000195",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "out-chan will not be closed until a long-running-fn has run for each of the integers in (range num-threads) with p//ism num-threads, so <!! wil block until that has finished"
  },
  {
    "timestamp": "2017-09-22T13:09:33.000307",
    "conversation_id": 731,
    "user": "Merri",
    "message": "I think you can still use pipeline-blocking since your transducer can run all of those steps composed as a single fn. I would be curious about throughput though. Seems to me like it should be about the same."
  },
  {
    "timestamp": "2017-09-22T13:10:44.000109",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but it is not like that, i don’t have `long-running-fn`. Ok i have to explain it more: 1) first issue is i have multi sources of data and i have to read from each one part by part. That one is easy. 2) next issue i have to use output of 1) to output this data in new place part by part 3) when this process is finish i have to do 1) 2) but for another source of data. And that is the issue. Because even when channels are close still something can send output."
  },
  {
    "timestamp": "2017-09-22T13:11:39.000133",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "PS the source of data is very big, so also i have to put to channel part by part"
  },
  {
    "timestamp": "2017-09-22T13:12:10.000510",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "ech i will paste my code here to better understand"
  },
  {
    "timestamp": "2017-09-22T13:13:05.000025",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "<https://pastebin.com/CgBp1i0x>"
  },
  {
    "timestamp": "2017-09-22T13:14:11.000347",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but maybe i am blind to solve that in different way"
  },
  {
    "timestamp": "2017-09-22T13:14:51.000132",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "`(archai/fetch-epoch #(>!! in-elastic %))` and that one `>!! in-elastic` on every incoming part of data"
  },
  {
    "timestamp": "2017-09-22T13:15:24.000372",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "which are the long running functions here?"
  },
  {
    "timestamp": "2017-09-22T13:15:50.000112",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "archai->push and fetch-epoch?"
  },
  {
    "timestamp": "2017-09-22T13:15:59.000048",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "yes, both"
  },
  {
    "timestamp": "2017-09-22T13:16:07.000382",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but what important"
  },
  {
    "timestamp": "2017-09-22T13:16:24.000377",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "`(archai/fetch-epoch #(>!! in-elastic %))` do`>!!` multiple times"
  },
  {
    "timestamp": "2017-09-22T13:17:12.000400",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "just inside that function i download source part by part (no other way)"
  },
  {
    "timestamp": "2017-09-22T13:18:18.000280",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "and that is fine i run it parallel and it work. But i need to know when it finish and this is what i don’t know how to solve"
  },
  {
    "timestamp": "2017-09-22T13:18:35.000035",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "i can do (atom) and inc/dec… but it looks so bad"
  },
  {
    "timestamp": "2017-09-22T13:19:13.000090",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "the easiest way will be to know when all: ``` (thread (try (elastic/archai->push input) (catch Throwable ex (l/error ex)))) ``` finish"
  },
  {
    "timestamp": "2017-09-22T13:19:41.000468",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "each call to thread returns a channel, if you can collect them and wait on all of them"
  },
  {
    "timestamp": "2017-09-22T13:20:15.000259",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "sounds like you want pipeline-astync"
  },
  {
    "timestamp": "2017-09-22T13:20:18.000294",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but if i will wait on them i will be blocked by limited numbers of `go`, so i don’t wait"
  },
  {
    "timestamp": "2017-09-22T13:20:57.000675",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "<@Harry> first solution based on that, but it doesn’t help. Still i can’t determine when output finished processing"
  },
  {
    "timestamp": "2017-09-22T13:21:21.000295",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "`pipeline-async` stop blocking as soon as input channel is closed"
  },
  {
    "timestamp": "2017-09-22T13:21:29.000367",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "output channel can be still processing"
  },
  {
    "timestamp": "2017-09-22T13:21:56.000148",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "yeah you need to have a finish channel for the thing consuming the output of that"
  },
  {
    "timestamp": "2017-09-22T13:21:57.000404",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "<@Gladys> why would you be blocked? waiting on a channel parks, you can wait on all the channels from the thread calls, when there are no more you know you are done"
  },
  {
    "timestamp": "2017-09-22T13:22:37.000070",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "if needed, you can put the channel returned by the thread call onto another channel, to park in another context"
  },
  {
    "timestamp": "2017-09-22T13:22:40.000223",
    "conversation_id": 731,
    "user": "Mia",
    "message": "<@Margaret> <@Myles> thanks for the help. a new `git checkout` seems to have fixed it ¯\\_(ツ)_/¯"
  },
  {
    "timestamp": "2017-09-22T13:22:40.000280",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "<@Margaret> i don’t see it, do you have some example?"
  },
  {
    "timestamp": "2017-09-22T13:23:08.000304",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "i mean i don’t see how it helps"
  },
  {
    "timestamp": "2017-09-22T13:23:23.000131",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "and how not blocking by limit of `go` numbers"
  },
  {
    "timestamp": "2017-09-22T13:23:29.000463",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "if the threads have all returned, then you can read from on their channels"
  },
  {
    "timestamp": "2017-09-22T13:23:53.000167",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "if you use `<!` to read the result, this parks and doesn't block the go block"
  },
  {
    "timestamp": "2017-09-22T13:23:59.000592",
    "conversation_id": 731,
    "user": "Merri",
    "message": "remember that `thread` returns a channel. You know that the thread is finished by waiting for the channel."
  },
  {
    "timestamp": "2017-09-22T13:24:20.000259",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "i know, but still i don’t see how it helps"
  },
  {
    "timestamp": "2017-09-22T13:24:34.000141",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "in that context"
  },
  {
    "timestamp": "2017-09-22T13:25:13.000580",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "no way to start threads with some names and check if threads with this names exists?"
  },
  {
    "timestamp": "2017-09-22T13:27:35.000285",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "no, but you can put all the channels returned by thread calls onto another channel, perhaps called \"pending\""
  },
  {
    "timestamp": "2017-09-22T13:27:42.000156",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "``` (go-loop [] (let [input (<! in-elastic)] (when-not (nil? input) (thread (try (elastic/archai->push input) (catch Throwable ex (l/error ex)))) (recur)))) ``` so step by step, if i will add `<!!` here with thread it will be running only 1 at a time, if i will run multiples workers in go block i will be blocked by limited numbers of go block"
  },
  {
    "timestamp": "2017-09-22T13:27:54.000334",
    "conversation_id": 731,
    "user": "Margaret",
    "message": "when every channel you read off of pending has been read from, you know all the threads you started are done"
  },
  {
    "timestamp": "2017-09-22T13:28:18.000302",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "ok let me think about that once again"
  },
  {
    "timestamp": "2017-09-22T13:28:30.000352",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "<@Gladys> here is what I would do ``` (defn archai->elastic-refresh [] (let [epochs (archai/generate-epochs epochs-from-now) in-elastic (chan 100) finished-chan (chan)] (pipeline-async 10 in-elastic (fn [epoch out-chan] (thread (archai/fetch-epoch #(>!! out-chan %)) (close! out-chan))) (to-chan epochs)) (pipeline-blocking 10 finished-chan (comp (map (fn [input] (try (elastic/archai->push input) (catch Throwable ex (l/error ex))))) (filter (constantly false))) in-elastic) (<!! finished-chan)) ```"
  },
  {
    "timestamp": "2017-09-22T13:28:50.000550",
    "conversation_id": 731,
    "user": "Merri",
    "message": "I think merge covers that use case nicely, <@Margaret>. You can merge all your chans into one uber-chan."
  },
  {
    "timestamp": "2017-09-22T13:28:52.000200",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "10 being the number of threads you want"
  },
  {
    "timestamp": "2017-09-22T13:29:18.000479",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "how would it help here?"
  },
  {
    "timestamp": "2017-09-22T13:30:22.000539",
    "conversation_id": 731,
    "user": "Aldo",
    "message": "I'm assuming you wanted to vary the amount of threads between the input and the output functions. if that's not necessary I'd just make it one big pipeline-blocking xf"
  },
  {
    "timestamp": "2017-09-22T13:30:42.000081",
    "conversation_id": 731,
    "user": "Myles",
    "message": "lmao. computers are very good"
  },
  {
    "timestamp": "2017-09-22T13:31:30.000064",
    "conversation_id": 731,
    "user": "Merri",
    "message": "If you're starting n workers. `(merge (map #(worker-fn..) (range n)))`"
  },
  {
    "timestamp": "2017-09-22T13:32:06.000065",
    "conversation_id": 731,
    "user": "Merri",
    "message": "then later on `<!!` from the chan that merge returns."
  },
  {
    "timestamp": "2017-09-22T13:33:43.000458",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "it wouldn’t work in that way, because `out-chan` has place for only 1 `>!!` but `(archai/fetch-epoch` how to `>!!` many times part by part"
  },
  {
    "timestamp": "2017-09-22T13:34:08.000161",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "but…. i know how to solve it, so thinking forward how to combine your example"
  },
  {
    "timestamp": "2017-09-22T13:34:25.000544",
    "conversation_id": 731,
    "user": "Merri",
    "message": "Good deal, glad I could help a little."
  },
  {
    "timestamp": "2017-09-22T13:37:39.000372",
    "conversation_id": 731,
    "user": "Gladys",
    "message": "hmm how it works about memory consuming? if for example 1 <!! takes 100 MB and it is returned by (map) will it be free after read from channel or after whole map end? Another problem is i can’t run it in that way because i know how to get next part of data only after get previous part of data…"
  },
  {
    "timestamp": "2017-10-06T15:48:33.000016",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "hi all!"
  },
  {
    "timestamp": "2017-10-06T15:49:06.000596",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "do you guys use exceptions for something in your clojure code?"
  },
  {
    "timestamp": "2017-10-06T15:49:19.000147",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "for instance -- for code decoupling?"
  },
  {
    "timestamp": "2017-10-06T15:49:55.000053",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "exceptions tend to couple code together"
  },
  {
    "timestamp": "2017-10-06T15:50:52.000139",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "It makes code need to become aware of exception classes of any library, at any stack depth"
  },
  {
    "timestamp": "2017-10-06T15:50:59.000305",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "exceptions allow separating code from exceptions handling"
  },
  {
    "timestamp": "2017-10-06T15:51:00.000216",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html>"
  },
  {
    "timestamp": "2017-10-06T15:51:22.000170",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "clojure disagrees"
  },
  {
    "timestamp": "2017-10-06T15:51:53.000369",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "so if I want a single-responsibility function I don't wanna handle wrong cases inside the function, I just want to allow someone to handle this"
  },
  {
    "timestamp": "2017-10-06T15:52:04.000349",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "People tend to turn errors into values/data, then act upon the data"
  },
  {
    "timestamp": "2017-10-06T15:52:25.000313",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "ok. how to separate main use case flow from alternative flows?"
  },
  {
    "timestamp": "2017-10-06T15:52:58.000297",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "I will say exceptions are a way of life on the JVM, you can't avoid them. Usually I pick a spot in the code where I turn a specific concrete exception into a datastructure... then send the datastructure around the program"
  },
  {
    "timestamp": "2017-10-06T15:53:19.000392",
    "conversation_id": 915,
    "user": "Merri",
    "message": "exceptions are like side effects, IMO. Unintended side effects that make it hard to write pure functions."
  },
  {
    "timestamp": "2017-10-06T15:53:21.000486",
    "conversation_id": 915,
    "user": "Guillermo",
    "message": "Think of ring web responses -- you turn an exception into a `{:status 400 ...}`"
  },
  {
    "timestamp": "2017-10-06T15:53:30.000382",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "I think you don't get my question. let me explain"
  },
  {
    "timestamp": "2017-10-06T15:54:32.000031",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "lets say I have a use case \"signup user\". I have email, password and confirm password. Firstly I need to check that fields are filled, then -- password and its confirmation match. then I need to check that the same user does not exist yet in DB. Then, after creating user, that the user was successfully created"
  },
  {
    "timestamp": "2017-10-06T15:54:42.000514",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "see the point? lots, LOTS of branching"
  },
  {
    "timestamp": "2017-10-06T15:54:48.000482",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "I want to avoid that"
  },
  {
    "timestamp": "2017-10-06T15:54:58.000288",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "in Java I have exceptions, in Haskell -- Either moand"
  },
  {
    "timestamp": "2017-10-06T15:55:05.000396",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "how to do it in clojure?"
  },
  {
    "timestamp": "2017-10-06T15:55:49.000066",
    "conversation_id": 915,
    "user": "Merri",
    "message": "Usually I try to just use `some->` if I don't care about which part of the process broke."
  },
  {
    "timestamp": "2017-10-06T15:56:31.000109",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "and if I do care? I just want to separate the main flow of the use case from the alternative flows"
  },
  {
    "timestamp": "2017-10-06T15:56:45.000187",
    "conversation_id": 915,
    "user": "Merri",
    "message": "Something like this works well if you do care: <https://adambard.com/blog/acceptable-error-handling-in-clojure/>"
  },
  {
    "timestamp": "2017-10-06T15:56:51.000156",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "just read that"
  },
  {
    "timestamp": "2017-10-06T15:57:10.000440",
    "conversation_id": 915,
    "user": "Willow",
    "message": "`{:user-info {:email ...} :reasons-preventing [:already-present :missing-email]}` and then `(if (seq (:reasons-preventing user-analysis)) (bad-response) (good-response (create-user user-analysis))`"
  },
  {
    "timestamp": "2017-10-06T15:57:16.000624",
    "conversation_id": 915,
    "user": "Willow",
    "message": "something along those lines is what i do often"
  },
  {
    "timestamp": "2017-10-06T15:58:38.000090",
    "conversation_id": 915,
    "user": "Merri",
    "message": "If you have to branch n times you're doing it wrong. I've played with this too: <http://funcool.github.io/cats/latest/>"
  },
  {
    "timestamp": "2017-10-06T15:58:53.000501",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "ok, so you guys don't use exceptions?"
  },
  {
    "timestamp": "2017-10-06T15:59:02.000273",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "so what then? monads?"
  },
  {
    "timestamp": "2017-10-06T16:00:13.000164",
    "conversation_id": 915,
    "user": "Willow",
    "message": "i wouldn't trust anything beyond trivial usage of monads in a dynamic language. i would absolutely hate to pick up someone else's code like that"
  },
  {
    "timestamp": "2017-10-06T16:00:58.000233",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Willow> same as me, monads are for static type system"
  },
  {
    "timestamp": "2017-10-06T16:01:35.000107",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "so I'm getting back to my question -- how to separate main flow and alternative flows without exceptions?.."
  },
  {
    "timestamp": "2017-10-06T16:03:08.000555",
    "conversation_id": 915,
    "user": "Willow",
    "message": "i like my example. build up an object with the inputs and analysis. you can put reasons preventing creating a user in the db, whatever. and then afterwards a function that takes that analysis object and has a simple cond statement examining the reasons-preventing the creation, and otherwise do the thing you want"
  },
  {
    "timestamp": "2017-10-06T16:04:36.000125",
    "conversation_id": 915,
    "user": "Willow",
    "message": "``` (def token-verification-functions [not-breeze-token? not-recent? not-verified? not-user-id?]) (defn- analyze-token* [decoded-token] (let [reasons (into [] (keep #(% decoded-token)) token-verification-functions)] {:valid? (empty? reasons) :reasons reasons})) ```"
  },
  {
    "timestamp": "2017-10-06T16:06:06.000117",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "yeah, it looks like a bit more complex variant of monad Either"
  },
  {
    "timestamp": "2017-10-06T16:06:14.000691",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "i think Either should go here"
  },
  {
    "timestamp": "2017-10-06T16:06:22.000525",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "exceptions look alien to clojure"
  },
  {
    "timestamp": "2017-10-06T16:12:51.000120",
    "conversation_id": 915,
    "user": "Merri",
    "message": "<@Robbyn> Off the top of my head I would try something like this: ```(let [[result err] (-> [[:success, nil] {:name \"name\" :password \"pw\"}] validate-user check-exists create-user)]) ```"
  },
  {
    "timestamp": "2017-10-06T16:13:28.000059",
    "conversation_id": 915,
    "user": "Merri",
    "message": "each fn returns a result and error and continues only if there's a good result."
  },
  {
    "timestamp": "2017-10-06T16:14:10.000141",
    "conversation_id": 915,
    "user": "Merri",
    "message": "`->` could also be `some->` so that you don't have to check the input on each fn."
  },
  {
    "timestamp": "2017-10-06T16:14:55.000543",
    "conversation_id": 915,
    "user": "Merri",
    "message": "The only kind of gross thing is having to return the [result err] seq in each fn."
  },
  {
    "timestamp": "2017-10-06T16:15:13.000462",
    "conversation_id": 915,
    "user": "Merri",
    "message": "reminds me a little of the way that go handles errors."
  },
  {
    "timestamp": "2017-10-06T16:15:36.000240",
    "conversation_id": 915,
    "user": "Margaret",
    "message": "it’s basically a hand-rolled monad"
  },
  {
    "timestamp": "2017-10-06T16:16:12.000399",
    "conversation_id": 915,
    "user": "Merri",
    "message": "It pretty much is, and we've come full circle."
  },
  {
    "timestamp": "2017-10-06T16:16:37.000097",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "and you might as well implement Validation instead :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:21:38.000452",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "I don't consider exceptions to be that evil, now that we have `ex-info` and `ex-data`."
  },
  {
    "timestamp": "2017-10-06T16:23:08.000320",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "OTOH, if you can `reduce` all your steps you can short-circuit evaluation by returning `(reduced {:fail ...})`..."
  },
  {
    "timestamp": "2017-10-06T16:24:03.000182",
    "conversation_id": 915,
    "user": "Merri",
    "message": "Hmm. That's a good use case for `reduced` that I haven't thought of."
  },
  {
    "timestamp": "2017-10-06T16:25:04.000329",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "`(try (some complex pipeline that throws ex-info anywhere) (catch clojure.lang.ExceptionInfo e (ex-data e)))` -- one top-level `catch` to return whatever data was thrown..."
  },
  {
    "timestamp": "2017-10-06T16:26:00.000262",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "A bit like having transients inside a process and making them persistent to return the value :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:26:21.000043",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "i'm surprised it's not been covered in the book I'm reading so far"
  },
  {
    "timestamp": "2017-10-06T16:27:00.000220",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "(sorry if you said earlier and I missed it)"
  },
  {
    "timestamp": "2017-10-06T16:28:07.000084",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "ah, it is. chapter 12. still on my way there :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:30:16.000024",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Merri> have you ever heard about monad Either? :wink:"
  },
  {
    "timestamp": "2017-10-06T16:30:30.000153",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Robbyn> scala hacker? :wink:"
  },
  {
    "timestamp": "2017-10-06T16:30:35.000562",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "Page 304 onward and page 447 onward cover some good stuff about exceptions (assuming JoC 2nd Ed)"
  },
  {
    "timestamp": "2017-10-06T16:30:47.000127",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "It lives by my left hand :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:31:03.000166",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Daniell> it was the friendliest to common lisp refugees I found. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:32:18.000067",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Daniell> looks like ex-info/ex-data is a good workaround for my case"
  },
  {
    "timestamp": "2017-10-06T16:33:23.000335",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "<@Arlean> Yeah, JoC 1st Ed was my first Clojure book -- but I'd done Lisp and a fair bit of FP in various academic languages back in the early 80's."
  },
  {
    "timestamp": "2017-10-06T16:34:56.000477",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "Modern clojure/clojurescript is truly refreshing, I didn't think I'd be able to do this seriously. The community is doing an amazing job and I am in awe. Just wish I'd made the jump sooner!"
  },
  {
    "timestamp": "2017-10-06T16:35:47.000278",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "I picked up clojure a bit early on, but it was rather fringe and iirc, there were some nasty bugs in maps that made me decide to sit it out for a while"
  },
  {
    "timestamp": "2017-10-06T16:36:13.000078",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "I picked up Clojure to play with in 2010, been doing it in production since 2011, and it became our primary back end language a few years ago."
  },
  {
    "timestamp": "2017-10-06T16:36:54.000348",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Daniell> maybe you can give us a talk about it on our conference?"
  },
  {
    "timestamp": "2017-10-06T16:37:04.000052",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "I've been very happy with ring, and it looks like spec will get me some way to functional dependant types without the pain of blowing up intellij you get with scala's shapeless :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:37:20.000330",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "<@Robbyn> Pretty easy to mimic Either and related monads with `first`/`second` and `vector` for the values. A few `def` aliases for syntactic sugar and you're golden! :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:37:47.000109",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "and never underestimate the fearsome power of macros :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:38:06.000220",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "yeah, but monad is about the syntactic sugar, otherwis it looks like even more complex solution than the problem it tries to solve"
  },
  {
    "timestamp": "2017-10-06T16:39:43.000312",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "Type systems are overrated :slightly_smiling_face: (I've had a love/hate relationship with Haskell since it appeared and I worked with a number of its predecessors in the 80's)"
  },
  {
    "timestamp": "2017-10-06T16:40:29.000009",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "Yeah, I'm in two minds with types, I think spec can hopefully find the middle ground. It looks so great until one of your nodes restarts and you goofed and push the rest of the cluster over. :confused:"
  },
  {
    "timestamp": "2017-10-06T16:40:29.000171",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Daniell> can't agree with you more. I feel like I'm much more productive in Clojure than in Haskell and even in Java. But I don't know why"
  },
  {
    "timestamp": "2017-10-06T16:40:57.000030",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "sometimes I think that clojure just offers such simple solutions that we don't need to spend the time for investigating complex frameworks"
  },
  {
    "timestamp": "2017-10-06T16:41:01.000253",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "that said i did some nodejs consultancy a few years ago and the scars drove me towards the Haskell/Scala camp :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:41:20.000139",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "<@Arlean> what brought you to clojure?"
  },
  {
    "timestamp": "2017-10-06T16:41:32.000275",
    "conversation_id": 915,
    "user": "Verona",
    "message": "I hope someone can help me, for some reason I'm unable to get the `(reset)` working for a reloaded workflow. I've used this on multiple projects in the past two years now, but it always seems very unstable. Quite often I'm unable to use the reset-fn since it errors that a namespace isn't found... I have checked that the source-paths in project.clj are correct. Anyone with similar troubles?"
  },
  {
    "timestamp": "2017-10-06T16:41:38.000113",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "Ah, yes, JS can inspire a fear of dynamic languages / love of type systems :slightly_smiling_face: I've managed to avoid JS almost completely..."
  },
  {
    "timestamp": "2017-10-06T16:42:37.000008",
    "conversation_id": 915,
    "user": "Daniell",
    "message": "<@Verona> There's a <#C0GQAAKA9|component> channel that may be able to give more specific advice. I must admit I've also had problems trying to use that workflow on projects..."
  },
  {
    "timestamp": "2017-10-06T16:43:02.000303",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Robbyn> initially I was a hairy undocumented sbcl hacker, so lisp is an old friend. My recent desire to learn it fluently is driven by discovering in production Scala is not delivering on types, and cemented by figwheel and general repl development"
  },
  {
    "timestamp": "2017-10-06T16:43:29.000300",
    "conversation_id": 915,
    "user": "Verona",
    "message": "<@Daniell> Ah, thanks, didn't know that. Will ask it there :+1:."
  },
  {
    "timestamp": "2017-10-06T16:44:36.000185",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Robbyn> some of what you get with CIDER repl development is 'meh' to a CL user, NASA literally debugged the pathfinder probe at the repl while it was on Mars using lisp- yet my initial forays into what clojure offers has wowed me, which just means I'm here to stay :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:44:59.000367",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "nah, I've heard that 1000....0000 times"
  },
  {
    "timestamp": "2017-10-06T16:45:02.000408",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "hehe"
  },
  {
    "timestamp": "2017-10-06T16:45:49.000012",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "let's face it, it's going to be a while before the lisp communities are going to top that anecdote"
  },
  {
    "timestamp": "2017-10-06T16:48:04.000147",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Robbyn> but if you're of a scala/haskell persuasion, spec being able to emulate scalacheck/quickcheck and provide static checking seems like a massive step towards closing any gap there may be."
  },
  {
    "timestamp": "2017-10-06T16:48:54.000234",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "every point on the lambda cube has pain. it's nice to try other geometry"
  },
  {
    "timestamp": "2017-10-06T16:56:18.000281",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "Nice! And how do you emulate it without static type system?"
  },
  {
    "timestamp": "2017-10-06T16:56:36.000465",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "clojure.spec.alpha :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T16:57:19.000301",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "it's dependent typing and structural typing in a common definition language, as far as i understand it (please anyone better qualified jump in at this point :))"
  },
  {
    "timestamp": "2017-10-06T16:59:12.000077",
    "conversation_id": 915,
    "user": "Rebeca",
    "message": "spec isn't a type system at all"
  },
  {
    "timestamp": "2017-10-06T16:59:27.000152",
    "conversation_id": 915,
    "user": "Rebeca",
    "message": "it is more like a contract system"
  },
  {
    "timestamp": "2017-10-06T17:00:33.000003",
    "conversation_id": 915,
    "user": "Rebeca",
    "message": "the only checking it does for functions is generative(generating inputs and checking outputs, no analysis of the code), which isn't suitable for use in production"
  },
  {
    "timestamp": "2017-10-06T17:01:34.000313",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "but for example, it could easily be used to declare structural types, ala typescript, no?"
  },
  {
    "timestamp": "2017-10-06T17:02:23.000050",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "the type system is obviously far to strong to be totally enforced at compile time, but ten years from now, couldn't we see linters using the common format to statically check certain aspects?"
  },
  {
    "timestamp": "2017-10-06T17:03:34.000327",
    "conversation_id": 915,
    "user": "Rebeca",
    "message": "possibly, but unlikely, it allows arbitrary predicates"
  },
  {
    "timestamp": "2017-10-06T17:04:27.000324",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "As for me without lots of tests this specs are useless"
  },
  {
    "timestamp": "2017-10-06T17:04:33.000426",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "absolutely, it would not even be *possible* to statically enforce the full level of specs"
  },
  {
    "timestamp": "2017-10-06T17:04:49.000280",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Robbyn> did you ever use property based testing?"
  },
  {
    "timestamp": "2017-10-06T17:04:59.000397",
    "conversation_id": 915,
    "user": "Robbyn",
    "message": "Yes"
  },
  {
    "timestamp": "2017-10-06T17:06:25.000462",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "hmm. come to think of it, specs structural language may be itself too powerful to do typechecking, predicates or no :confused:"
  },
  {
    "timestamp": "2017-10-06T17:09:20.000213",
    "conversation_id": 915,
    "user": "Willow",
    "message": "is there a good collection compare for testing when order doesn't matter besides set, or this essentially what any collection compare would do anyways?"
  },
  {
    "timestamp": "2017-10-06T17:09:44.000379",
    "conversation_id": 915,
    "user": "Willow",
    "message": "i guess that would destroy duplicates in teh general case which doesn't affect me here but presumably this is a standard problem?"
  },
  {
    "timestamp": "2017-10-06T17:10:27.000126",
    "conversation_id": 915,
    "user": "Aldo",
    "message": "<@Willow> (= (frequencies col1) (frequencies col2))?"
  },
  {
    "timestamp": "2017-10-06T17:10:46.000506",
    "conversation_id": 915,
    "user": "Willow",
    "message": "ah nice"
  },
  {
    "timestamp": "2017-10-06T17:10:58.000208",
    "conversation_id": 915,
    "user": "Willow",
    "message": "thanks"
  },
  {
    "timestamp": "2017-10-06T17:11:04.000244",
    "conversation_id": 915,
    "user": "Aldo",
    "message": "np, I love that function"
  },
  {
    "timestamp": "2017-10-06T17:11:11.000156",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "bag=, i love it"
  },
  {
    "timestamp": "2017-10-06T17:11:15.000328",
    "conversation_id": 915,
    "user": "Aldo",
    "message": "it's so useful in so many surprising ways"
  },
  {
    "timestamp": "2017-10-06T17:11:16.000012",
    "conversation_id": 915,
    "user": "Willow",
    "message": "i like it and never thing to use it."
  },
  {
    "timestamp": "2017-10-06T17:12:06.000443",
    "conversation_id": 915,
    "user": "Willow",
    "message": "<@Arlean> do you have `bag=` defn'd to the frequencies comparison bfabry showed?"
  },
  {
    "timestamp": "2017-10-06T17:13:05.000041",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "<@Willow> no! but I will now :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T17:13:05.000237",
    "conversation_id": 915,
    "user": "Willow",
    "message": "or have an alternative imp"
  },
  {
    "timestamp": "2017-10-06T17:13:14.000115",
    "conversation_id": 915,
    "user": "Willow",
    "message": "haha i was kinda thinking the same thing"
  },
  {
    "timestamp": "2017-10-06T17:13:27.000001",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "it's the perfect bag= function. perfect for all your ISeq needs :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T17:13:47.000259",
    "conversation_id": 915,
    "user": "Arlean",
    "message": "my naive answer would be coerce both args to sets, and now look, we don't handle bags :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-10-06T17:18:59.000385",
    "conversation_id": 915,
    "user": "Willow",
    "message": "ticket closed for not being amenable to nice looking code"
  },
  {
    "timestamp": "2017-11-07T20:37:29.000135",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "I wonder if Rich would be ok with clojure 2.0 having breaking changes to remove warts from the core language, or if he wants clojure to be eternally backwards compatible regardless of whether the occasional bad design decision aggregates or not"
  },
  {
    "timestamp": "2017-11-07T20:38:05.000034",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "I mean clojure is a very well designed language but there are a few ugly parts that could use a do-over"
  },
  {
    "timestamp": "2017-11-07T20:38:34.000009",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i know he mentioned that if he could do it all over again reduce would require an initial value"
  },
  {
    "timestamp": "2017-11-07T20:42:28.000029",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "and rename `for` to something like `sequence-comprehension`"
  },
  {
    "timestamp": "2017-11-07T20:42:37.000197",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "(my suggestion, not anybody elses)"
  },
  {
    "timestamp": "2017-11-07T20:43:03.000148",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "and I tend to think that lazy evaluation of the elements of a sequence and the actual transformation performed over a sequence are orthogonal concepts. its unfortunate that transducers are complected with the idea of immediate evaluation."
  },
  {
    "timestamp": "2017-11-07T20:43:25.000157",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "are they? you can transduce lazily"
  },
  {
    "timestamp": "2017-11-07T20:44:12.000151",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "(transduce ...) isn't truly lazy"
  },
  {
    "timestamp": "2017-11-07T20:44:29.000041",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "but that’s not the only transducing context - and right, transduce is not lazy"
  },
  {
    "timestamp": "2017-11-07T20:45:18.000057",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "what i'm really getting at is that the core api is more complex than it needs to be simply because it was necessary to keep it backwards compatible and not make a breaking change"
  },
  {
    "timestamp": "2017-11-07T20:45:53.000270",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "what you'd really want to do is be able to define a set of transformations (probably a sequence of transformations actually)"
  },
  {
    "timestamp": "2017-11-07T20:46:09.000235",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "sequence is lazy, and eduction"
  },
  {
    "timestamp": "2017-11-07T20:46:34.000187",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "and defining a transducing function is exactly what you describe"
  },
  {
    "timestamp": "2017-11-07T20:47:02.000037",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "then you'd want to separately define how those transformations are applied to a sequence of data (lazy, not lazy, across multiple cores or not, etc)"
  },
  {
    "timestamp": "2017-11-07T20:47:06.000092",
    "conversation_id": 1292,
    "user": "Aldo",
    "message": "transducers are literally a way to define a set of transformations without worrying about representation. the `transduce` function is perhaps a bit misleading as it's a way of applying transducers"
  },
  {
    "timestamp": "2017-11-07T20:47:31.000114",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "right now we have reducers in the core library for handling the parallel case"
  },
  {
    "timestamp": "2017-11-07T20:47:36.000076",
    "conversation_id": 1292,
    "user": "Margaret",
    "message": "<@Evelin> you are describing exactly how transducers are used"
  },
  {
    "timestamp": "2017-11-07T20:48:06.000223",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "let me be more specific then"
  },
  {
    "timestamp": "2017-11-07T20:48:16.000262",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "what i'm saying isn't that something should exist"
  },
  {
    "timestamp": "2017-11-07T20:48:22.000291",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "its that something shouldn't exist"
  },
  {
    "timestamp": "2017-11-07T20:48:32.000261",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "there shouldn't be an api for doing things \"without transducers\""
  },
  {
    "timestamp": "2017-11-07T20:48:48.000161",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "transducers are the bottom, simplest (most decomplected) case"
  },
  {
    "timestamp": "2017-11-07T20:49:03.000182",
    "conversation_id": 1292,
    "user": "Aldo",
    "message": "eh, that's a position to take. it'd make the language less approachable though"
  },
  {
    "timestamp": "2017-11-07T20:50:12.000085",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "<@Evelin> Do you know where Rich said that about reduce requiring an init val? I remember that as well, but I tried looking for it once and couldn't find it."
  },
  {
    "timestamp": "2017-11-07T20:50:48.000108",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "And I think he has said that clojure 2.0 just isn't going to happen..."
  },
  {
    "timestamp": "2017-11-07T20:51:00.000203",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "there is something else i find a bit puzzling though-- we use transducers to convey what is basically loop unrolling to the compiler-- we really don't NEED then to pass around the idea of doing a specific sequence of transformations, because we could just use apply to apply a sequence of transformations or we could pass around an s-expression that represents the transformations"
  },
  {
    "timestamp": "2017-11-07T20:51:04.000175",
    "conversation_id": 1292,
    "user": "Evan",
    "message": "<@Giovanna> he mentions it in his effective programs talk"
  },
  {
    "timestamp": "2017-11-07T20:51:31.000188",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "basically i've been thinking and i'm trying to understand whether or not transducers are really ACTUALLY simple, or whether or not they are just an implementation detail"
  },
  {
    "timestamp": "2017-11-07T20:52:07.000081",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "wouldn't a sufficiently intelligent compiler be able to inspect an s expression before evaluating it and rearrange its subexressions algebraically to do what transducers are effectively doing?"
  },
  {
    "timestamp": "2017-11-07T20:52:46.000028",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "or heck, a macro could do that"
  },
  {
    "timestamp": "2017-11-07T20:53:01.000200",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "the async library has really magical macros that tear apart s expressions"
  },
  {
    "timestamp": "2017-11-07T20:53:21.000053",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "A macro is a compiler, in a way"
  },
  {
    "timestamp": "2017-11-07T20:54:45.000162",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i'm just thinking that transducers, while they capture the idea of performing a computation independent of the type of the collection or data source, and in that sense are a basic fundamental thing, realistically aren't NECESSARY to extract the information about what sequence of transformations are actually taking place, since this is a lisp after all"
  },
  {
    "timestamp": "2017-11-07T20:55:21.000325",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i'm really not sure how I feel about it, its either transducers (and the initial difficulty in learning them) or the magic of a macro"
  },
  {
    "timestamp": "2017-11-07T20:57:03.000335",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "imagine that if instead of having go channels take a transducer you just had something like `(magic (map f (filter g chan)))`, where `magic` is responsible for doing what transducers essentially do for chans"
  },
  {
    "timestamp": "2017-11-07T20:57:43.000024",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "it would do all the unrolling itself, and ensure that you didn't have intermediate collections or channels"
  },
  {
    "timestamp": "2017-11-07T20:58:01.000281",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "furthermore you can extend `magic` beyond what transducers are strictly capable of"
  },
  {
    "timestamp": "2017-11-07T20:58:13.000255",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "you can use it with other (non transducible) forms"
  },
  {
    "timestamp": "2017-11-07T20:58:46.000093",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "If you want to use transducers on a lazy source call `(sequence xfn coll)`"
  },
  {
    "timestamp": "2017-11-07T21:00:34.000196",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "(where `xfn` is the transducer)"
  },
  {
    "timestamp": "2017-11-07T21:01:01.000154",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i'm aware of that <@Guillermo> i was just criticizing some of clojure's design"
  },
  {
    "timestamp": "2017-11-07T21:02:26.000027",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "I think there is an option somewhere in between those. I was thinking about that the other day. Transducers are kind of ... fragile?... they have all these rules like don't touch the result so far, call the next rf in the chain in the cleanup arity, zero arity just calls (rf), etc. Could a macro kind of like `fn` take care of all that stuff instead of us having to write all that boilerplate?"
  },
  {
    "timestamp": "2017-11-07T21:03:08.000040",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Rich has made it really clear that despite some regrets, compatibility will be preserved. There will not be any attempt to \"fix mistakes\" and break everyone's code. This is why it's important to commit to and promise less"
  },
  {
    "timestamp": "2017-11-07T21:04:08.000173",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "(see the \"speculation\" keynote)"
  },
  {
    "timestamp": "2017-11-07T21:04:33.000088",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "As always though, the future holds interesting possibilities..."
  },
  {
    "timestamp": "2017-11-07T21:07:33.000181",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Wouldn't your `magic` macro have to know about all possible transducers though? How would it know if something can be made into a transducer?"
  },
  {
    "timestamp": "2017-11-07T21:09:03.000017",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "<@Jonas> <https://github.com/cgrand/xforms>"
  },
  {
    "timestamp": "2017-11-07T21:09:40.000152",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "I mean i understand that one of the really great things about transducers is that you can construct your own transducers and then use them with any transducible process. My criticism about it is that it seems to expose some limitation in the implementation; its not purely about separating the sequence of transformations from the sequence (or channel or whatever) of data-- you could make that separation without creating the idea of a transducer, by just passing around function that is composed of the data processing functions for instance, then apply that function directly to the data."
  },
  {
    "timestamp": "2017-11-07T21:11:36.000194",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "<@Jonas> Also I wrote this one for someone here on the slack <https://gist.github.com/madstap/a7d158ef0c3e7b5bbf5cd55c5de4c913>"
  },
  {
    "timestamp": "2017-11-07T21:12:26.000116",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "<@Evelin>, `(map inc)`, `(filter even?)`, etc. seem like fairly minimal descriptions of a “step”"
  },
  {
    "timestamp": "2017-11-07T21:13:05.000067",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "why even bother me with that though?"
  },
  {
    "timestamp": "2017-11-07T21:13:24.000124",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "why can't i say `(map inc (filter even? (map inc foo)))`"
  },
  {
    "timestamp": "2017-11-07T21:13:32.000191",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "why can't clojure do algebra to reorganize it"
  },
  {
    "timestamp": "2017-11-07T21:13:37.000168",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "<@Evelin> But how would you do filter in that scheme? A function that returns nothing, as something separate from nil?"
  },
  {
    "timestamp": "2017-11-07T21:14:27.000196",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "how would you like it organized? currently, you can do `(comp (map inc) (filter even?) (map inc))`"
  },
  {
    "timestamp": "2017-11-07T21:14:31.000244",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Doing algebra in the compiler has a cost... That's what Haskell does"
  },
  {
    "timestamp": "2017-11-07T21:15:06.000164",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "There is also no clear definition in an impure language around what is pure vs impure, where can I move things around, etc"
  },
  {
    "timestamp": "2017-11-07T21:15:37.000129",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Transducers aren't perfect, but the cost-benefit / leverage is off the charts high"
  },
  {
    "timestamp": "2017-11-07T21:16:05.000041",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "They were also implemented in user space, in a library initially"
  },
  {
    "timestamp": "2017-11-07T21:16:17.000213",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "No involvement of compiler"
  },
  {
    "timestamp": "2017-11-07T21:16:51.000252",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "basically, `(comp (map inc) (filter even?) (map inc))` is no better a representation of the process from an apparent point of view than the s-expression `((map inc) (filter even?) (map inc))`, or the s expression `(map inc (filter even? (map inc)))`"
  },
  {
    "timestamp": "2017-11-07T21:18:08.000040",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "the idea of transducers were to separate the definition of what was being done from the thing upon which it was being done"
  },
  {
    "timestamp": "2017-11-07T21:18:13.000184",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i posit that we could already do this"
  },
  {
    "timestamp": "2017-11-07T21:18:15.000273",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "because this is lisp"
  },
  {
    "timestamp": "2017-11-07T21:18:48.000111",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "neat"
  },
  {
    "timestamp": "2017-11-07T21:18:55.000017",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "the real reason transducers are around is because clojure see's `(map inc (filter even? (map inc x)))` and makes three sequences"
  },
  {
    "timestamp": "2017-11-07T21:19:05.000211",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "it isn't smart enough to know it can unravel for you"
  },
  {
    "timestamp": "2017-11-07T21:19:08.000129",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "I don't really know what you're arguing for tbh"
  },
  {
    "timestamp": "2017-11-07T21:19:27.000201",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "just for my understanding, how does this compare to `(comp (partition-by consecutive-fn) (map merge-fn))`?"
  },
  {
    "timestamp": "2017-11-07T21:19:48.000197",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Transducers are independent of collections. They don't compare to a collection pipeline"
  },
  {
    "timestamp": "2017-11-07T21:21:10.000028",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "But sure, can make a macro that does a lot of things. Transducers as they are in core hit a sweet spot with expressivity and leverage"
  },
  {
    "timestamp": "2017-11-07T21:21:10.000196",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "The merge-fn is reduced over each partition instead of given a partition as an argument."
  },
  {
    "timestamp": "2017-11-07T21:21:17.000036",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Does that make sense?"
  },
  {
    "timestamp": "2017-11-07T21:21:45.000019",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "The examples being bandied about (map inc) are nice because they capture only essential detail"
  },
  {
    "timestamp": "2017-11-07T21:22:05.000094",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Hard to improve on that"
  },
  {
    "timestamp": "2017-11-07T21:22:11.000128",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "so more like `(comp (partition-by consecutive-fn) (map #(reduce merge-fn %))`?"
  },
  {
    "timestamp": "2017-11-07T21:23:23.000226",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "I think that would be equivalent. Nice one!"
  },
  {
    "timestamp": "2017-11-07T21:23:47.000149",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "although, I think your example wouldn’t have to hold a whole partition in memory at the same time"
  },
  {
    "timestamp": "2017-11-07T21:24:02.000016",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "There would have to be a huge benefit to incur additional complexity into the compiler or macro. Not saying that's a no, but it's unlikely to be sufficiently compelling."
  },
  {
    "timestamp": "2017-11-07T21:24:03.000108",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "so if you had large partitions"
  },
  {
    "timestamp": "2017-11-07T21:24:20.000172",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "That's true"
  },
  {
    "timestamp": "2017-11-07T21:24:42.000164",
    "conversation_id": 1292,
    "user": "Guillermo",
    "message": "Esp to overcome the inertia of adding an opt phase in the compiler"
  },
  {
    "timestamp": "2017-11-07T21:25:34.000171",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "my biggest gripe is that transducer's inherent value seems to be that you can describe a process to be done on the elements of a data source (channel, collection, sequence, iterable, whatever else) by \"composing that process out of transducers\"-- but you could already DESCRIBE that process anyway, without resorting to composing functions; you could just compose data in S-expressions that literally represent what you are doing to whatever thing you are doing it to; and if you want it to be independent of the thing you have that choice already! just omit it from the S-expression (its always going to be the most nested, rightmost element)"
  },
  {
    "timestamp": "2017-11-07T21:25:46.000192",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "i’m trying to figure out if the same transducer could be created from two simpler transducers, but my brains a little fried at the moment"
  },
  {
    "timestamp": "2017-11-07T21:25:55.000166",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "too much philosophizing about tranducers :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-11-07T21:26:24.000264",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "so i'm wracking my head trying to think, what do transducers really actually do? They don't necessarily allow me to communicate anything about the process of transformation on data moreso than i could without them, and they don't allow me to separate the process from the thing being processed moreso than i could do without them"
  },
  {
    "timestamp": "2017-11-07T21:27:22.000057",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i can only think that what transducers really do that the nested S-expressions don't is to capture the idea of doing a bunch of processes together at once in one pass on whatever the thing is"
  },
  {
    "timestamp": "2017-11-07T21:27:26.000132",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "I think you could say that about functions in clojure in general"
  },
  {
    "timestamp": "2017-11-07T21:27:34.000054",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "once you do `(def myfn (fn [x] (+ x 1)))`"
  },
  {
    "timestamp": "2017-11-07T21:27:44.000184",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "you don’t pass around the s-expr"
  },
  {
    "timestamp": "2017-11-07T21:27:49.000168",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "you pass around the function"
  },
  {
    "timestamp": "2017-11-07T21:27:55.000035",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "and you can’t really take it apart later"
  },
  {
    "timestamp": "2017-11-07T21:28:51.000113",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "I find them fun and tiring to write :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-11-07T21:29:17.000045",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "if you hand somebody `myfn`, they can’t tell if it’s made up for complicated stuff or that it just returns a constant"
  },
  {
    "timestamp": "2017-11-07T21:29:41.000280",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "hehe"
  },
  {
    "timestamp": "2017-11-07T21:30:01.000259",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "that’s kinda why i’m hoping you could make more complicated transducers by just composing simpler ones"
  },
  {
    "timestamp": "2017-11-07T21:30:33.000244",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "because, as you mentioned, there are a bunch of rules that you have to follow"
  },
  {
    "timestamp": "2017-11-07T21:30:49.000088",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "… or else"
  },
  {
    "timestamp": "2017-11-07T21:30:52.000125",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "kaboom"
  },
  {
    "timestamp": "2017-11-07T21:31:36.000104",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "if the idea of transducers was to separate what is being done from the thing is is being done to, isn't that just the definition of a function?"
  },
  {
    "timestamp": "2017-11-07T21:31:49.000157",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "doesn't `myfn` do precisely that?"
  },
  {
    "timestamp": "2017-11-07T21:32:08.000130",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "why should i need transducers when i have `(fn ...)`"
  },
  {
    "timestamp": "2017-11-07T21:32:24.000123",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "i mean, you can take a look at the definitions of the different transducers"
  },
  {
    "timestamp": "2017-11-07T21:32:29.000203",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "and they are “just functions”"
  },
  {
    "timestamp": "2017-11-07T21:32:43.000247",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "I think it’s useful to say more about them and give them a name like transducers"
  },
  {
    "timestamp": "2017-11-07T21:33:04.000149",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "for these types of functions, `map`, `filter`, `dedupe`, etc"
  },
  {
    "timestamp": "2017-11-07T21:33:29.000048",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "and having the tranducers as a separate thing has already paid off"
  },
  {
    "timestamp": "2017-11-07T21:33:43.000185",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Yes, exactly. I think that you mostly can do that, but sometimes there are just basic building blocks that aren't compositions of other transducers. And sometimes, like I did, you make a new one cause you don't have the imagination to combine two existing ones."
  },
  {
    "timestamp": "2017-11-07T21:33:45.000111",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "originally, core async had their own map, filter, dedupe functions"
  },
  {
    "timestamp": "2017-11-07T21:34:07.000071",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "but now you can reuse these core functions in core async or use them with lazy sequences"
  },
  {
    "timestamp": "2017-11-07T21:34:45.000175",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "it seems kinda obvious that it should be possible, but if you look around at other ecosystems, they do have have a `map` for Rx, and then `map` for collections"
  },
  {
    "timestamp": "2017-11-07T21:34:59.000061",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Take a look at source of the xforms library some time, some of those are basic building blocks. (Fair warning, trying to grok that is headache inducing.)"
  },
  {
    "timestamp": "2017-11-07T21:35:21.000070",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i don't mean to imply that i think we should have a bunch of different maps for different data types"
  },
  {
    "timestamp": "2017-11-07T21:35:28.000158",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i'm trying to say that i don't think we need transducers to avoid that"
  },
  {
    "timestamp": "2017-11-07T21:36:09.000247",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "yea, it seems neat"
  },
  {
    "timestamp": "2017-11-07T21:36:17.000160",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "thanks for the link!"
  },
  {
    "timestamp": "2017-11-07T21:36:40.000017",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "think about what you are actually feeding a chan for instance when you provide a xf argument"
  },
  {
    "timestamp": "2017-11-07T21:36:53.000034",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "you are giving it a function that is composed of transducers (other functions)"
  },
  {
    "timestamp": "2017-11-07T21:37:01.000124",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "it has to be composed of transducers, nothing else"
  },
  {
    "timestamp": "2017-11-07T21:37:45.000179",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "you can't for instance, give it just a general expression that expects a value in a particular place and can use any function (\"transducible\" or otherwise)"
  },
  {
    "timestamp": "2017-11-07T21:37:57.000022",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "you also can't just give it any old function"
  },
  {
    "timestamp": "2017-11-07T21:38:13.000044",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "and expect it to work, even if the dimensionality and data types match up"
  },
  {
    "timestamp": "2017-11-07T21:38:18.000138",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "atleast not as exepcted"
  },
  {
    "timestamp": "2017-11-07T21:38:41.000101",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "IF the transducible process had the macro capability to look inside what you gave it"
  },
  {
    "timestamp": "2017-11-07T21:39:04.000082",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "THEN it could decide for itself what it can do, whether it has to break up some things or rearrange others into what we are calling \"transducible process\""
  },
  {
    "timestamp": "2017-11-07T21:39:21.000142",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "it could even rearrange things or break things up in more particular ways that are specific to the thing being worked on"
  },
  {
    "timestamp": "2017-11-07T21:39:26.000011",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "chan in this instance"
  },
  {
    "timestamp": "2017-11-07T21:39:48.000160",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "this is what async/go actually does"
  },
  {
    "timestamp": "2017-11-07T21:40:00.000134",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "it breaks up your s-expression and creates a state machine out of it"
  },
  {
    "timestamp": "2017-11-07T21:40:34.000103",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "transducers were a great way to follow DRY, but i feel like it was a missed opportunity to just fix the real issue"
  },
  {
    "timestamp": "2017-11-07T21:41:08.000070",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "can you give an example of what you would like the code to look like?"
  },
  {
    "timestamp": "2017-11-07T21:42:14.000129",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "i feel like it’s hard to be more concise than `(chan 1 (map inc))`,"
  },
  {
    "timestamp": "2017-11-07T21:45:04.000039",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i'd like to say `(map dec (filter even? (reduce conj [] (foo bar (xan zoo WHATEVER)))))` and have clojure know how to optimally unravel it so that it doesn't create more intermediate sequences than necessary, can do what is effectively known as a \"transducible process\" (doing things in one pass) on either side of the reduce, and can even do things in parallel if it can use the runtime to judge that doing so doesn't alter the semantics of what you are doing (it can't if you are just using immutable values) and if doing so would result in faster computation even after taking into account the overhead involved with concurrency."
  },
  {
    "timestamp": "2017-11-07T21:45:40.000259",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "in other words, the details exposed to us in the transducer api shouldn't really have to be exposed to us-- if that is how things need to work between \"transducible processes\" well ok, but why should i be bothered with it?"
  },
  {
    "timestamp": "2017-11-07T21:45:51.000009",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "that sort of thing belongs in the implementation of eval"
  },
  {
    "timestamp": "2017-11-07T21:46:17.000058",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "the fact that making new transducers means they have to do this and this and that, why do i care?"
  },
  {
    "timestamp": "2017-11-07T21:46:27.000136",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "can't eval look at what i'm giving it and verify that i've done these things?"
  },
  {
    "timestamp": "2017-11-07T21:47:02.000163",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "if i want to express the idea of a computation without the thing being computed, i can just say `(map dec (filter even? (reduce conj [] (foo bar (xan zoo)))))`"
  },
  {
    "timestamp": "2017-11-07T21:47:06.000069",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "notice the lack of WHATEVER"
  },
  {
    "timestamp": "2017-11-07T21:47:30.000103",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i just pass it as an s-expression and someone can inject whatever they want into it and then evaluate it"
  },
  {
    "timestamp": "2017-11-07T21:47:41.000257",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "imho transducers just don't feel very lispy"
  },
  {
    "timestamp": "2017-11-07T21:48:01.000050",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "they work well for what they try to do, but it sort of misses the point of lisp"
  },
  {
    "timestamp": "2017-11-07T21:48:10.000007",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Verify that I've done these things is different than doing them automatically, though."
  },
  {
    "timestamp": "2017-11-07T21:49:44.000042",
    "conversation_id": 1292,
    "user": "Jonas",
    "message": "it would be cool if the compiler would take my clojure code and optimize/parallelize it for me, but that seems like a separate issue than the design of transducers"
  },
  {
    "timestamp": "2017-11-07T21:49:57.000031",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "yeah its sort of a bigger issue"
  },
  {
    "timestamp": "2017-11-07T21:50:56.000043",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i guess i tend to think that ideally programs should just say what it is, semantically, that you want to do"
  },
  {
    "timestamp": "2017-11-07T21:51:12.000013",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "the question of how that is done or how to make it performant is a completely separate and orthogonal concern"
  },
  {
    "timestamp": "2017-11-07T21:51:23.000104",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "usually best solved in the complier or evalutor"
  },
  {
    "timestamp": "2017-11-07T21:51:45.000086",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "i don't like it when programming languages ask you to make them faster by instructing them on how to do the compiler's job"
  },
  {
    "timestamp": "2017-11-07T21:52:17.000223",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "I think that's kind of not the clojure way, though. Like the difference between `last` and `peek` on a vector."
  },
  {
    "timestamp": "2017-11-07T21:53:29.000081",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Semantically they're the same, but one's way faster"
  },
  {
    "timestamp": "2017-11-07T21:53:47.000103",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "yeah i guess i just have a different opinion on the matter"
  },
  {
    "timestamp": "2017-11-07T21:53:51.000226",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "you are right it probably isn't the clojure way"
  },
  {
    "timestamp": "2017-11-07T21:54:01.000036",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "heck it probably isn't even a very popular view on things"
  },
  {
    "timestamp": "2017-11-07T21:54:06.000011",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "oh well i'll stop ranting"
  },
  {
    "timestamp": "2017-11-07T21:54:11.000123",
    "conversation_id": 1292,
    "user": "Evelin",
    "message": "thanks for hearing me out though"
  },
  {
    "timestamp": "2017-11-07T21:56:22.000210",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "Yeah, I remember hearing/reading it longer ago than the conj.... I have a crappy memory though, so you never know ¯\\_(ツ)_/¯"
  },
  {
    "timestamp": "2017-11-07T22:02:38.000087",
    "conversation_id": 1292,
    "user": "Giovanna",
    "message": "I think it's very valid to question things :slightly_smiling_face: Rich is not a messiah and blindly following him is not good for anyone."
  },
  {
    "timestamp": "2017-11-07T22:07:24.000065",
    "conversation_id": 1292,
    "user": "Daniell",
    "message": "Re: writing your own transducing functions -- I wrote one that turned flat sequences of maps into sequences of threaded sequences of maps (based on certain fields acting as keys and back references). It turned out to be a very elegant solution to creating threaded conversations out of raw sequences of messages between members. It hid the complexity of the problem and it was easily composable with any other processing I wanted to do on messages (before transformation) or conversations (after transformation)."
  },
  {
    "timestamp": "2017-11-07T23:43:04.000201",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "<@Evelin> there's a lot of compiler tech out there that does this sort of thing. PyPy does it out-of-the-box at runtime, infact PyPy actually runs transducers over int arrays faster than Clojure. ClojureScript does as well. Clang can do this sort of stuff but it would require all your pipelines to be defined up-front and fully static"
  },
  {
    "timestamp": "2017-11-07T23:43:52.000132",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "The beauty of the Clojure model, is that none of this took compiler support. It just works as a library."
  },
  {
    "timestamp": "2017-11-07T23:44:35.000034",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "That's the problem with a lot of these approaches. PyPy took 3-4 people 10 years to engineer. The JS JITs took less time, but larger teams. Transducers were mostly designed in about 3 weeks by one person."
  },
  {
    "timestamp": "2017-11-07T23:45:11.000031",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "And you'll see that pattern throughout Clojure, never over-engineer. If you can accomplish what you need with your existing tools, do it that way."
  },
  {
    "timestamp": "2017-11-07T23:45:38.000046",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "Not saying these other methods aren't valid, but they are much more complicated."
  },
  {
    "timestamp": "2017-11-08T00:08:00.000094",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "And for anyone here interested, here's pretty much the state-of-the-art for this sort of thing. From the Scala world, but the paper goes over Lisp and the like as well: <https://infoscience.epfl.ch/record/180642/files/EPFL_TH5456.pdf>"
  },
  {
    "timestamp": "2017-11-08T00:10:50.000197",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "yeah the first 50 pages or so are an overview of why we need this thing"
  },
  {
    "timestamp": "2017-11-08T00:15:37.000068",
    "conversation_id": 1292,
    "user": "Berry",
    "message": "<@Sandy>: can you tell <https://www.youtube.com/channel/UC6yONKYeoE2P3bsahDtsimg/videos> to create a video walkthrough of the paper, step by step, implementing a minimal setup in clojure ?"
  },
  {
    "timestamp": "2017-11-08T01:00:38.000128",
    "conversation_id": 1292,
    "user": "Sandy",
    "message": "Heh, most of it leans really heavily on static typing. How to adapt it to more dynamic languages is still a WIP"
  },
  {
    "timestamp": "2017-11-21T15:07:14.000568",
    "conversation_id": 1458,
    "user": "Lori",
    "message": "i have a long list of `let` bindings where a conditional could branch an error at any time options: 1. I have many-nested `(let [...] (cond ... (let [...] (cond ...` 2. ~would it be idiomatic to build the `let` \"context\" as a record getting passed down a `(cond->`?~ 3. something else?"
  },
  {
    "timestamp": "2017-11-21T15:08:59.000184",
    "conversation_id": 1458,
    "user": "Lori",
    "message": "actually, step 2 doesn't seem to work like I want"
  },
  {
    "timestamp": "2017-11-21T15:09:41.000319",
    "conversation_id": 1458,
    "user": "Lori",
    "message": "basically, I'd just like a long list of let bindings, that depend on things before them, but if I have a conditional branch during that process, I can \"short circuit\" the whole thing"
  },
  {
    "timestamp": "2017-11-21T15:11:33.000323",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Is there a way for a deftype to extend Atom, or do I need to have an atom in its parameters and implement the lang.IAtom interface?"
  },
  {
    "timestamp": "2017-11-21T15:12:13.000530",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I assume I should do that instead of manually using mutable fields? (using `set!`?)"
  },
  {
    "timestamp": "2017-11-21T15:18:40.000464",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "<@Earlie>, there are some cases where manually setting mutable fields might be more straightforward (eg. java interop)"
  },
  {
    "timestamp": "2017-11-21T15:19:11.000160",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "why won’t using a regular atom work for your usecase?"
  },
  {
    "timestamp": "2017-11-21T15:22:48.000092",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "<@Lori> let-later from useful works for that kind of thing <https://github.com/amalloy/useful/blob/develop/src/flatland/useful/utils.clj#L224>"
  },
  {
    "timestamp": "2017-11-21T15:30:46.000002",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Jonas> I'm using deftype, because there are a number of other protocols to be implemented and modifications to the normal atom functions. I didn't know if there was a way for it to extend an atom, since its base data is just an atom."
  },
  {
    "timestamp": "2017-11-21T15:32:21.000273",
    "conversation_id": 1458,
    "user": "Lori",
    "message": "interesting, that could possibly work, but I'd rather not bring in a big dependency, nor copy out what I need from EPL'd code... is there not a standard trick for me to obviate heavily nested code?"
  },
  {
    "timestamp": "2017-11-21T15:33:14.000138",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "the typical approach is to extend all the interfaces / protocols atom implements, instead of concrete inheritance from atom itself"
  },
  {
    "timestamp": "2017-11-21T15:34:34.000555",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "```=> (supers (class (atom nil))) #{clojure.lang.IRef java.lang.Object clojure.lang.IMeta clojure.lang.AReference clojure.lang.ARef clojure.lang.IDeref clojure.lang.IReference clojure.lang.IAtom}```"
  },
  {
    "timestamp": "2017-11-21T15:35:04.000342",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "it depends what you need - IDeref doesn’t help with eg. swap! or add-watch"
  },
  {
    "timestamp": "2017-11-21T15:35:50.000408",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "isn’t `swap!` specifically for atoms and not any other reference type?"
  },
  {
    "timestamp": "2017-11-21T15:36:57.000208",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "it depends what someone means by “acting like an atom” here - it’s fully in our power to make something that is a drop in replacement for an atom"
  },
  {
    "timestamp": "2017-11-21T15:37:53.000581",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "not that I know of - you could do something similar to what let-later is doing, but more manually - making delays and only realizing them as you need them for example"
  },
  {
    "timestamp": "2017-11-21T15:38:09.000356",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "there are also “monad” libraries that use the Either monad for a similar result"
  },
  {
    "timestamp": "2017-11-21T15:41:19.000630",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "right. I ask mostly because most of the time when I’ve seen someone try to implement `IAtom`, they don’t plan to also implement all of the same semantics. if you’re not implementing all of the same semantics, I think it probably makes more sense to just use another function to manipulate your reference type just like the other clojure reference types each have their own functions, (eg. `vswap!`, `send`, `ref-set`, etc)"
  },
  {
    "timestamp": "2017-11-21T15:44:52.000605",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Thanks, guys, this helps."
  },
  {
    "timestamp": "2017-11-21T15:45:05.000319",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "<@Earlie> going back to your initial question, `proxy` can extend an atom, or you can implement all the right protocols / interfaces to replicate an atom (maybe even using a closed over atom) with deftype, reify, defrecord, etc."
  },
  {
    "timestamp": "2017-11-21T15:45:25.000049",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "but it really depends on what you are trying to do, which behaviors you need, what you exactly you wanted from IAtom"
  },
  {
    "timestamp": "2017-11-21T15:45:48.000095",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "because extending a clojure built in tends to be a bit tedious because of how the interfaces / protocols are factored"
  },
  {
    "timestamp": "2017-11-21T15:45:48.000666",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Closed over meaning the deftype includes an atom as a parameter?"
  },
  {
    "timestamp": "2017-11-21T15:46:20.000147",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "as a parameter, or just creating a reify inside a let block that defines the atom - there’s a few ways to “capture” an atom for internal usage"
  },
  {
    "timestamp": "2017-11-21T15:46:39.000308",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": ":thumbsup:"
  },
  {
    "timestamp": "2017-11-21T15:55:43.000611",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> When implementing IAtom's swap functions, is there a way to reduce duplication of swapping code? Do I need the 4 different arrity versions?"
  },
  {
    "timestamp": "2017-11-21T15:56:53.000063",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "since you can’t control the caller, and the interface supports all those arities, I think the only safe thing is to define them all (even if they all end up calling the same variadic function)"
  },
  {
    "timestamp": "2017-11-21T15:57:26.000102",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "clojure will let you skip arities or even methods, but it will lead to a runtime error if they get called"
  },
  {
    "timestamp": "2017-11-21T15:57:47.000628",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Is there a performance benefit of not colling the other arities of the type (duplicating the function). (e.g. should I call deref on the `this` argument, or does it make sense to reimplement the logic of the deref inline?)"
  },
  {
    "timestamp": "2017-11-21T15:58:21.000531",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, so an external variable arity function could be called by all of them. That's probably the cleanest."
  },
  {
    "timestamp": "2017-11-21T15:58:36.000498",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "that’s a more general software design question isn’t it? sometimes it’s worth it to avoid the abstraction for performance / resource reasons, sometimes it makes sense to abstract and avoid the repetition"
  },
  {
    "timestamp": "2017-11-21T15:58:47.000673",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "right, yeah, that’s probably cleanest"
  },
  {
    "timestamp": "2017-11-21T15:58:58.000204",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, I suppose it is. Thanks!"
  },
  {
    "timestamp": "2017-11-21T16:09:39.000650",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> You mind giving me your opinion on this?: ``` (defn- swap-g-counter [this f & args] (let [oldv @this newv (apply f oldv args)] (assert (number? newv) \"Swap! G-Counter function must return a Number\") (swap! (.p this) update (.n this) + (- newv oldv)) @this)) (defn- compare-and-set-g-counter [this oldv newv] (let [value @this] (if (not= oldv value) false (do (swap! this + (- newv value)) true)))) (deftype G-Counter [p n] clojure.lang.IDeref (deref [this] (reduce + (vals @p))) clojure.lang.IAtom (swap [this f] (swap-g-counter this f)) (swap [this f a] (swap-g-counter this f a)) (swap [this f a b] (swap-g-counter this f b)) (swap [this f a b args] (apply swap-g-counter this f b args)) (compareAndSet [this oldv newv] (compare-and-set-g-counter this oldv newv)) (reset [this newv] (swap! this + (- newv @this)) newv)) (defn gcounter [] (new G-Counter (atom {:id 0}) :id)) ```"
  },
  {
    "timestamp": "2017-11-21T16:10:21.000662",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "using @ and swap! in the same function is usually a race condition"
  },
  {
    "timestamp": "2017-11-21T16:11:20.000024",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "On the reset function? So the `@this` should be bound before `swap!`?"
  },
  {
    "timestamp": "2017-11-21T16:11:20.000422",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "you probably want compare-and-set! which allows more complex logic"
  },
  {
    "timestamp": "2017-11-21T16:11:57.000448",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "<@Earlie> at a quick skim, every single function that uses @ and swap! in the same body is a likely race condition"
  },
  {
    "timestamp": "2017-11-21T16:12:23.000458",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "I mean, you even have compare-and-set in the name, so implementing via compare-and-set! is much more likely to be correct"
  },
  {
    "timestamp": "2017-11-21T16:13:00.000234",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I'm not following how it would be a race condition."
  },
  {
    "timestamp": "2017-11-21T16:13:05.000028",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "and yes, looking closer, those are definite race conditions in both of the first two functions"
  },
  {
    "timestamp": "2017-11-21T16:13:27.000174",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Right, I didn't think about how the normal `compare-and-set!` would use my custom reset logic. I'll switch to that."
  },
  {
    "timestamp": "2017-11-21T16:13:57.000086",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "<@Earlie> `(+ newv oldv)` - this is a race condition, oldv came from a deref, the swap! itself will retry, but your function won’t so it will use stale data in a race"
  },
  {
    "timestamp": "2017-11-21T16:14:27.000659",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "`(not= oldv value)` - the truth value of this can change before the swap! runs"
  },
  {
    "timestamp": "2017-11-21T16:14:30.000288",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> Oh! Thanks for clerifying that. I'm following now."
  },
  {
    "timestamp": "2017-11-21T16:14:56.000575",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I'd completely neglector the retrying functionality of atoms."
  },
  {
    "timestamp": "2017-11-21T16:16:14.000630",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> Oh, I can't use the normal `compare-and-set!`, because I'm not wanting the atom reset to the newval; only a subset of the atom can ever be set."
  },
  {
    "timestamp": "2017-11-21T16:16:40.000658",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "`compare-and-set!` uses a java interop `.compareAndSet`"
  },
  {
    "timestamp": "2017-11-21T16:17:09.000314",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "you can’t use it to implement your full functionality, but to preserve expected atom semantics it needs to be your building block"
  },
  {
    "timestamp": "2017-11-21T16:17:31.000038",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "It is? `compareAndSet`"
  },
  {
    "timestamp": "2017-11-21T16:17:49.000255",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Between swap and reset"
  },
  {
    "timestamp": "2017-11-21T16:17:52.000661",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "you can’t just mix @ and swap! of the same atom and expect correctness of any sort"
  },
  {
    "timestamp": "2017-11-21T16:18:08.000669",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "but you can get it by using compare-and-set, with your own retry condition, etc."
  },
  {
    "timestamp": "2017-11-21T16:18:41.000451",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, I think I'm following. I'll try implementing that."
  },
  {
    "timestamp": "2017-11-21T16:19:20.000413",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "the idea is to use compare-and-set to wrap both the read and the modification, and then recur as your retry if the operation did not succeed"
  },
  {
    "timestamp": "2017-11-21T16:25:06.000076",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "is there a reason you want your reference type to use the atom functions instead of creating new functions to interact with your reference type?"
  },
  {
    "timestamp": "2017-11-21T16:26:07.000133",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Mostly as a proof of concept / out of curiosity at the moment."
  },
  {
    "timestamp": "2017-11-21T16:27:10.000030",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "it seems like instead of putting counter related logic inside of `swap!` and `deref`, it might make more sense to put that logic in another function that takes an atom as an argument"
  },
  {
    "timestamp": "2017-11-21T16:28:22.000355",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Well my thought was to abstract it, so users can completely ignore the implementation details of the crdt. :shrug: I think I'll do it both ways and see how it feels."
  },
  {
    "timestamp": "2017-11-21T16:28:46.000433",
    "conversation_id": 1458,
    "user": "Pattie",
    "message": "Not a Monad, no. By fmap I mean (at the minimum) to be able to apply a function to the members of something that this can be done to such that it creates another thing that this can be done to whose members are the result of applying that function. This is very much something we’d want to do with abstract data structures. Like a vector or a map. If it happens to follow the rules of being a Functor (which a Monad does, yes), then great."
  },
  {
    "timestamp": "2017-11-21T16:28:47.000041",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "I would actually probably have the functions work on immutable data"
  },
  {
    "timestamp": "2017-11-21T16:29:05.000318",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "and then let the consumers of the counter decide if they want to use an atom or other reference type"
  },
  {
    "timestamp": "2017-11-21T16:29:19.000013",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, that's likely how I'd do it."
  },
  {
    "timestamp": "2017-11-21T16:51:41.000331",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "How can I get two `swap!`s to run at the same time to test retrying?"
  },
  {
    "timestamp": "2017-11-21T16:52:49.000381",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, it was just too fast... A Thread/sleep did the trick."
  },
  {
    "timestamp": "2017-11-21T16:53:34.000129",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "yeah - adding sleeps (maybe randomized) is a quick way to get race conditions to happen"
  },
  {
    "timestamp": "2017-11-21T16:53:56.000285",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Randomized is a good idea"
  },
  {
    "timestamp": "2017-11-21T16:54:35.000120",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "combining randomized timeouts / sleeps with looped calls is a great way to stress test things that might misbehave"
  },
  {
    "timestamp": "2017-11-21T16:55:00.000587",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "(in terms of race conditions that is)"
  },
  {
    "timestamp": "2017-11-21T16:58:43.000149",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> So I'm still not quite seeing the purpose of `compare-and-set!`. Is there a reason I shouldn't just implement `reset!` inside it with the new value if the old value is the expected value?"
  },
  {
    "timestamp": "2017-11-21T16:59:29.000034",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "the point of compare-and-set! is that atoms don’t lock, and you need to be able to retry if the value changes before your update completes"
  },
  {
    "timestamp": "2017-11-21T17:00:00.000427",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Which `reset!` would do, right?"
  },
  {
    "timestamp": "2017-11-21T17:00:05.000492",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "no"
  },
  {
    "timestamp": "2017-11-21T17:00:09.000431",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "how would it even know?"
  },
  {
    "timestamp": "2017-11-21T17:00:19.000315",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, unless you have some sort of abstract logic based on the value?"
  },
  {
    "timestamp": "2017-11-21T17:00:27.000005",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I think I'm starting to understand."
  },
  {
    "timestamp": "2017-11-21T17:00:32.000434",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "reset! never retries, and the condition you would need to detect in order to retry is outside the scope of the reset! call"
  },
  {
    "timestamp": "2017-11-21T17:00:41.000002",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "which is why you have compare-and-set!"
  },
  {
    "timestamp": "2017-11-21T17:21:10.000413",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> Mind giving this another look? ``` (defn- project-g-counter [p] (reduce + (vals p))) (defn- swap-g-counter [p n f & args] (let [oldv (project-g-counter p) newv (apply f oldv args)] (assert (number? newv) \"Swap! G-Counter function must return a Number\") (assert (>= newv oldv) \"G-Counter is grow only\") (update p n + (- newv oldv)))) (deftype G-Counter [p n] clojure.lang.IDeref (deref [this] (project-g-counter @p)) clojure.lang.IAtom (swap [this f] (swap! p swap-g-counter n f) @this) (swap [this f a] (swap! p swap-g-counter n f a) @this) (swap [this f a b] (swap! p swap-g-counter n f a b) @this) (swap [this f a b args] (apply swap! p swap-g-counter n f a b args) @this) (compareAndSet [this oldv newv] (loop [] (let [pval @p] (if (not= oldv (project-g-counter pval)) false (or (compare-and-set! p pval (swap-g-counter pval n + (- newv oldv))) (recur)))))) (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") (swap! this (partial + (- newv @this))) newv)) (defn gcounter [] (new G-Counter (atom {:id 0}) :id)) ```"
  },
  {
    "timestamp": "2017-11-21T17:24:41.000223",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "<@Earlie> I can see you are trying but <@Rebeca> is right - all the code that uses deref and swap! in the same block of code is setting up a race of some sort"
  },
  {
    "timestamp": "2017-11-21T17:25:42.000278",
    "conversation_id": 1458,
    "user": "Rebeca",
    "message": "swap returns the value swapped in, derefing after the swap could return anything"
  },
  {
    "timestamp": "2017-11-21T17:26:07.000344",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "what I meant about compare-and-set! is that to make this code correct the whole thing needs to be inside a compare-and-set! loop which can either let the caller know if it failed or retry if there was any modification outside"
  },
  {
    "timestamp": "2017-11-21T17:26:33.000213",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, right, I need to use `project-g-counter` on the return value of `swap!` instead. Is there something somewhere else?"
  },
  {
    "timestamp": "2017-11-21T17:26:59.000607",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "the various places you call swap! then return @this for example"
  },
  {
    "timestamp": "2017-11-21T17:27:40.000153",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I realize that problem now: ``` clojure.lang.IAtom (swap [this f] (project-g-counter (swap! p swap-g-counter n f))) (swap [this f a] (project-g-counter (swap! p swap-g-counter n f a))) (swap [this f a b] (project-g-counter (swap! p swap-g-counter n f a b))) (swap [this f a b args] (project-g-counter (apply swap! p swap-g-counter n f a b args))) ```"
  },
  {
    "timestamp": "2017-11-21T17:28:56.000328",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "someone posted and example of using `compare-and-set!` recently, <https://github.com/plumatic/plumbing/blob/master/src/plumbing/core.cljx#L360>"
  },
  {
    "timestamp": "2017-11-21T17:30:05.000155",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Is there something wrong with the implementation of compare-and-set! above?"
  },
  {
    "timestamp": "2017-11-21T17:35:11.000033",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "you don’t seem to understand why I was mentioning compare-and-set! - in order to check an arbitrary condition and retry if the value is modified and also return an arbitrary value other than the thing you just modified, compare-and-set! is the ideal tool"
  },
  {
    "timestamp": "2017-11-21T17:35:35.000189",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "it lets you keep the logic you wanted without having all the race conditions (as long as you use it properly)"
  },
  {
    "timestamp": "2017-11-21T17:37:05.000114",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh, you're saying compare-and-set! should be used not only for the implementation of compareAndSet, but also for the other implementations too?"
  },
  {
    "timestamp": "2017-11-21T17:37:51.000035",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "right - it lets you coordinate in a more flexible way than swap!"
  },
  {
    "timestamp": "2017-11-21T17:38:08.000298",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I apologize for not reading that more carefully. Makes sense. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-11-21T17:38:28.000013",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I didn't even know `compare-and-set!` was a thing until I went to implement IAtom."
  },
  {
    "timestamp": "2017-11-21T17:51:19.000180",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "<@Margaret> Like this? ``` (defn- project-g-counter [p] (reduce + (vals p))) ;; (defn- swap-g-counter [p n f & args] ;; (let [oldv (project-g-counter p) ;; newv (apply f oldv args)] ;; (assert (number? newv) \"Swap! G-Counter function must return a Number\") ;; (assert (>= newv oldv) \"G-Counter is grow only\") ;; (update p n + (- newv oldv)))) (defn- swap-g-counter [this f & args] (let [p (.p this) n (.n this)] (loop [] (let [oldval @this newval (apply f oldval args) pval @p nval (update pval n + (- newval oldval))] (if (compare-and-set! p pval nval) newval (recur)))))) (deftype G-Counter [p n] clojure.lang.IDeref (deref [this] (reduce + (vals p)) ;; (project-g-counter @p) ) clojure.lang.IAtom (swap [this f] (swap-g-counter this f) ;; (project-g-counter (swap! p swap-g-counter n f)) ) (swap [this f a] (swap-g-counter this f a) ;; (project-g-counter (swap! p swap-g-counter n f a)) ) (swap [this f a b] (swap-g-counter this f a b) ;; (project-g-counter (swap! p swap-g-counter n f a b)) ) (swap [this f a b args] (apply swap-g-counter this f a b args) ;; (project-g-counter (apply swap! p swap-g-counter n f a b args)) ) (compareAndSet [this oldv newv] (loop [] (let [pval @p] (if (not= oldv (project-g-counter pval)) false (or (compare-and-set! p pval (swap-g-counter pval n + (- newv oldv))) (recur)))))) (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") (swap! this (partial + (- newv @this))) newv)) (defn g-counter [] (new G-Counter (atom {:id 0}) :id)) ```"
  },
  {
    "timestamp": "2017-11-21T17:53:04.000120",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "I don’t get what’s happening in `reset` but the rest looks better at a first glance"
  },
  {
    "timestamp": "2017-11-21T17:54:48.000292",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Rreset needs to take the value the user wants the counter to be and find the difference between the that and the current value of the counter, then it adds that to the value in the map the user is allowed to modify."
  },
  {
    "timestamp": "2017-11-21T17:55:30.000187",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "``` (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") (swap! this #(+ % (- newv @this))) newv) ``` I had this originally. I suppose it's more readable."
  },
  {
    "timestamp": "2017-11-21T17:55:52.000153",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Can a swap function deref the atom it's swapping?"
  },
  {
    "timestamp": "2017-11-21T17:56:25.000388",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "It's weird, because derefing doesn't return the same value as the swap function accepts."
  },
  {
    "timestamp": "2017-11-21T17:56:33.000348",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "I don’t know if that’s correct yet, but fyi you can always replace `(swap! a #(f % b))` with `(swap! a f b)`"
  },
  {
    "timestamp": "2017-11-21T17:56:52.000015",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Oh yeah, good point. :thumbsup:"
  },
  {
    "timestamp": "2017-11-21T17:57:03.000132",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Much cleaner"
  },
  {
    "timestamp": "2017-11-21T17:57:45.000119",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Actually, swap does accept the current counter value. There's no need for the `@this`"
  },
  {
    "timestamp": "2017-11-21T17:57:53.000323",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "a deref of the same atom inside the function arg to swap! is safe because if the atom changes you will retry the swap!"
  },
  {
    "timestamp": "2017-11-21T17:58:08.000255",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "but yes, that too"
  },
  {
    "timestamp": "2017-11-21T17:58:29.000226",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "That's what I thought, which is why I hadn't thought about it."
  },
  {
    "timestamp": "2017-11-21T17:58:36.000247",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "``` (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") ;; (swap! this + (- newv @this)) (swap! this #(+ % (- newv %))) newv) ```"
  },
  {
    "timestamp": "2017-11-21T18:00:41.000062",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "... I'm not sure why I'm doing this. It just needs to return the newv, and the swap! will handle the difference stuff."
  },
  {
    "timestamp": "2017-11-21T18:01:48.000033",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "``` (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") (swap! this (constantly newv)) newv) ```"
  },
  {
    "timestamp": "2017-11-21T18:02:24.000507",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "won’t the swap! call already return newv?"
  },
  {
    "timestamp": "2017-11-21T18:02:42.000292",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Uh, yeah, it will."
  },
  {
    "timestamp": "2017-11-21T18:02:48.000201",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Well, that shrunk a lot..."
  },
  {
    "timestamp": "2017-11-21T18:03:34.000311",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "It feels a little weird to use swap for reset, though I suppose that allows me to keep the difference logic in the same place."
  },
  {
    "timestamp": "2017-11-21T18:05:23.000297",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I'm pretty happy with that. For anyone interested: ``` (defn- swap-g-counter [this f & args] (let [p (.p this) n (.n this)] (loop [] (let [oldval @this newval (apply f oldval args) pval @p nval (update pval n + (- newval oldval))] (assert (number? newval) \"Swap! G-Counter function must return a Number\") (assert (>= newval oldval) \"G-Counter is grow only\") (if (compare-and-set! p pval nval) newval (recur)))))) (deftype G-Counter [p n] clojure.lang.IDeref (deref [this] (reduce + (vals p))) clojure.lang.IAtom (swap [this f] (swap-g-counter this f)) (swap [this f a] (swap-g-counter this f a)) (swap [this f a b] (swap-g-counter this f a b)) (swap [this f a b args] (apply swap-g-counter this f a b args)) (compareAndSet [this oldv newv] (loop [] (let [pval @p] (if (not= oldv (project-g-counter pval)) false (or (compare-and-set! p pval (swap-g-counter pval n + (- newv oldv))) (recur)))))) (reset [this newv] (assert (number? newv) \"Reset! G-Counter value must be a Number\") (swap! this (constantly newv)))) (defn g-counter [] (new G-Counter (atom {:id 0}) :id)) ```"
  },
  {
    "timestamp": "2017-11-21T18:06:11.000051",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Thanks, <@Margaret>, <@Jonas>, <@Rebeca>! I appreciate the help."
  },
  {
    "timestamp": "2017-11-21T18:14:13.000466",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "seems like calling `vals` on `p` in the deref method would throw an exception"
  },
  {
    "timestamp": "2017-11-21T18:15:20.000247",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, that's a typo. I've fixed it: ``` clojure.lang.IDeref (deref [this] (reduce + (vals @p))) ```"
  },
  {
    "timestamp": "2017-11-21T18:15:29.000193",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "I'm not sure when that got changed."
  },
  {
    "timestamp": "2017-11-21T18:17:49.000013",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "i might be reading it wrong, but seems like there’s still a race condition in your `swap-g-counter` function"
  },
  {
    "timestamp": "2017-11-21T18:18:25.000094",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "the compare-and-set! will fail if p no longer olds pval"
  },
  {
    "timestamp": "2017-11-21T18:18:30.000427",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "that’s the point of using that function"
  },
  {
    "timestamp": "2017-11-21T18:18:52.000301",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "inside a loop that retries if the compare-and-set! fails"
  },
  {
    "timestamp": "2017-11-21T18:19:18.000039",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "and the compare-and-set! will fail if p changes"
  },
  {
    "timestamp": "2017-11-21T18:19:26.000187",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "so if it changes between the 1st and 2nd dereference, but not between the 2nd dereference and `compare-and-set!`"
  },
  {
    "timestamp": "2017-11-21T18:19:30.000185",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "it would be inconsistent"
  },
  {
    "timestamp": "2017-11-21T18:19:49.000234",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "since the new value is derived from both the 1st and 2nd dereference"
  },
  {
    "timestamp": "2017-11-21T18:20:00.000294",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "and the first and second dereference might have different values"
  },
  {
    "timestamp": "2017-11-21T18:20:12.000080",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "no- if it changes between binding oldval and compare-and-set! the compare-and-set will fail"
  },
  {
    "timestamp": "2017-11-21T18:20:43.000243",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "`oldval` isn’t passed into `compare-and-set!`, `pval` is"
  },
  {
    "timestamp": "2017-11-21T18:21:05.000066",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "oh, tricky"
  },
  {
    "timestamp": "2017-11-21T18:21:08.000308",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "yeah, this is weird"
  },
  {
    "timestamp": "2017-11-21T18:21:33.000271",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, I need to get a better naming convention."
  },
  {
    "timestamp": "2017-11-21T18:22:01.000191",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "i think the code would be simplified a lot by having functions that work on immutable counter data"
  },
  {
    "timestamp": "2017-11-21T18:22:16.000121",
    "conversation_id": 1458,
    "user": "Margaret",
    "message": "I think you need nested compare-and-set! calls to ensure consistency on both dereferences?"
  },
  {
    "timestamp": "2017-11-21T18:22:18.000057",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "and using a plain ol’ atom to hold the data"
  },
  {
    "timestamp": "2017-11-21T18:23:02.000132",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "if you really wanted it to work with this interface, you could have `pval` use the data from the `oldval` dereference"
  },
  {
    "timestamp": "2017-11-21T18:24:23.000413",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, I think I'm going to need to switch to immutable functions anyways for my merging logic. At the moment I'd need to have a function which takes one of these and a p (from somewhere else) and merge them. I'd also need another function to get the p out to send elsewhere."
  },
  {
    "timestamp": "2017-11-21T18:24:49.000419",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "the nice thing about atoms is that they just encapsulate identity. I don’t think you want to mix the identity and state pieces into one thing"
  },
  {
    "timestamp": "2017-11-21T18:25:01.000243",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "pval can't use oldval, because oldval is just an integer."
  },
  {
    "timestamp": "2017-11-21T18:25:36.000152",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, I think you're right."
  },
  {
    "timestamp": "2017-11-21T18:25:40.000082",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "right, I guess you would have to have `oldval` derive from `pval`"
  },
  {
    "timestamp": "2017-11-21T18:25:58.000183",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Good call, that's something that it could do."
  },
  {
    "timestamp": "2017-11-21T18:26:17.000450",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Though I'd need to bring back project-g-counter for the reduction function."
  },
  {
    "timestamp": "2017-11-21T18:26:51.000123",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "yea"
  },
  {
    "timestamp": "2017-11-21T18:28:19.000400",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "or as long as you dereference `pval` before you do the dereference for `oldval`, it would work"
  },
  {
    "timestamp": "2017-11-21T18:28:29.000238",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "actually, nvmd"
  },
  {
    "timestamp": "2017-11-21T18:28:33.000062",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "i take that back"
  },
  {
    "timestamp": "2017-11-21T18:29:06.000189",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "I think you have to do it with a single dereference"
  },
  {
    "timestamp": "2017-11-21T18:29:21.000355",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": "other wise it could change in between dereferences and then change back"
  },
  {
    "timestamp": "2017-11-21T18:29:21.000388",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "``` (defn- swap-g-counter [this f & args] (let [p (.p this) n (.n this)] (loop [] (let [pval @p oldval (reduce + (vals pval)) newval (apply f oldval args) nval (update pval n + (- newval oldval))] (assert (number? newval) \"Swap! G-Counter function must return a Number\") (assert (>= newval oldval) \"G-Counter is grow only\") (if (compare-and-set! p pval nval) newval (recur)))))) ```"
  },
  {
    "timestamp": "2017-11-21T18:29:30.000197",
    "conversation_id": 1458,
    "user": "Earlie",
    "message": "Yeah, I'm pretty sure it's needed."
  },
  {
    "timestamp": "2017-11-21T18:30:17.000040",
    "conversation_id": 1458,
    "user": "Jonas",
    "message": ":thumbsup:"
  },
  {
    "timestamp": "2017-12-08T16:50:25.000382",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "I was actually never sure if `(merge nil {:a 1})` working was reliably supported behavior"
  },
  {
    "timestamp": "2017-12-08T16:50:31.000179",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "The doc string does not indicate that it should work"
  },
  {
    "timestamp": "2017-12-08T16:50:47.000424",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "It is fairly annoying to not utilize it though at times"
  },
  {
    "timestamp": "2017-12-08T16:51:07.000280",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "``` clojure.core/merge ([& maps]) Returns a map that consists of the rest of the maps conj-ed onto the first. If a key occurs in more than one map, the mapping from the latter (left-to-right) will be the mapping in the result. ```"
  },
  {
    "timestamp": "2017-12-08T16:52:17.000054",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "that description seems to imply it shouldn't in fact"
  },
  {
    "timestamp": "2017-12-08T16:52:26.000110",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "because ``` (conj nil {:a 1}) => ({:a 1}) (merge nil {:a 1}) => {:a 1} ```"
  },
  {
    "timestamp": "2017-12-08T16:52:55.000469",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "it is supported, but yeah it makes somethings difficult"
  },
  {
    "timestamp": "2017-12-08T16:52:58.000218",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "<@Aldo> good point"
  },
  {
    "timestamp": "2017-12-08T16:53:23.000189",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "merge uses conj internally, but protects against nil"
  },
  {
    "timestamp": "2017-12-08T16:53:31.000464",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "Just because a fn happens to do some behavior with nil now, doesn’t give me a lot of confidence that I’m not relying on an impl detail"
  },
  {
    "timestamp": "2017-12-08T16:53:47.000240",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "I wish it’d be in the docs for these sorts of edge cases"
  },
  {
    "timestamp": "2017-12-08T16:54:29.000116",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "There are plenty of cases like this though. The `merge` one is just one I’ve wrestled with in my head a few times."
  },
  {
    "timestamp": "2017-12-08T16:54:56.000219",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "Also, I’m thinking it’d be a pretty harsh change to have `merge` stop supporting this behavior - so not likely to change anymore :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-12-08T16:54:58.000326",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "core specs will help with this, can almost guarantee it won't go in the docstring"
  },
  {
    "timestamp": "2017-12-08T16:55:34.000252",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "merge supports a couple other surprises, see the last comment in <https://dev.clojure.org/jira/browse/CLJ-1458>"
  },
  {
    "timestamp": "2017-12-08T16:56:08.000215",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "I feel like if a spec is added to merge that says (s/nilable m) then a subsequent docstring PR that clarified what happened in the case of nil would prob be accepted"
  },
  {
    "timestamp": "2017-12-08T16:57:05.000269",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "<@Guillermo> good point on the core.specs. I just took a look over at that (haven’t looked in a while). It still has a lot more functions to cover still right? At least from what I see so far."
  },
  {
    "timestamp": "2017-12-08T16:58:17.000152",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "It's mostly the main macros right now, <@Sonny> has more stuff pending somewhere, and there are a couple of github users that have their own specs of core"
  },
  {
    "timestamp": "2017-12-08T16:58:31.000276",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "ah ok"
  },
  {
    "timestamp": "2017-12-08T16:59:22.000149",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "generally clojure docstrings don't comprehensively specify edge-cases, but <http://clojuredocs.org|clojuredocs.org> or whatever the thing-du-jour is certainly can"
  },
  {
    "timestamp": "2017-12-08T17:00:35.000234",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "\"Someone should\" add an API to third-party clojuredocs and integrate them with tooling"
  },
  {
    "timestamp": "2017-12-08T17:01:28.000348",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "I’m typically ok with that idea"
  },
  {
    "timestamp": "2017-12-08T17:02:18.000203",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "Then other times I have a hard time deciding whether I’m relying on an odd impl detail or not"
  },
  {
    "timestamp": "2017-12-08T17:02:22.000389",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "hah :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-12-08T17:02:45.000016",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "Interesting Jira though, read through the CLJ-1458 one"
  },
  {
    "timestamp": "2017-12-08T17:05:39.000281",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "The stricter interpretation you take of the doc strings, the less likely you are to be relying on an odd impl detail."
  },
  {
    "timestamp": "2017-12-08T17:06:53.000469",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "I know that is still pretty vague advice, but at least in the case of merge, if you never pass it nil, you are safe. If you do, maybe it could return anything at all or raise an exception in Clojure 1.13"
  },
  {
    "timestamp": "2017-12-08T17:07:40.000093",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "Not saying it is likely, given the backwards compatibility effort Rich et al put into Clojure."
  },
  {
    "timestamp": "2017-12-08T17:07:56.000174",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "<@Micha> yeah, and I’ve found myself a few times being defensive about it out of that sort of worry ``` (update x merge {:a 1}) ; not this (update x (fnil merge {}) {:a 1}) ; this ```"
  },
  {
    "timestamp": "2017-12-08T17:07:58.000089",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "that sort of thing"
  },
  {
    "timestamp": "2017-12-08T17:08:16.000257",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "I then just start to wonder if it is worth the nil-guarding efforts"
  },
  {
    "timestamp": "2017-12-08T17:08:25.000140",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "and (generally) the more the docstring promises, the narrower a future path might be"
  },
  {
    "timestamp": "2017-12-08T17:09:07.000356",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "the trade-off, make more verbose code to not rely on things vs hope for the best, but be prepared for potentially more difficult upgrades in the future"
  },
  {
    "timestamp": "2017-12-08T17:09:29.000230",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "and perhaps watch the Jiras carefully and fight for whatever obscure use-case you see that someone is about to break :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-12-08T17:09:49.000121",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "I’m not saying what is right vs wrong here. Just explaining my internal conflict and struggle"
  },
  {
    "timestamp": "2017-12-08T17:10:02.000188",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "<@Petronila> total aside: that update could just use assoc ```=> (assoc nil :a 0) {:a 0}```"
  },
  {
    "timestamp": "2017-12-08T17:10:17.000487",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "<@Margaret> hah thanks, I didn’t intend to make something realistic"
  },
  {
    "timestamp": "2017-12-08T17:10:27.000107",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "that’s what makes it an aside haha"
  },
  {
    "timestamp": "2017-12-08T17:10:27.000330",
    "conversation_id": 1674,
    "user": "Petronila",
    "message": "wasn’t a great example :stuck_out_tongue:"
  },
  {
    "timestamp": "2017-12-08T17:10:33.000115",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "(and `nil` in merge is only problematic in the first argument)"
  },
  {
    "timestamp": "2017-12-08T17:10:58.000193",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "oooh `(fnil merge {} {})` is also valid though"
  },
  {
    "timestamp": "2017-12-08T17:11:47.000473",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "What is a spec for `merge`?"
  },
  {
    "timestamp": "2017-12-08T17:12:01.000293",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "at least the :args part"
  },
  {
    "timestamp": "2017-12-08T17:12:18.000006",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "and ignoring the GIGO cases"
  },
  {
    "timestamp": "2017-12-08T17:12:56.000062",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "it’s one of my pet clojure style issues, I just had to say something, I compulsively replace calls to merge that use a map literal as a second arg with calls to assoc (or instruct co-workers to do so when doing code reviews)"
  },
  {
    "timestamp": "2017-12-08T17:18:44.000155",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "seems like `if-not` could just ditch the expansion with `not` i.e. ``` (defmacro if-not ([test then] `(if ~test nil ~then)) ([test then else] `(if ~test ~else ~then)))```"
  },
  {
    "timestamp": "2017-12-08T17:19:09.000275",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "right, it’s just `if` with the args flipped."
  },
  {
    "timestamp": "2017-12-08T17:19:23.000096",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "minor thing."
  },
  {
    "timestamp": "2017-12-08T17:22:14.000461",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "nope, that's the GIGO"
  },
  {
    "timestamp": "2017-12-08T17:22:36.000495",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "garbage in garbage out"
  },
  {
    "timestamp": "2017-12-08T17:22:41.000172",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "ah, I thought you were speccing the current behaviour :)"
  },
  {
    "timestamp": "2017-12-08T17:23:09.000223",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "GIGO is such a punitive perspective."
  },
  {
    "timestamp": "2017-12-08T17:23:42.000299",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "Ah, you are right <@Kareen>"
  },
  {
    "timestamp": "2017-12-08T17:24:48.000253",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "i am definitely wrong, it's 530PM EST on friday."
  },
  {
    "timestamp": "2017-12-08T17:25:21.000095",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "TIL `(merge)` works"
  },
  {
    "timestamp": "2017-12-08T17:25:33.000247",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "(I think I confused myself with the metadata propagation, which only happens when the first arg is not nil)"
  },
  {
    "timestamp": "2017-12-08T17:26:05.000501",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "But `:m0` should be `(s/nilable (s/keys))`"
  },
  {
    "timestamp": "2017-12-08T17:26:12.000107",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "<@Kareen> the best parge is that `(merge)` returns nil"
  },
  {
    "timestamp": "2017-12-08T17:26:18.000231",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "haha yes ^"
  },
  {
    "timestamp": "2017-12-08T17:26:31.000456",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "I have a feeling that part is definitely gigo"
  },
  {
    "timestamp": "2017-12-08T17:26:32.000277",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "it is a strange implementation"
  },
  {
    "timestamp": "2017-12-08T17:26:45.000391",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "the `some identity` check at the beginning"
  },
  {
    "timestamp": "2017-12-08T17:26:47.000259",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "and it's not really supposed to work"
  },
  {
    "timestamp": "2017-12-08T17:27:28.000168",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "i’ve always found it punitive."
  },
  {
    "timestamp": "2017-12-08T17:27:59.000255",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "there's nothing particularly attractive about it, it's just reality in a dynamic langauge. spec is moving us towards Garbage In EXCEPTION"
  },
  {
    "timestamp": "2017-12-08T17:28:09.000449",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "<@Kareen> merge -> (merge nil nil nil nil) get -> (get get get get)"
  },
  {
    "timestamp": "2017-12-08T17:28:13.000394",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "it can be <@Deandrea>... I think spec will _really_ help with that."
  },
  {
    "timestamp": "2017-12-08T17:28:35.000244",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "``` user=> (merge [] {}) [{}] ```"
  },
  {
    "timestamp": "2017-12-08T17:28:46.000157",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "no matter how many times I see that get over the years it always makes me chuckle"
  },
  {
    "timestamp": "2017-12-08T17:29:07.000161",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "it’s probably one of my greatest discoveries"
  },
  {
    "timestamp": "2017-12-08T17:29:17.000254",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "one of many"
  },
  {
    "timestamp": "2017-12-08T17:29:47.000351",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Guillermo> yes, that is one thing i find attractive about it (spec)."
  },
  {
    "timestamp": "2017-12-08T17:29:55.000292",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "somebody should work on a dialect of swearjure that only uses weird stuff like this"
  },
  {
    "timestamp": "2017-12-08T17:30:13.000345",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "for those who are unfamiliar ```=> (= get ((get get get get) {get get} get)) true```"
  },
  {
    "timestamp": "2017-12-08T17:31:59.000310",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "well, how would you prevent gigo in clojure? spec! what happens if you don't do something like that? gigo! ie, gigo is just the default case in a dynamic language where data is passed around in structures with uniform interfaces"
  },
  {
    "timestamp": "2017-12-08T17:32:49.000359",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> that may be true from some cases but that has more to do with the programmer who wrote the source. it’s not inherently a problem in dynamic languages."
  },
  {
    "timestamp": "2017-12-08T17:33:15.000008",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "another option would be to sanity check all inputs manually. I'm glad no one took the time to do that seeing as spec exists now and that code would just be noise"
  },
  {
    "timestamp": "2017-12-08T17:33:58.000247",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> i disagree. `:pre` and `:post` checks, which i use heavily, are useful."
  },
  {
    "timestamp": "2017-12-08T17:34:09.000355",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "but they're super noisy"
  },
  {
    "timestamp": "2017-12-08T17:34:15.000073",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "and slow"
  },
  {
    "timestamp": "2017-12-08T17:34:19.000149",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "for development."
  },
  {
    "timestamp": "2017-12-08T17:34:41.000440",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "and only when `*check-asserts*` is true. instrumentation with spec is extremely slow as well."
  },
  {
    "timestamp": "2017-12-08T17:34:53.000373",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "they're certainly useful. but they're noisy, and quite a lot of work. I think spec is a much more elegant solution because it gives you some sort of structural documentation and errors as well as validation"
  },
  {
    "timestamp": "2017-12-08T17:35:46.000146",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "if someone had gone through core and :pre'd every function then the current work of going through core and spec'ing every function would feel a bit redundant"
  },
  {
    "timestamp": "2017-12-08T17:35:53.000042",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "so basically, the argument in favor of GIGO is “i don’t want to write the sanity checks for my code because it’s noisy”?"
  },
  {
    "timestamp": "2017-12-08T17:36:00.000287",
    "conversation_id": 1674,
    "user": "Charity",
    "message": "pretty much"
  },
  {
    "timestamp": "2017-12-08T17:36:18.000311",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "\"I don't want to write the sanity checks because it's noisy and I have more important things to write\""
  },
  {
    "timestamp": "2017-12-08T17:36:23.000137",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "that seems like a weak argument against clearly expressing your domain, range, semantics, etc."
  },
  {
    "timestamp": "2017-12-08T17:36:32.000383",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "and that's why spec has been created?"
  },
  {
    "timestamp": "2017-12-08T17:36:37.000267",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "yes."
  },
  {
    "timestamp": "2017-12-08T17:36:40.000363",
    "conversation_id": 1674,
    "user": "Guillermo",
    "message": "Leverage"
  },
  {
    "timestamp": "2017-12-08T17:36:44.000335",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "not just that - overly strict preconditions can make later extensions tedious or incompatible"
  },
  {
    "timestamp": "2017-12-08T17:37:09.000121",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Margaret> i can see that, although, i’ve never come up against that in practice."
  },
  {
    "timestamp": "2017-12-08T17:37:58.000132",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "<@Deandrea> simple example - imagine whitelisting the allowed keys in a hash-map - you now need to rewrite your code as soon as code around it is extended, even though it shouldn’t have to care"
  },
  {
    "timestamp": "2017-12-08T17:38:12.000390",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "other cases are more subtle but often just as tedious"
  },
  {
    "timestamp": "2017-12-08T17:38:19.000115",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> i’ve seen that attitude fail catastrophically though, enough so that `:post (some? %)` has saved me hours of debugging."
  },
  {
    "timestamp": "2017-12-08T17:39:38.000412",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "you can get future proof code without a bunch of complex incantations by failing to validate, once you validate future proofing is more work, and adds complexity in which bugs can hide"
  },
  {
    "timestamp": "2017-12-08T17:39:56.000075",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "(unless the validating comes from the outside, eg. spec)"
  },
  {
    "timestamp": "2017-12-08T17:40:12.000172",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "I don't think anyone disagrees that some validation can be very useful. which is presumably why schema became so popular and why spec was created. I personally think on balance :pre and :post don't give enough extra value to go along with the validation to make them worth it the vast majority of the time. schema gave a bit more value and now spec gives even more to help tip the scales towards making it worth doing"
  },
  {
    "timestamp": "2017-12-08T17:40:17.000253",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Margaret> i suppose my argument there would that, to your point, the constraint is too tight. spec doesn’t alleviate you from that either."
  },
  {
    "timestamp": "2017-12-08T17:40:49.000211",
    "conversation_id": 1674,
    "user": "Charity",
    "message": "if only there were technologies for late-parameterizing specifications with additional requirements"
  },
  {
    "timestamp": "2017-12-08T17:41:19.000174",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "<https://i.imgflip.com/20r5et.jpg>"
  },
  {
    "timestamp": "2017-12-08T17:41:24.000399",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": ":joy:"
  },
  {
    "timestamp": "2017-12-08T17:41:30.000171",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "lol"
  },
  {
    "timestamp": "2017-12-08T17:41:37.000239",
    "conversation_id": 1674,
    "user": "Charity",
    "message": ">.>"
  },
  {
    "timestamp": "2017-12-08T17:42:29.000223",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "so GIGO is not salient when constraints are and vice-versa?"
  },
  {
    "timestamp": "2017-12-08T17:42:36.000232",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "I don't understand what we're arguing about, clojure had a GIGO problem and now we have spec to avoid that"
  },
  {
    "timestamp": "2017-12-08T17:42:37.000432",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "I thought GIGO in Clojure was purely motivated by run-time efficiency ?"
  },
  {
    "timestamp": "2017-12-08T17:43:05.000409",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "I wouldn't say purely but that's the biggest reason"
  },
  {
    "timestamp": "2017-12-08T17:43:07.000369",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Kareen> i was simply trying to understand the attraction to the GIGO rationale."
  },
  {
    "timestamp": "2017-12-08T17:43:16.000272",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "And have any core Clojure developers ever called it GIGO, or is that something originated by others?"
  },
  {
    "timestamp": "2017-12-08T17:43:19.000265",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "GIGO isn't a philosophy or a rationale, it's just a statement. if you pass nonsense in that there's no validation checks around you can expect to get nonsense out"
  },
  {
    "timestamp": "2017-12-08T17:43:38.000215",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Micha> I'm sure I've seen alex call it GIGO more than once :)"
  },
  {
    "timestamp": "2017-12-08T17:43:56.000143",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "i’ve seen that too."
  },
  {
    "timestamp": "2017-12-08T17:44:15.000057",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> in some cases it is a rationale."
  },
  {
    "timestamp": "2017-12-08T17:44:25.000233",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "I would like to see one of those cases"
  },
  {
    "timestamp": "2017-12-08T17:44:33.000260",
    "conversation_id": 1674,
    "user": "Margaret",
    "message": "while GIGO is just a fact, there’s a rationale to prefering code with GIGO behavior over defensive code - which does describe clojure code before spec"
  },
  {
    "timestamp": "2017-12-08T17:45:17.000287",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "yeah but that preference is because of \"performance\" or \"cleaner code\" or \"whatever\". it's not like anyone is specifically trying to write code to silently fail"
  },
  {
    "timestamp": "2017-12-08T17:45:42.000231",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> <https://clojurians.slack.com/archives/C03S1KBA2/p1512771734000461>"
  },
  {
    "timestamp": "2017-12-08T17:46:03.000415",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "meh, you make it sound like most GIGO in clojure was a *design decision* when in reality it is just lack of validation to avoid: - runtime performance costs - having to manually write explicit checks for everything"
  },
  {
    "timestamp": "2017-12-08T17:46:13.000437",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "<@Aldo> If you mean an example of GIGO being a rationale to avoid adding run-time type checks, the clojure.set operators are the biggest example in my mind, e.g. <https://dev.clojure.org/jira/browse/CLJ-1953>"
  },
  {
    "timestamp": "2017-12-08T17:46:21.000285",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Deandrea> ghadi isn't a core developer"
  },
  {
    "timestamp": "2017-12-08T17:46:39.000299",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Kareen> what does that have to do with the discussion?"
  },
  {
    "timestamp": "2017-12-08T17:46:50.000089",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "that's what andy asked"
  },
  {
    "timestamp": "2017-12-08T17:46:59.000442",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "they're using \"gigo\" to describe \"that's a case where the function does something unintended because you passed in something unintended\". I don't see anyone saying \"it should be that way cuz gigo\""
  },
  {
    "timestamp": "2017-12-08T17:47:01.000099",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "i was merely interested in why GIGO is floated as an answer ever."
  },
  {
    "timestamp": "2017-12-08T17:47:33.000023",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "because it's a succinct and accurate one?"
  },
  {
    "timestamp": "2017-12-08T17:47:34.000179",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "look, s/GIGO/undefined behaviour/"
  },
  {
    "timestamp": "2017-12-08T17:47:55.000147",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "gigo is just shorter to type"
  },
  {
    "timestamp": "2017-12-08T17:48:13.000124",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Kareen> ah, okay."
  },
  {
    "timestamp": "2017-12-08T17:48:23.000131",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> accurate?"
  },
  {
    "timestamp": "2017-12-08T17:48:34.000156",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": ":joy:"
  },
  {
    "timestamp": "2017-12-08T17:48:39.000230",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "<@Micha> no one is saying they're not validating clojure.set \"because gigo\". If you were to specifically ask my guess would be \"because performance and can't be bothered\""
  },
  {
    "timestamp": "2017-12-08T17:49:00.000235",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Aldo> i’m pretty sure that’s been floated as a rationale in that discussion."
  },
  {
    "timestamp": "2017-12-08T17:49:21.000242",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "no"
  },
  {
    "timestamp": "2017-12-08T17:49:37.000374",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "core members have said in multiple forums that spec will \"solve\" the gigo issues of clojure.set"
  },
  {
    "timestamp": "2017-12-08T17:49:46.000166",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "so clearly gigo is not a rationale"
  },
  {
    "timestamp": "2017-12-08T17:49:54.000232",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "in one of the linked tickets \"Now that `set` is faster for sets, I think we could actually add checking for sets in some places where we might not have before. \""
  },
  {
    "timestamp": "2017-12-08T17:50:05.000401",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "or that ^"
  },
  {
    "timestamp": "2017-12-08T17:50:11.000408",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "so the previous reason was performance. and the current reason is \"better things to do so far\""
  },
  {
    "timestamp": "2017-12-08T17:50:35.000227",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "also, lucky they did those better things, because they made spec! and now that validation is trivially added in a uniform way rather than ad-hoc"
  },
  {
    "timestamp": "2017-12-08T17:53:44.000027",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Kareen> my line of question was in general not with respect to only core members."
  },
  {
    "timestamp": "2017-12-08T17:54:18.000346",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "it’s was more of “i’ve seen this GIGO thing be used as a rationale in the context of the clojure community and i’m curious what motivates it.”"
  },
  {
    "timestamp": "2017-12-08T17:54:41.000169",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "right, I was assuming we were specifically talking about core"
  },
  {
    "timestamp": "2017-12-08T17:55:40.000292",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "<@Deandrea> The community cannot change clojure.core without the approval of one person. If someone else gives a rationale for what changes in clojure.core, or does not change in clojure.core, it is based on their interpretation/guesstimate of the reasons."
  },
  {
    "timestamp": "2017-12-08T17:57:44.000253",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "there you go :)"
  },
  {
    "timestamp": "2017-12-08T17:57:52.000244",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "My interpretation is that \"can't be bothered to add the checks\" seems unlikely for things like clojure.set functions, since many people would have been happy to provide patches for those years ago if they were desired by the core developer team. spec being a far more general tool is fantastic, and I'm glad it was created."
  },
  {
    "timestamp": "2017-12-08T17:57:59.000059",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "that’d be like, useful"
  },
  {
    "timestamp": "2017-12-08T17:58:10.000329",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "you don’t even have to wait for them to be in core to use them"
  },
  {
    "timestamp": "2017-12-08T17:58:16.000345",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Micha> i understand that, however, my question was more broad in scope. i’m not calling out clojure core, the libraries, or the members. it was a question for the room in the context of the community purely because i’ve seen it be a rationale for doing something not bound by the performance reason."
  },
  {
    "timestamp": "2017-12-08T17:58:20.000034",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "just put ’em in a namespace and load them"
  },
  {
    "timestamp": "2017-12-08T17:59:13.000132",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "the typing thing, well, that’s effectively a fallacy (in my opinion)."
  },
  {
    "timestamp": "2017-12-08T17:59:45.000272",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "to say “i won’t do _x_ because typing” can be a fine argument in certain situations but in general it’s very weak."
  },
  {
    "timestamp": "2017-12-08T18:00:59.000054",
    "conversation_id": 1674,
    "user": "Aldo",
    "message": "the point was simply that you see that kind of beahaviour less in typed languages (at an unacceptable cost). again. not a rationale. a statement"
  },
  {
    "timestamp": "2017-12-08T18:01:00.000243",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "in my experience, writing specs for core stuff can bring out many subtle questions. going through those and teasing apart what is expected, what works but is unexpected, and what doesn’t work now but we might want to work in the future has some measure of art to it."
  },
  {
    "timestamp": "2017-12-08T18:01:04.000223",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "the way i read that argument is “my program won’t/will have this set of properties because (not) typing”."
  },
  {
    "timestamp": "2017-12-08T18:01:48.000346",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "I don't understand what \"typing\" you mean here :) the fingers on a keyboard one or the holy war one"
  },
  {
    "timestamp": "2017-12-08T18:02:07.000066",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Kareen> fingers on the board."
  },
  {
    "timestamp": "2017-12-08T18:02:56.000163",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "i don’t believe in arguing about static vs dynamic typing. it’s a pointless endeavor. folks should be open to good ideas period and stop obsessing about typing discipline."
  },
  {
    "timestamp": "2017-12-08T18:03:01.000395",
    "conversation_id": 1674,
    "user": "Johana",
    "message": "congrats on clojure 1.9.0!"
  },
  {
    "timestamp": "2017-12-08T18:03:34.000081",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "i’m actually filled with a bit of dread now because it means i have to finish garden 2.0.0. :joy:"
  },
  {
    "timestamp": "2017-12-08T18:03:43.000087",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "I’m celebrating with some Templeton Rye 6 year myself :)"
  },
  {
    "timestamp": "2017-12-08T18:05:13.000072",
    "conversation_id": 1674,
    "user": "Johana",
    "message": "I celebrated by upgrading our dev branch and pushed to staging"
  },
  {
    "timestamp": "2017-12-08T18:05:37.000341",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "I have some scotch that would qualify, but I keep coming back to this Templeton lately"
  },
  {
    "timestamp": "2017-12-08T18:06:07.000022",
    "conversation_id": 1674,
    "user": "Charity",
    "message": "3pm PST, I’m in for 1.9.0 scotch :smile:"
  },
  {
    "timestamp": "2017-12-08T18:06:42.000214",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "\"Ahhh, the 1.9.0 --- that was a good version for Scotch...\""
  },
  {
    "timestamp": "2017-12-08T18:06:48.000217",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "ahaha"
  },
  {
    "timestamp": "2017-12-08T18:07:31.000092",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "it’s like they were all drunk or something"
  },
  {
    "timestamp": "2017-12-08T18:07:53.000037",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "on to Clojure 1.10 :)"
  },
  {
    "timestamp": "2017-12-08T18:08:21.000317",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "well the last few weeks has mostly been me rewriting the docs over and over at Rich’s direction :)"
  },
  {
    "timestamp": "2017-12-08T18:08:43.000335",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "Gotta make sure the docs don't over-promise :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-08T18:08:46.000037",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "but also giving it some soak time in case anything came up"
  },
  {
    "timestamp": "2017-12-08T18:08:56.000173",
    "conversation_id": 1674,
    "user": "Micha",
    "message": "Sorry, I couldn't resist. Bad me["
  },
  {
    "timestamp": "2017-12-08T18:09:05.000330",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "no, that’s true :)"
  },
  {
    "timestamp": "2017-12-08T18:09:33.000042",
    "conversation_id": 1674,
    "user": "Sonny",
    "message": "scottish blessing I think"
  },
  {
    "timestamp": "2017-12-08T18:10:15.000187",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": ":thumbsup_all: to the CLI stuff."
  },
  {
    "timestamp": "2017-12-08T18:14:03.000124",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Audie> are you able to patch your test (or code) in such a way that it does not require the task to be executed asynchronously? i know that’s not answering your question, however, it’s one i would ask myself in that situation."
  },
  {
    "timestamp": "2017-12-08T18:16:37.000219",
    "conversation_id": 1674,
    "user": "Audie",
    "message": "<@Deandrea> I don’t see a way to do that. I have to call this async function and wait for the entire process to finish. Otherwise, when I go to the database the data is not there yet"
  },
  {
    "timestamp": "2017-12-08T18:18:31.000336",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Audie> you could use a promise or a future."
  },
  {
    "timestamp": "2017-12-08T18:22:57.000164",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "someone else might have a more elegant solution."
  },
  {
    "timestamp": "2017-12-08T18:23:34.000077",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "sounds like that’s the place in the code you need to patch."
  },
  {
    "timestamp": "2017-12-08T18:24:31.000251",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "so, yes. you need to be able to deliver to the promise when the async task completes. i’m guessing there’s probably a function or something that gets handed to whatever does the async work."
  },
  {
    "timestamp": "2017-12-08T18:29:38.000098",
    "conversation_id": 1674,
    "user": "Audie",
    "message": "I see.. thanks for the help! I’ll try to fix this"
  },
  {
    "timestamp": "2017-12-08T18:40:30.000030",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Daniell> yes, that was a typo."
  },
  {
    "timestamp": "2017-12-08T18:40:39.000156",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "thank you for catching that."
  },
  {
    "timestamp": "2017-12-08T18:41:21.000211",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Berry> if you use conj/peek/pop, vectors and lists behave the same as stacks"
  },
  {
    "timestamp": "2017-12-08T18:41:34.000149",
    "conversation_id": 1674,
    "user": "Daniell",
    "message": "<@Deandrea> I was genuinely surprised it \"worked\" -- I rarely use `:pre`/`:post` so I nearly always have to look up the syntax!"
  },
  {
    "timestamp": "2017-12-08T18:41:52.000171",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "I tend to use vectors as stacks just because `pop-n` and `peek-n` are easier to implement efficiently on vectors"
  },
  {
    "timestamp": "2017-12-08T18:42:01.000107",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Berry> +1 for vectors. and enjoy the concatenative journey. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-08T18:42:07.000090",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Berry> no, all those operations are constant time on both vectors and lists"
  },
  {
    "timestamp": "2017-12-08T18:42:31.000019",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Kareen>: I think vector is log_32 #-elemes, which is <= 5 in most caeds, but technically log n"
  },
  {
    "timestamp": "2017-12-08T18:43:51.000099",
    "conversation_id": 1674,
    "user": "Daniell",
    "message": "I was actually sufficiently awed by Gershwin at one point that I tried it out at work and wrote a few functions in the \"Forth\" style of Clojure! :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-08T18:44:12.000247",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Berry> no that's not correct, conj/pop/peek on vectors are amortized constant time, not log_32, nth/assoc are log_32 on vectors"
  },
  {
    "timestamp": "2017-12-08T18:44:16.000167",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Daniell>: I've lost track the # of afternoons I've lost due to you providing fasicnating links."
  },
  {
    "timestamp": "2017-12-08T18:44:31.000204",
    "conversation_id": 1674,
    "user": "Daniell",
    "message": "(but since it relies on a fork of Clojure and wasn't being updated, I quickly went back to pure Clojure)"
  },
  {
    "timestamp": "2017-12-08T18:45:15.000020",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Kareen>: conj has to be log_32 time as it has to create a new node for every level of the b-tree"
  },
  {
    "timestamp": "2017-12-08T18:45:36.000319",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "clojure's persistent vectors are not b-trees"
  },
  {
    "timestamp": "2017-12-08T18:45:58.000254",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "I thought they were btrees with 32 fanout -- if not btrees, what are they?"
  },
  {
    "timestamp": "2017-12-08T18:46:25.000004",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<http://hypirion.com/musings/understanding-persistent-vector-pt-1>"
  },
  {
    "timestamp": "2017-12-08T18:46:50.000266",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Berry> if you’re interested have a look at factor, joy, cat, and kitten in this space as well."
  },
  {
    "timestamp": "2017-12-08T18:47:13.000243",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "factor is a ton of fun."
  },
  {
    "timestamp": "2017-12-08T18:47:17.000098",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<@Berry> in particular <http://hypirion.com/musings/understanding-persistent-vector-pt-3>"
  },
  {
    "timestamp": "2017-12-08T18:47:26.000236",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "this is the optimization that makes conj amortized constant time"
  },
  {
    "timestamp": "2017-12-08T18:47:55.000120",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "same for pop/peek"
  },
  {
    "timestamp": "2017-12-08T18:48:31.000363",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "1. the depth of the tree is log_32 n 2. when we do a conj, we have to create a new node at each level of the tree ^-- which is the two above statements is false ? -- because if they're both true, it's log_32 n time EVERY TIME"
  },
  {
    "timestamp": "2017-12-08T18:49:07.000290",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "2 is not true"
  },
  {
    "timestamp": "2017-12-08T18:49:55.000250",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "``` Instead of keeping the rightmost leaf in the tree itself, we keep a direct reference to it in the vector header: That's the last block which has been added to the vector head since last blogpost. The reference to the rightmost leaf node is called the tail. ``` ah"
  },
  {
    "timestamp": "2017-12-08T18:49:59.000135",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "that's clever; bronsa++"
  },
  {
    "timestamp": "2017-12-08T18:50:15.000146",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "well I didn't come up with any of this"
  },
  {
    "timestamp": "2017-12-08T18:50:33.000086",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "thanks for correcting me on this time, I've been thinking conj was log_32 n time"
  },
  {
    "timestamp": "2017-12-08T18:50:33.000299",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": ":smile:"
  },
  {
    "timestamp": "2017-12-08T18:50:49.000176",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "wrt \"what are they\", I've heard the clj vector impl called bitmapped vector trie, not sure if there's a better name"
  },
  {
    "timestamp": "2017-12-08T18:52:17.000298",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Daniell>: I feel like we can get most of forth in clojure by defining macro `f->`, where it behaves like `->` except 1. if it sees a constant (number, kw, string), it pushes it to the stack 2. all functionsin it take stack as input and produces stack as output"
  },
  {
    "timestamp": "2017-12-08T18:57:08.000126",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Berry> the thing is though you’ll need to come up with a way to call out how much of the stack to consume for fn’s that have multiple arities."
  },
  {
    "timestamp": "2017-12-08T18:57:32.000165",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "e.g. how do you interpret `[\"foo\" \"bar\" \"baz\" str]`?"
  },
  {
    "timestamp": "2017-12-08T18:58:11.000004",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<https://twitter.com/brandonbloom/status/528262785642545153> this is still my favourite impl of stack programming in clojure :)"
  },
  {
    "timestamp": "2017-12-08T18:58:49.000051",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "<https://github.com/brandonbloom/factjor> for a more useful impl"
  },
  {
    "timestamp": "2017-12-08T18:59:53.000016",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": ":+1:"
  },
  {
    "timestamp": "2017-12-08T19:00:52.000297",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Deandrea>: afaik, forth doesn't support var-arity functions, so f-> won't either"
  },
  {
    "timestamp": "2017-12-08T19:01:06.000182",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "all functions passed to f-> take a single arg (the stack) as input and produces a stack as output"
  },
  {
    "timestamp": "2017-12-08T19:02:23.000049",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Berry> right but you could imagine something like `[a b c ^{:argc 2} str]` as way to tell the compiler to take 2 args from the stack when applying str to it."
  },
  {
    "timestamp": "2017-12-08T19:03:13.000070",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "(f-> a b c (mod 2 str)), where mod :: int -> func -> func , specifies how many args to take and use"
  },
  {
    "timestamp": "2017-12-08T19:03:40.000183",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "oh nice. i like that."
  },
  {
    "timestamp": "2017-12-08T19:03:40.000215",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "except instead of calling it mod, we should call it m! or something"
  },
  {
    "timestamp": "2017-12-08T19:05:23.000150",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "heh, i sometimes wish clojure had that in core. when mapping over a list of lists (for example) i often want something that takes a number `n` and function `f` and pulls `n` many arguments from each list and applies them to the `f` rather than writing the function that unpacks the arguments by hand. it’s easy to write but i sometimes i wish i didn’t have to. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-08T19:08:20.000144",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "<@Berry> `ap` might be a nice shorthand there. `[a b c str 2 ap]`"
  },
  {
    "timestamp": "2017-12-08T19:21:32.000174",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "<@Deandrea>: how does 'str know to delay evaluation?"
  },
  {
    "timestamp": "2017-12-08T19:22:16.000045",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "i'm assuming nothing but `ap` applies anything"
  },
  {
    "timestamp": "2017-12-08T19:23:50.000094",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "the model I had in mind was: if you get a constant, you push it, if you get a function, you eval it"
  },
  {
    "timestamp": "2017-12-08T19:24:01.000079",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "but in this model, it appears to be \"push until you hit ap\" ?"
  },
  {
    "timestamp": "2017-12-08T19:24:09.000058",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "how would you do HOF then?"
  },
  {
    "timestamp": "2017-12-08T19:24:29.000030",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "can you give me a concrete example you have in mind ?"
  },
  {
    "timestamp": "2017-12-08T19:24:41.000063",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "write `(map inc [1 2 3])`"
  },
  {
    "timestamp": "2017-12-08T19:24:59.000026",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "is [1 2 3] a single arg on the stack, or is it a stack of 3 items ?"
  },
  {
    "timestamp": "2017-12-08T19:25:09.000139",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "that's clojure"
  },
  {
    "timestamp": "2017-12-08T19:25:15.000258",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "write that in your stack based dialect"
  },
  {
    "timestamp": "2017-12-08T19:25:49.000014",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "if your semantics are \"if the top element in my stack is a function, apply it\", then you have no way of using a function as a value"
  },
  {
    "timestamp": "2017-12-08T19:26:44.000033",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "I was going to do all function combinators in clojure"
  },
  {
    "timestamp": "2017-12-08T19:27:09.000176",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "the model I had in mind for `f->` is: 1. f-> gets a list of args 2. eval each arg 3. if arg is a constant, change it to a push 4. if it's a function, apply it"
  },
  {
    "timestamp": "2017-12-08T19:27:47.000072",
    "conversation_id": 1674,
    "user": "Kareen",
    "message": "well good luck, keywords symbols vectors maps sets are functions too"
  },
  {
    "timestamp": "2017-12-08T19:27:59.000202",
    "conversation_id": 1674,
    "user": "Berry",
    "message": "F---"
  },
  {
    "timestamp": "2017-12-08T19:39:30.000039",
    "conversation_id": 1674,
    "user": "Deandrea",
    "message": "@qqq let me get back to you. :wink: I've gotta play with my kids right now. I will be back to meditate on this some more. :smile:"
  },
  {
    "timestamp": "2017-12-15T12:11:55.000054",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "<@Kennith> are you doing gravitational dynamics?"
  },
  {
    "timestamp": "2017-12-15T12:13:35.000390",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "because if so you're making it unnecessarily difficult from a programming standpoint"
  },
  {
    "timestamp": "2017-12-15T12:14:00.000667",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "since from a physics standpoint you'd like to do one pass over the planets and calculate force"
  },
  {
    "timestamp": "2017-12-15T12:14:20.000695",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "and then another pass to update momentum"
  },
  {
    "timestamp": "2017-12-15T12:14:25.000067",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "and another pass to update position"
  },
  {
    "timestamp": "2017-12-15T12:16:13.000338",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "although for speed probably the best thing to do is to solve for the gravitational potential on a grid and then interpolate to get forces, depending on how many planets you have"
  },
  {
    "timestamp": "2017-12-15T12:16:31.000341",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "i doubt there's a good poisson library in javascript, haha"
  },
  {
    "timestamp": "2017-12-15T12:17:23.000155",
    "conversation_id": 1792,
    "user": "Kennith",
    "message": "<@Priscilla> I am, I am trying to reimplement this: <https://github.com/raisoman/de-for-children/blob/master/processingjs/p5/mars-trip.html> in cljs."
  },
  {
    "timestamp": "2017-12-15T12:21:19.000672",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "ya, from a physics POV, that code would be better if it accumulated `xpp` and `ypp` in arrays"
  },
  {
    "timestamp": "2017-12-15T12:21:51.000210",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "and only actually moved the planets after it had calculated that for all of them"
  },
  {
    "timestamp": "2017-12-15T12:22:33.000221",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "splitting hairs, probably; the errors from doing it as linked take many orbits to be visible"
  },
  {
    "timestamp": "2017-12-15T12:24:09.000199",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "`(comp (map #(update-position planets)) (map get-force))`"
  },
  {
    "timestamp": "2017-12-15T12:24:25.000681",
    "conversation_id": 1792,
    "user": "Priscilla",
    "message": "would give you pretty much what you need"
  },
  {
    "timestamp": "2017-12-15T12:27:32.000343",
    "conversation_id": 1792,
    "user": "Kennith",
    "message": "<@Priscilla> I also had a sneaking suspicion that my original was actually more correct, but the constants are calibrated to work with the js version, which is quite sensitive to starting conditions since it is inserting a tiny space-ship into orbit around mars. Not that I really understand the physics very well :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-15T12:51:46.000162",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "`(send-off ... (retry fn) ...)`"
  },
  {
    "timestamp": "2017-12-15T12:53:02.000028",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "``` (defn retry [f] (fn x [& args] (try (apply f args) (catch Throwable t (apply x args))))) ```"
  },
  {
    "timestamp": "2017-12-15T14:16:27.000354",
    "conversation_id": 1792,
    "user": "Berry",
    "message": "inside a (fn [] .... ) is there a way to \"refer to self, i.e. the function being defined\" -- and this is not via recur"
  },
  {
    "timestamp": "2017-12-15T14:17:24.000347",
    "conversation_id": 1792,
    "user": "Erlene",
    "message": "Why are you not able to use recur?"
  },
  {
    "timestamp": "2017-12-15T14:17:41.000393",
    "conversation_id": 1792,
    "user": "Felix",
    "message": "you can name a fn (fn f [] …)"
  },
  {
    "timestamp": "2017-12-15T14:23:25.000463",
    "conversation_id": 1792,
    "user": "Berry",
    "message": "because I need to call the function two/three times, in a tree like fashion, it's not a loop"
  },
  {
    "timestamp": "2017-12-15T14:24:01.000257",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "yeah, that’s why the `(fn f [] ...)` syntax exists, it’s the straightforward way to do this"
  },
  {
    "timestamp": "2017-12-15T14:24:26.000167",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "though if two functions need to do this mutually, `letfn` exists for that purpose and no other"
  },
  {
    "timestamp": "2017-12-15T14:24:57.000354",
    "conversation_id": 1792,
    "user": "Berry",
    "message": "ah, the `(fn f [] ...)` syntax gives it a name I can refer to it by; no idea howI missed it all these years; thanks!"
  },
  {
    "timestamp": "2017-12-15T14:25:19.000447",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "extra bonus - when you use (fn f [] …) the name “f” will show up in a stack trace"
  },
  {
    "timestamp": "2017-12-15T14:25:44.000008",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "sometimes I name my fn even if it doesn’t self call just so my stack traces will make a little more sense"
  },
  {
    "timestamp": "2017-12-15T14:26:23.000407",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "it makes me want versions of partial and comp and complement and fnil etc. that take a “name” parameter too frankly"
  },
  {
    "timestamp": "2017-12-15T14:52:38.000151",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "it is not a syntax, keywords are functions"
  },
  {
    "timestamp": "2017-12-15T14:52:56.000412",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "symbols, hash-maps, sets, and vectors are also functions"
  },
  {
    "timestamp": "2017-12-15T14:53:22.000502",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "at one point they argued about making regexes functions too but they opted not to do that"
  },
  {
    "timestamp": "2017-12-15T14:53:34.000307",
    "conversation_id": 1792,
    "user": "Myles",
    "message": "specifically, keywords implement IFn"
  },
  {
    "timestamp": "2017-12-15T14:53:45.000343",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "ah? do you remember when ?"
  },
  {
    "timestamp": "2017-12-15T14:53:55.000391",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "@chris right when I say “is a function” about clojure that means “implements IFn”"
  },
  {
    "timestamp": "2017-12-15T14:54:16.000117",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "no - I have seen discussion about it but forget the details"
  },
  {
    "timestamp": "2017-12-15T14:55:04.000548",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "But there must be something special about them because there are an infinite number of them and they spring forth whenever you use them"
  },
  {
    "timestamp": "2017-12-15T14:55:22.000540",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "@Justin how’s that different from fn?"
  },
  {
    "timestamp": "2017-12-15T14:55:27.000452",
    "conversation_id": 1792,
    "user": "Myles",
    "message": "is that different from how a function works?"
  },
  {
    "timestamp": "2017-12-15T14:55:31.000478",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "haha"
  },
  {
    "timestamp": "2017-12-15T14:55:35.000109",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "or a symbol"
  },
  {
    "timestamp": "2017-12-15T14:55:38.000435",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "I've never seen serious discussion about it, just perennial whinging about how nice or how cool it would be if it was the case"
  },
  {
    "timestamp": "2017-12-15T14:55:52.000366",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "the reader interns symbols/keywords"
  },
  {
    "timestamp": "2017-12-15T14:56:04.000231",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "yeah same"
  },
  {
    "timestamp": "2017-12-15T14:56:14.000285",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "but symbols can have metadata so they do something different about the interning right?"
  },
  {
    "timestamp": "2017-12-15T14:56:42.000153",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "yeah symbols just have their internal string interned"
  },
  {
    "timestamp": "2017-12-15T14:56:54.000228",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "actually since a few versions ago that might not be true, I can't remember"
  },
  {
    "timestamp": "2017-12-15T14:57:16.000751",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "one possible answer “pattern is a final class” <https://groups.google.com/forum/#!topic/clojure/LiWT7NIJOdQ>"
  },
  {
    "timestamp": "2017-12-15T14:59:57.000518",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "and interning has nothing to do with being used as a function"
  },
  {
    "timestamp": "2017-12-15T15:00:53.000048",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "true, I was just answering how they \"pop out of existence\""
  },
  {
    "timestamp": "2017-12-15T15:01:09.000131",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "`(foo a b c)` in clojure is something like `((IFn)foo).invoke(a, b, c)` in java"
  },
  {
    "timestamp": "2017-12-15T15:01:30.000144",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "I previously just thought of them as identifiers that had some concrete unique representation that allowed them to be used as keys in a map. But then they can also be used in the first position in a list (which I think of as “function” position but I’m sure it has a more precise name). I suppose the point is that they are instantiated as lookup functions the moment the reader sees them and the reference to that lookup function is what is used as a key?"
  },
  {
    "timestamp": "2017-12-15T15:01:53.000379",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "they are instances of clojure.lang.Keyword"
  },
  {
    "timestamp": "2017-12-15T15:01:59.000025",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "which implements IFn"
  },
  {
    "timestamp": "2017-12-15T15:02:08.000215",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "clojure.lang.IFn"
  },
  {
    "timestamp": "2017-12-15T15:02:26.000205",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "oh right. okay got it"
  },
  {
    "timestamp": "2017-12-15T15:02:29.000031",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "thanks all"
  },
  {
    "timestamp": "2017-12-15T15:02:40.000258",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "@Justin also, regarding “allowed to use them as keys in a map” that’s true of literally any value in clojure"
  },
  {
    "timestamp": "2017-12-15T15:02:51.000187",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "as an aside"
  },
  {
    "timestamp": "2017-12-15T15:03:14.000202",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "`(:foo {:foo 1})` becomes something like `new Keyword (\"foo\").invoke ( {:foo 1 })`"
  },
  {
    "timestamp": "2017-12-15T15:03:24.000093",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "any object on the jvm that doesn't replace Object's hashCode and equals with methods that throw execeptions"
  },
  {
    "timestamp": "2017-12-15T15:03:40.000638",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "which is implemented roughly as `{:foo 1}.get(this)`"
  },
  {
    "timestamp": "2017-12-15T15:04:07.000338",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "clojure values just make better keys then most objects on the jvm"
  },
  {
    "timestamp": "2017-12-15T15:04:48.000444",
    "conversation_id": 1792,
    "user": "Myles",
    "message": "immutability is a good idea™"
  },
  {
    "timestamp": "2017-12-15T15:05:32.000352",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "ahh right- you can use a mutable thing as a key, but if the mutation changes the hash or equality you will have a bad time haha"
  },
  {
    "timestamp": "2017-12-15T15:06:07.000684",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "<@Margaret> Right that was phrased awkwardly. Keywords are a little interesting because unlike something like a let binding or a formal parameter, what you call the keyword actually changes something in memory. I guess that’s no different from a string literal but it has always felt unusual to me because a keyword looks like a formal name rather than data."
  },
  {
    "timestamp": "2017-12-15T15:06:20.000370",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "At least I think that’s right."
  },
  {
    "timestamp": "2017-12-15T15:06:31.000610",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "keywords are data, not labels"
  },
  {
    "timestamp": "2017-12-15T15:06:48.000096",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "just like a string or a number"
  },
  {
    "timestamp": "2017-12-15T15:07:08.000067",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "same with symbols"
  },
  {
    "timestamp": "2017-12-15T15:07:24.000207",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "Thanks yea that’s important to remember. Because to my C/C++/JS mind they look like names."
  },
  {
    "timestamp": "2017-12-15T15:07:34.000347",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "(in fact they are listed under data_structures on <http://clojure.org|clojure.org>, <https://clojure.org/reference/data_structures>)"
  },
  {
    "timestamp": "2017-12-15T15:08:14.000372",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "apart from reader macros, there's no labels or language syntax that's not reified as a value"
  },
  {
    "timestamp": "2017-12-15T15:10:54.000346",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "let bindings are sneaky to find, and even sneakier to do anything with as data haha but yeah <https://gist.github.com/noisesmith/3490f2d3ed98e294e033b002bc2de178>"
  },
  {
    "timestamp": "2017-12-15T15:11:35.000162",
    "conversation_id": 1792,
    "user": "Thu",
    "message": "omg"
  },
  {
    "timestamp": "2017-12-15T15:12:15.000329",
    "conversation_id": 1792,
    "user": "Petronila",
    "message": "Beyond the `(keys &env)` I wouldn’t really consider let-bindings to be “reified” (officially) in clj"
  },
  {
    "timestamp": "2017-12-15T15:12:34.000218",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "right - but that snippet proves they are reified"
  },
  {
    "timestamp": "2017-12-15T15:12:42.000100",
    "conversation_id": 1792,
    "user": "Petronila",
    "message": "sort of"
  },
  {
    "timestamp": "2017-12-15T15:12:42.000420",
    "conversation_id": 1792,
    "user": "Petronila",
    "message": "hah"
  },
  {
    "timestamp": "2017-12-15T15:12:42.000454",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "no"
  },
  {
    "timestamp": "2017-12-15T15:13:10.000104",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "you are reading compiler state using the macro and generating code to reproduce it at runtime"
  },
  {
    "timestamp": "2017-12-15T15:13:30.000012",
    "conversation_id": 1792,
    "user": "Margaret",
    "message": "oh… that is different OK"
  },
  {
    "timestamp": "2017-12-15T15:14:04.000290",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "what bronsa meant is `(let [a 1] a)` is not \"syntax\" as such, it is a list containing a symbol, a vector, and another symbol"
  },
  {
    "timestamp": "2017-12-15T15:19:43.000181",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "``` user=> ((fn [x] ((x {:a {:a 1}}) x)) :a) 1 user=> ``` might be interesting to puzzle out when learning about keywords"
  },
  {
    "timestamp": "2017-12-15T15:32:48.000632",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "well, no, right? because the reader doesn't determine what a valid keyword is"
  },
  {
    "timestamp": "2017-12-15T15:41:31.000368",
    "conversation_id": 1792,
    "user": "Micha",
    "message": "If an implementation doesn't stop you, someone somewhere will do it. :slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-15T15:41:55.000040",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "and think it is a great idea"
  },
  {
    "timestamp": "2017-12-15T15:44:05.000129",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "there is a lot of background on this - the regex for keywords in the reader is actually wrong, which is why it works"
  },
  {
    "timestamp": "2017-12-15T15:44:21.000070",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "we “fixed” it in 1.6 and found out it broke a lot of existing code"
  },
  {
    "timestamp": "2017-12-15T15:44:28.000182",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "so we unfixed it"
  },
  {
    "timestamp": "2017-12-15T15:45:12.000055",
    "conversation_id": 1792,
    "user": "Micha",
    "message": "Taking advantage of such behavior does put you at some kind of risk of a future version of Clojure reserving characters for other purposes, and now either you update your application or don't run it or its data with that version of Clojure. Given sensitivity to backwards compatibility by core team, I doubt they would break such things for fun."
  },
  {
    "timestamp": "2017-12-15T15:45:36.000171",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "I’d say at this point that there is no chance we will take that away"
  },
  {
    "timestamp": "2017-12-15T15:45:45.000043",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "we did break it, and it wasn’t fun"
  },
  {
    "timestamp": "2017-12-15T15:48:25.000390",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "I notice one can now override `*reader-resolver*` in Clojure 1.9. Has anyone tried this? What scenarios is it useful for?"
  },
  {
    "timestamp": "2017-12-15T15:49:38.000364",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "If I wanted to write a utility that overrode `*reader-resolver*` to do cool stuff, I would have to `alter-var-root` it rather than `bindings` it so that I can load code with that new reader resolver in place, right?"
  },
  {
    "timestamp": "2017-12-15T15:50:50.000329",
    "conversation_id": 1792,
    "user": "Gladys",
    "message": "thx, after all I did this: ``` (def queue (agent [] :error-handler (fn [a ex] (l/error ex \"slack agent failed\") (restart-agent a @a)))) ```"
  },
  {
    "timestamp": "2017-12-15T15:50:56.000156",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "it’s useful if you want to have control over how namespace-sensitive things resolve (like autoresolved keywords)"
  },
  {
    "timestamp": "2017-12-15T15:51:32.000406",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "Looks like I can affect the behavior of `read-string`: ``` user=> (binding [*reader-resolver* (reify clojure.lang.LispReader$Resolver (resolveAlias [this sym] 'blah))] (read-string \"::a/b\")) :blah/b ```"
  },
  {
    "timestamp": "2017-12-15T15:51:54.000333",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "It seems to me that that's the only thing I can do with `binding`"
  },
  {
    "timestamp": "2017-12-15T15:51:59.000387",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "Just want to make sure that's accurate"
  },
  {
    "timestamp": "2017-12-15T15:52:04.000296",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "yes"
  },
  {
    "timestamp": "2017-12-15T15:52:30.000224",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "really best for programmatic reader cases where you are creating the environment (not for general code loading in the RT)"
  },
  {
    "timestamp": "2017-12-15T15:52:47.000298",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "gotcha, that's what I wanted to confirm"
  },
  {
    "timestamp": "2017-12-15T15:52:48.000322",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "thanks"
  },
  {
    "timestamp": "2017-12-15T15:53:08.000288",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "I was hoping I could write myself a `with-aliases` macro that lets me define arbitrary aliases in local scope or something"
  },
  {
    "timestamp": "2017-12-15T15:54:16.000059",
    "conversation_id": 1792,
    "user": "Sonny",
    "message": "I think reading has already been done at macro time so that wouldn’t work"
  },
  {
    "timestamp": "2017-12-15T15:54:28.000602",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "yep"
  },
  {
    "timestamp": "2017-12-15T15:54:32.000425",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "yep"
  },
  {
    "timestamp": "2017-12-15T15:56:36.000212",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "unless I use `push-thread-bindings` and `pop-thread-bindings`...."
  },
  {
    "timestamp": "2017-12-15T15:57:05.000236",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "then I could write a `defalias` macro that pushes a new `*reader-resolver*` for the remainder of that file"
  },
  {
    "timestamp": "2017-12-15T15:57:15.000218",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "but then I don't know when to pop it"
  },
  {
    "timestamp": "2017-12-15T15:59:43.000312",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "having a `push-thread-binding` escape its lexical context is not a good idea anyway"
  },
  {
    "timestamp": "2017-12-15T16:00:13.000533",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "``` (ns my.ns) (defalias o other.ns) ::o/a-keyword (end-aliases!) ``` :troll:"
  },
  {
    "timestamp": "2017-12-15T16:01:07.000056",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "if your `push-thread-binding` gets executed from within a `binding`, that `binding `ill pop the wrong thing"
  },
  {
    "timestamp": "2017-12-15T16:01:27.000392",
    "conversation_id": 1792,
    "user": "Rebeca",
    "message": "if you are going to be gross, hijack the dispatchMacros table in the reader"
  },
  {
    "timestamp": "2017-12-15T16:02:06.000163",
    "conversation_id": 1792,
    "user": "Kareen",
    "message": "haha"
  },
  {
    "timestamp": "2017-12-15T16:02:13.000402",
    "conversation_id": 1792,
    "user": "Edelmira",
    "message": "brb forking Clojure"
  },
  {
    "timestamp": "2017-12-27T20:59:38.000073",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "hey, has anyone successfully used a go block in clojure >=1.7.0? i am having trouble with it not closing over its scope properly, so `(let [c (chan)] (go (prn (<! c))))` gets me `Unable to resolve var: c`"
  },
  {
    "timestamp": "2017-12-27T20:59:55.000093",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "this is right out of the tutorial, and it works in clojure 1.6"
  },
  {
    "timestamp": "2017-12-27T21:00:05.000140",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "but that seems like an awful long time for something so fundamental to be broken"
  },
  {
    "timestamp": "2017-12-27T21:00:12.000052",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "so i’m open to it being totally my problem"
  },
  {
    "timestamp": "2017-12-27T21:00:55.000085",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "the weird thing about that block of code is that core.async should treat it as a noop returning a channel that never delivers"
  },
  {
    "timestamp": "2017-12-27T21:01:02.000009",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "since nothing can possibly use c"
  },
  {
    "timestamp": "2017-12-27T21:01:34.000024",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i mean, there’s a more complicated version of that code, which also fails with the same issue, which actually does do a real hello world with the channels, in the tutorial"
  },
  {
    "timestamp": "2017-12-27T21:01:44.000181",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "but i stripped it down to just that being enough for it to fail with the same issue"
  },
  {
    "timestamp": "2017-12-27T21:02:11.000137",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "```Clojure 1.9.0 +user=> (require '[clojure.core.async :as > :refer [go chan <!]]) nil +user=> (let [c (chan)] (go (prn (<! c)))) #object[clojure.core.async.impl.channels.ManyToManyChannel 0x1e5e2e06 \"clojure.core.async.impl.channels.ManyToManyChannel@1e5e2e06\"] ```"
  },
  {
    "timestamp": "2017-12-27T21:02:39.000093",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i accidentally had written a lot of actually working code before realizing this issue, because i had `def`ed a channel with the same name as i was using inside go blocks"
  },
  {
    "timestamp": "2017-12-27T21:02:46.000032",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "ok well what the crap"
  },
  {
    "timestamp": "2017-12-27T21:02:57.000155",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "what core.async version are you using?"
  },
  {
    "timestamp": "2017-12-27T21:03:20.000002",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "0.3.465"
  },
  {
    "timestamp": "2017-12-27T21:03:27.000062",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i tried a lot of releases"
  },
  {
    "timestamp": "2017-12-27T21:03:37.000068",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "that's the version I was using"
  },
  {
    "timestamp": "2017-12-27T21:04:34.000034",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "this is straight up clojure + core.async running from a custom uberjar (project here <https://github.com/noisesmith/bench> - I just run lein uberjar then make the jar an executable)"
  },
  {
    "timestamp": "2017-12-27T21:04:52.000117",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "```option-bot.core> (require '[clojure.core.async :as > :refer [go chan <!]]) nil option-bot.core> (let [c (chan)] (go (prn (<! c)))) ExceptionInfo Could not resolve var: c clojure.core/ex-info (core.clj:4739)```"
  },
  {
    "timestamp": "2017-12-27T21:05:32.000083",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "are you using leiningen? if so try using lein clean then starting a new repl"
  },
  {
    "timestamp": "2017-12-27T21:05:53.000149",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "sometimes things can get wonky with core.async and lein caches when versions of things change, in my experience"
  },
  {
    "timestamp": "2017-12-27T21:07:04.000119",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "same deal :disappointed:"
  },
  {
    "timestamp": "2017-12-27T21:07:50.000071",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "are you using any weird plugins? is there a chance that `lein deps :tree` shows a version conflict that would give you the wrong version of core.async?"
  },
  {
    "timestamp": "2017-12-27T21:08:20.000023",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "nah, it’s pretty simple"
  },
  {
    "timestamp": "2017-12-27T21:08:23.000029",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "``` [clojure-complete \"0.2.4\" :exclusions [[org.clojure/clojure]]] [org.clojure/clojure \"1.9.0\"] [org.clojure/core.specs.alpha \"0.1.24\"] [org.clojure/spec.alpha \"0.1.143\"] [org.clojure/core.async \"0.3.465\"] [org.clojure/tools.analyzer.jvm \"0.7.0\"] [org.clojure/core.memoize \"0.5.9\"] [org.clojure/core.cache \"0.6.5\"] [org.clojure/data.priority-map \"0.0.7\"] [org.clojure/tools.analyzer \"0.6.9\"] [org.clojure/tools.reader \"1.0.0-beta4\"] [org.ow2.asm/asm-all \"4.2\"] [org.clojure/tools.nrepl \"0.2.12\" :exclusions [[org.clojure/clojure]]] [self/ib \"9.73.01-SNAPSHOT\"]```"
  },
  {
    "timestamp": "2017-12-27T21:08:46.000134",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i mean, there is one custom java api library, but that shouldn’t do anything like this, i wouldn’t think"
  },
  {
    "timestamp": "2017-12-27T21:08:54.000007",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "I'm going to see if a project with those deps gives me the same issue"
  },
  {
    "timestamp": "2017-12-27T21:09:11.000036",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "(ignoring self/lib that is)"
  },
  {
    "timestamp": "2017-12-27T21:09:31.000156",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "well, hm"
  },
  {
    "timestamp": "2017-12-27T21:09:44.000049",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i just did `lein repl` and that works"
  },
  {
    "timestamp": "2017-12-27T21:09:47.000176",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "so it’s just cider that’s the problem"
  },
  {
    "timestamp": "2017-12-27T21:10:11.000056",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "cider is clearly doing something goofy"
  },
  {
    "timestamp": "2017-12-27T21:10:28.000004",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "thanks for figuring it out before I had to do more work heh"
  },
  {
    "timestamp": "2017-12-27T21:10:33.000074",
    "conversation_id": 1956,
    "user": "Linn",
    "message": ":slightly_smiling_face:"
  },
  {
    "timestamp": "2017-12-27T21:11:02.000045",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "so I guess the answer to \"are you using any weird plugins\" is \"we didn't realize how weird cider is\""
  },
  {
    "timestamp": "2017-12-27T21:11:02.000053",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "guess i’ll try updating that"
  },
  {
    "timestamp": "2017-12-27T21:11:06.000120",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "haha, yeah"
  },
  {
    "timestamp": "2017-12-27T21:11:31.000114",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "Tooling, the cause of, and solution to, every problem we have when programming clojure."
  },
  {
    "timestamp": "2017-12-27T21:11:52.000132",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "(to paraphrase homer simpson)"
  },
  {
    "timestamp": "2017-12-27T21:12:04.000155",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "and i thought every issue i had with it had been fixed now that cider could pass its plugin versions into lein"
  },
  {
    "timestamp": "2017-12-27T21:12:33.000085",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "I stopped trying to figure that magic out a long time ago ¯\\_(ツ)_/¯"
  },
  {
    "timestamp": "2017-12-27T21:13:37.000011",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "updated cider, it all appears to work"
  },
  {
    "timestamp": "2017-12-27T21:13:41.000023",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "lost my awesome scratch buffer"
  },
  {
    "timestamp": "2017-12-27T21:13:42.000090",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "oh well"
  },
  {
    "timestamp": "2017-12-27T21:15:02.000170",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "thanks for being a sanity check"
  },
  {
    "timestamp": "2017-12-27T21:15:16.000122",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i was like “there’s no way this has actually been broken for the last three years, right?”"
  },
  {
    "timestamp": "2017-12-27T21:22:11.000095",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "so here’s a more general question"
  },
  {
    "timestamp": "2017-12-27T21:22:40.000066",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "what’s a good way to represent a record that requires multiple api calls (and callbacks) to be fully realized?"
  },
  {
    "timestamp": "2017-12-27T21:22:48.000093",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "like, i have a representation of a stock"
  },
  {
    "timestamp": "2017-12-27T21:23:11.000117",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "and there’s a bunch of static info about it that’s just intrinsic to it"
  },
  {
    "timestamp": "2017-12-27T21:23:42.000116",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "but then also it kind of has a price, right? but to get the price, that’s the result of some other call"
  },
  {
    "timestamp": "2017-12-27T21:24:07.000152",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "so i have been putting that behind a `future`"
  },
  {
    "timestamp": "2017-12-27T21:24:16.000072",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "a good functional technique is to put the price and the time in there together, and make sure all price queries are explicit about time windows they accept"
  },
  {
    "timestamp": "2017-12-27T21:24:51.000066",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "and sure, you can put a future in, you could also have a function that returns a future that returns a new instance of your record (with a newer time stamp) when realized"
  },
  {
    "timestamp": "2017-12-27T21:24:59.000095",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "that ensures the parts of the record are all in sync"
  },
  {
    "timestamp": "2017-12-27T21:25:35.000122",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "oh and then i’d have some fn `get-price` (or maybe use `conform`) and it’d get me the price that was cached if it was fresh enough"
  },
  {
    "timestamp": "2017-12-27T21:25:39.000031",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "or go get a new one"
  },
  {
    "timestamp": "2017-12-27T21:25:44.000040",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "also, you could use a TTL cache (clojure core.cache provides this) and retrieve the price from the cache"
  },
  {
    "timestamp": "2017-12-27T21:25:55.000106",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "if the record is created recently enough, it's returned, otherwise queried"
  },
  {
    "timestamp": "2017-12-27T21:26:31.000014",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "ooh"
  },
  {
    "timestamp": "2017-12-27T21:26:56.000047",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "the nice thing with core.cache is that it doesn't force a specific storage - it just takes a hash-map and returns a new one, and you can put this in a local that propagates via recur, or put it in a ref, or an atom, or even a proper db if you serialize it right - it should just work"
  },
  {
    "timestamp": "2017-12-27T21:27:13.000200",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "(as long as you always use the new hash-map it returns of course)"
  },
  {
    "timestamp": "2017-12-27T21:27:30.000065",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "that’s super handy"
  },
  {
    "timestamp": "2017-12-27T21:27:46.000079",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "<https://github.com/clojure/core.cache>"
  },
  {
    "timestamp": "2017-12-27T21:27:47.000084",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "because yeah i’m making a lot of wasteful API calls"
  },
  {
    "timestamp": "2017-12-27T21:27:59.000005",
    "conversation_id": 1956,
    "user": "Berry",
    "message": "<https://docs.oracle.com/javase/7/docs/api/java/io/DataInputStream.html#readFully(byte[])> <-- where is this readFully contract definedd ?"
  },
  {
    "timestamp": "2017-12-27T21:28:08.000151",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i basically just hacked together some bullshit that worked for now with promises/futures"
  },
  {
    "timestamp": "2017-12-27T21:28:11.000007",
    "conversation_id": 1956,
    "user": "Berry",
    "message": "I'm trying to read 10k bytes from a file, and I don't wnat to loop; I want to make on3 call and have java read it for me"
  },
  {
    "timestamp": "2017-12-27T21:28:13.000111",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "I use core.cache in front of mongo documents encoded via transit"
  },
  {
    "timestamp": "2017-12-27T21:28:24.000146",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "now i’m trying to go back and use core.async channels to model the continuous updates"
  },
  {
    "timestamp": "2017-12-27T21:28:34.000051",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "the core.cache protocols do all the cache ttl logic, and transit handles the serialization, and mongo the storage"
  },
  {
    "timestamp": "2017-12-27T21:30:25.000098",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "regarding mongo - I wouldn't necessarily recommend for a new project, it was inherited as part of the team expertise if that makes any sense"
  },
  {
    "timestamp": "2017-12-27T21:30:40.000150",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "yeah i haven’t even begun to think about a persistence layer"
  },
  {
    "timestamp": "2017-12-27T21:30:50.000210",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i’m doing like super elementary algorithmic trading"
  },
  {
    "timestamp": "2017-12-27T21:31:03.000156",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "mostly because i want to stop having to wake up at like 4am to catch market opens"
  },
  {
    "timestamp": "2017-12-27T21:31:36.000030",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "so far clojure’s concurrency stuff has been as good as i expected for this"
  },
  {
    "timestamp": "2017-12-27T21:31:38.000003",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "yeah, core.cache also does simple in-memory cache with ttl which is what I'm sure you actually want - for those mongo caches I'm measuring the ttl in days not minutes"
  },
  {
    "timestamp": "2017-12-27T21:31:45.000097",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "haha, yup"
  },
  {
    "timestamp": "2017-12-27T21:31:48.000098",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "it’d be like seconds"
  },
  {
    "timestamp": "2017-12-27T21:32:10.000059",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "but there are some other queries that i might want to store for longer"
  },
  {
    "timestamp": "2017-12-27T21:32:26.000088",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "like, price data, seconds, but the actual existence of the contracts i’m interested in"
  },
  {
    "timestamp": "2017-12-27T21:32:36.000037",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "that can be cached for a long time"
  },
  {
    "timestamp": "2017-12-27T21:32:36.000083",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "also the simplest solution would be to use an atom for your cache, but if you start to hit contention slowdowns you could use multiple refs instead of an atom with multiple keys in it"
  },
  {
    "timestamp": "2017-12-27T21:32:53.000087",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i am also thinking like"
  },
  {
    "timestamp": "2017-12-27T21:33:10.000027",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "oh, instead of handing out refs like candy and then trying to update them in place"
  },
  {
    "timestamp": "2017-12-27T21:33:39.000003",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i guess i should make a function that is like `get-contract` and then have that access the cache or synthesize a new contract info object"
  },
  {
    "timestamp": "2017-12-27T21:33:58.000020",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "using lots of refs does work (and performs better under heavy write load) it's just a more complex design than a hash-map in an atom with a key for each \"thing\""
  },
  {
    "timestamp": "2017-12-27T21:34:01.000049",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i have been thinking it would be kind of neat to have an agent for every contract i’m keeping track of"
  },
  {
    "timestamp": "2017-12-27T21:34:22.000033",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "and then just deref the contract for the current state"
  },
  {
    "timestamp": "2017-12-27T21:34:39.000076",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "but maybe using an explicit cache would be much better"
  },
  {
    "timestamp": "2017-12-27T21:35:02.000023",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "oh, that’s what you were saying, though"
  },
  {
    "timestamp": "2017-12-27T21:35:07.000149",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "a ref for every cache entry?"
  },
  {
    "timestamp": "2017-12-27T21:35:34.000035",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "caching logic is notoriously tricky to get right, and core.cache helps a lot with that; I was surprised - I did a big cache with a lot of features built on core.cache and it worked without a hitch after the trivial data bugs were fixed"
  },
  {
    "timestamp": "2017-12-27T21:37:09.000089",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "<@Linn> I'm trying to work out what this would require - it's a lot simpler to add keys on demand to an atom, but you could also hypothetically manage multiple refs but then you have the question of what tracks these on-demand refs and then I'm like \"refs inside an atom\" and no that is insanity"
  },
  {
    "timestamp": "2017-12-27T21:37:21.000064",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "lol"
  },
  {
    "timestamp": "2017-12-27T21:37:26.000155",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "that’s where i went too"
  },
  {
    "timestamp": "2017-12-27T21:37:29.000008",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "it was like aaaaa"
  },
  {
    "timestamp": "2017-12-27T21:37:45.000019",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "because the idea of a record that magically updates itself"
  },
  {
    "timestamp": "2017-12-27T21:38:19.000061",
    "conversation_id": 1956,
    "user": "Linn",
    "message": "i guess for right now, it’s not a big deal, i can just have a single atom with a map"
  },
  {
    "timestamp": "2017-12-27T21:38:39.000061",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "if you know it's always 10k bytes or less why not pass a 10k byte-array to the read method?"
  },
  {
    "timestamp": "2017-12-27T21:40:03.000070",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "here's DataInput readFully <https://docs.oracle.com/javase/7/docs/api/java/io/DataInput.html#readFully(byte[])>"
  },
  {
    "timestamp": "2017-12-27T21:40:20.000127",
    "conversation_id": 1956,
    "user": "Margaret",
    "message": "it's saying \"look at the method foo on class bar\" - it's just phrasing it kind of weird"
  }
]